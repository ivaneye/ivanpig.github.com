<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="static blog" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clojure简介</title>
  <link rel="stylesheet" href="../stylesheets/bootstrap.min.css"/>
  <link rel="stylesheet" href="../stylesheets/blog.css"/>
  <link rel="stylesheet" href="../stylesheets/themes/my.css"/>
  <script src="../javascripts/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body><!--
    <header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role="banner">
      <div class="container">
      <h1 class="title"></h1>
                          </div>
  </header>
   -->
  <div class="container">
    <div class="row">
           <p>% Clojure简介</p><h1>前言</h1><p>此文为后续介绍RPC应用做铺垫,如果没兴趣,可直接忽略.</p><h1>Clojure</h1><p>Clojure是JVM上的Lisp实现.Lisp是1958年,约翰·麦卡锡发明的语言,是第二老的语言.语法非常异类!!!</p><p>Lisp从未成为主流语言,至少到目前是!但是很多大牛对其推崇备至.例如:保罗·格雷厄姆,<<黑客与画家>>, << OnLisp>>作者,硅谷创业之父.(李开复山寨了他,创办了创新工场)</p><p>我之所以会盯上这门语言,基于如下几个原因:</p><ul><li>方便个人独立开发,动态语言是首选,例如Ruby,Python,Groovy等</li><li>但是不能浪费了我在jvm上的投资,所以忽略Ruby,Python等非jvm语言</li><li>JVM上语言众多,但是    JRuby,Jython版本迭代明显落后于Ruby,Python    Groovy之父都放弃Groovy了,现在Groovy完全靠社区发展    Scala太复杂,且是静态语言,API文档晦涩难懂,绝对是JVM上的C++</li><li>与Java要有足够多的区别,才能跳出以前的思维范畴</li><li>有足够多的新特性</li><li>我目前比较喜欢这个怪异的语法!!</li></ul><p>附上Scala文档和Clojure文档比较</p><pre><code class="Scala">
def reduce&#91;A1 &gt;: A&#93;&#40;op: &#40;A1, A1&#41; ⇒ A1&#41;: A1

Reduces the elements of this traversable or iterator using the specified associative binary operator.
</code></pre><pre><code class="clojure">
reduce

function
Usage: &#40;reduce f coll&#41;
       &#40;reduce f val coll&#41;

f should be a function of 2 arguments. If val is not supplied,
returns the result of applying f to the first 2 items in coll, then
applying f to that result and the 3rd item, etc. If coll contains no
items, f must accept no arguments as well, and reduce returns the
result of calling f with no arguments.  If coll has only 1 item, it
is returned and f is not called.  If val is supplied, returns the
result of applying f to val and the first item in coll, then
applying f to that result and the 2nd item, etc. If coll contains no
items, returns val and f is not called.
</code></pre><h1>安装</h1><p>Clojure无需安装,就是一个jar包而已.它提供了编译器的功能,将Clojure语法编译为class文件,给JVM运行.</p><h1>语法高度统一</h1><p>Java有关键字近100个,你需要学习所有的关键字,每个关键字的语法还不同,比如如何定义class,如何定义方法等等,每个都需要记忆.</p><p>Clojure只有十几个Special Form(相当于Java关键字,关键字在Clojure指另外的东西),且语法一致:</p><pre><code class="clojure">
&#40;special form/函数/宏 参数&#41;
</code></pre>实例:<pre><code class="clojure">
&#40;def a 1&#41;         ;def相当于Java中的关键字,这里叫Special Form

&#40;defn p &#91;s&#93;       ;defn是个宏,后面全部是参数
  &#40;println s&#41;&#41;    ;这里定义了一个函数,名字叫p,参数是s,动作是打印

&#40;p a&#41;             ;p是上面定义的函数,a是前面定义的var&#40;类似Java中的变量&#41;
</code></pre><p>上面就是Clojure所有的语法,剩下的事情就是学习API</p><h1>REPL</h1><p>几乎所有的动态语言都会提供REPL(Read-Eval-Print-Loop).Java也有叫BeanShell的第三方软件(我没启动成功). REPL能够方便的进行试探性开发.你能直接在REPL中输入代码,然后立即得到结果.而不需要像Java一样, 打开IDE->新建文件->编写代码->点击运行->有问题再修改.</p><pre><code class="sh">
user=&gt; &#40;+ 1 2 3&#41;
6
user=&gt; &#40;println 123&#41;
123
nil
user=&gt; &#40;println &quot;Hello&quot;&#41;
Hello
nil
user=&gt;
</code></pre><h1>集合处理</h1><ul><li>假设有一个集合[1 2 3 4 5 6 7 8]</li><li>请将每个元素加一</li><li>求集合的和</li><li>过滤奇数/偶数</li></ul><p>对于这些问题 ,Java需要如何处理?请自行脑补!</p><pre><code class="clojure">
&#40;def v &#91;1 2 3 4 5 6 7 8&#93;&#41;

;每个元素加一
&#40;map inc v&#41;

;求集合的和
&#40;reduce + v&#41;

;过滤奇数
&#40;filter #&#40;= &#40;rem % 2&#41; 0&#41; v&#41;

;过滤偶数
&#40;filter #&#40;= &#40;rem % 2&#41; 1&#41; v&#41;

</code></pre><h1>解构</h1><p>如果你有一个List,你想取前面两个数据.又或者你有一个Map,你想取指定的key值.想想Java怎么获取?</p><pre><code class="clojure">
;解构集合,这里集合是&#91;1 2 3&#93;,自动将1赋值为a,2赋值为b,打印1 2
&#40;let &#91;&#91;a b&#93; &#91;1 2 3&#93;&#93; &#40;println a b&#41;&#41;

;解构集合,这里集合是&#91;1 2 3&#93;,自动将2赋值为a,3赋值为b,打印2 3
&#40;let &#91;&#91;&#95; a b&#93; &#91;1 2 3&#93;&#93; &#40;println a b&#41;&#41;

;解构map,这里自动将key为:name的值赋给name. :name在Clojure里叫关键字
&#40;let &#91;{:keys &#91;name&#93;} {:name &quot;ttnet&quot; :version 1}&#93; &#40;println name&#41;&#41;
</code></pre><h1>无限序列</h1><p>在Java里，无限序列是不可想象的。请问你如何来引用一个无限序列？</p><p>在Clojure中通过lazy-seq函数将序列转变为lazyseq来实现无限序列(很多函数的结果也是lazyseq,比如上面的map,reduce等)</p><p>无限序列有什么用处?</p><p>请实现斐波那契数列！你能想到的无非两种方法:</p><ul><li>递归</li><li>循环</li></ul><p>无线序列提供的另一种思路:</p><pre><code>
    1 1 2 3 5 8  13 21 ...
    0 1 1 2 3 5  8  13 ...

0 1 1 2 3 5 8 13 21 34 ...

</code></pre><pre><code class="clojure">
&#40;defn fibs &#91;&#93;
    &#40;lazy-seq &#40;cons 0 &#40;cons 1 &#40;map + &#40;drop 1 &#40;fibs&#41;&#41; &#40;fibs&#41;&#41;&#41;&#41;&#41;&#41;

&#40;take 10 &#40;fibs&#41;&#41;     ;&#40;0 1 1 2 3 5 8 13 21 34&#41;

</code></pre><h1>继承</h1><p>请问有多少人知道继承是独立于类的? Clojure是基于名称的继承,任意名字可以继承任意名字!!</p><pre><code class="Clojure">
&#40;derive ::rect ::shape&#41;     ;:rect为:shape的child
&#40;derive ::circle ::shape&#41;   ;:circle是:shape的child
</code></pre><h1>多态</h1><p>既然继承不是基于类的,那么多态也就可以不是基于对象的了! Clojure提供基于方法的多态</p><pre><code class="clojure">
&#40;defmulti p &#40;fn &#91;arg&#93; arg&#41;&#41;

&#40;defmethod p ::rect
    &#91;arg&#93;
    &#40;println &quot;Rect&quot;&#41;&#41;

&#40;defmethod p ::shape
    &#91;arg&#93;
    &#40;println &quot;Shape&quot;&#41;&#41;

&#40;p ::rect&#41;      ;打印Rect
&#40;p ::circle&#41;    ;打印Shape
</code></pre><h1>设计语言</h1><p>前面已经说了Clojure语法很简单,可以说就是没有语法!所以没有Java中语法的束缚.你可以任意修改语言。</p><p>很简单的例子,在JDK1.5之前是没有foreach循环的,我们只能使用普通的循环.</p><p>而在Clojure里面可以创建语法</p><pre><code class="clojure">
&#40;def s &#91;1 2 3 4 5&#93;&#41;

;我想写个类似如下解构的循环,根据下标获取元素
&#40;foreach &#91;a &#40;range 0 &#40;count s&#41;&#41;&#93;
         &#40;println &#40;get s a&#41;&#41;&#41;

;我只需要定义一个宏即可
&#40;defmacro foreach &#91;&#91;idx rag&#93; &amp; rest&#93;
  `&#40;doseq &#91;&#126;idx &#126;rag&#93;
     &#126;@rest&#41;&#41;

;我想再换个写法
&#40;fors &#91;a s&#93; &#40;println a&#41;&#41;

;我重新定义一个宏
&#40;defmacro fors &#91;&#91;a s&#93; &amp; rest&#93;
  `&#40;doseq &#91;&#126;a &#126;s&#93; &#126;@rest&#41;&#41;

</code></pre><p>你可能会说Java也可以啊!使用AspectJ,CGlib也可以对Java进行操作.但是你需要另外学习一套语法.</p><p>而Clojure使用原始语法就可以了!</p><h1>缺点</h1><p>Clojure缺点也很明显</p><ul><li>代码过长后,非常的难读!虽然编写Clojure代码一般都比较短,但是初学时难免会写出较长的代码!</li><li>语法怪异!这个仁者见仁,智者见智了!</li><li>对开发要求较高,不太适合大团队开发!包括前一条原因.</li><li>09年的新语言,没有太多成功案例!最著名的就是twitter的Storm</li></ul><h1>最后给个例子</h1><p>如下是进行简繁通翻译的Clojure代码,功能和目前中文站使用的简繁通相同.测试性能基本相同.</p><pre><code class="Clojure">
&#40;ns jft.trans
  &#40;:require &#91;clojure.string :as clstr&#93;&#41;&#41;

&#40;defn read-map
  &quot;从文件中读取翻译数据&quot;
  &#91;path&#93;
  &#40;apply hash-map &#40;clstr/split &#40;slurp path&#41; #&quot;&#91; n&#93;&quot;&#41;&#41;&#41;

&#40;defn translate
  &quot;通过翻译字典来翻译字符串&quot;
  &#91;s transmap&#93;
  &#40;clstr/join &#40;map #&#40;let &#91;tmp &#40;str %&#41;&#93; &#40;transmap tmp tmp&#41;&#41; s&#41;&#41;&#41;

&#40;defn do-trans
  &quot;翻译函数，包括过滤不需要翻译的字符串&quot;
  &#91;s tmap ntmap&#93;
  &#40;let &#91;re &#40;translate s tmap&#41;
        ks &#40;keys ntmap&#41;&#93;
    &#40;reduce #&#40;clstr/replace %1 %2 &#40;ntmap %2&#41;&#41; re ks&#41;&#41;&#41;
</code></pre><p>调用;<pre><code class="clojure">
;获取需要翻译的字典
&#40;def tmap &#40;trans/read-map &quot;/home/ivan/program/clojure/jft/jfmap.clj&quot;&#41;&#41;

;获取不需要翻译的字典
&#40;def ntmap &#40;trans/read-map &quot;/home/ivan/program/clojure/jft/ntmap.clj&quot;&#41;&#41;

;获得需要翻译的字符串
&#40;def pstr &#40;slurp &quot;/home/ivan/program/clojure/jft/source.txt&quot;&#41;&#41;

;翻译，并将结果写入到t2.txt
&#40;spit &quot;/home/ivan/program/clojure/jft/t2.txt&quot; &#40;cstr/join &#40;trans/do-trans pstr tmap ntmap&#41;&#41;&#41;
 </code></pre></p>
    </div>
  </div>
</body>
<script type="text/javascript">
var tbs = document.getElementsByTagName("table");
for(var i = 0; i < tbs.length;i++) {tbs[i].className="table table-bordered table-striped";}
</script>
</html>
