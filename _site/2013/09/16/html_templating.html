<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="keywords" content="clojure, luminus"/>
        <meta name="author" content="ivanpig.github.io"> 
        <link rel="canonical" href="http://ivanpig.github.io/2013/09/16/html_templating.html">
        <link href="http://ivanpig.github.io/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
        <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
        <title>Luminus手册-HTML模板 - IvanPig's Blog</title>
        <link rel="stylesheet" href="/css/min/pure-min.css">
        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
<![endif]-->
        <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
        <!--<![endif]-->

        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
<![endif]-->
        <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="/css/JekyllPure.css">
        <!--<![endif]-->

        <link href="/css/min/font-awesome.min.css" rel="stylesheet">
        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
<![endif]-->
        <script src="/js/min/jquery-1.7.2.min.js"></script>
        <link rel="stylesheet" href="/css/themes/my.css"/>
        <script src="/js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>

    <body>

        <div id="layout" class="pure-g">
            <div class="sidebar pure-u-1 pure-u-md-1-4">
                <div class="header">
                    <div class="headerpic">
                        <a href="/">
                            <img src="/img/head.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                        </a>
                    </div>
                    <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
                    <h2 id="_tagline" class="brand-tagline">IvanPig's Blog</h2>
<!--                     <br class="newline"/><br class="newline"/> -->

                    <nav class="nav">
                        <ul class="nav-list">
                            <li class="nav-item">
                                <a class="pure-button" href="/Timing">时间轴</a>
                            </li>
                            <li class="nav-item">
                                <a class="pure-button" href="/tag">标签库</a>
                            </li>
                            <li class="nav-item">
                                <a class="pure-button" href="/type">分类库</a>
                            </li>
                        </ul>
                    </nav>
                    <div class="search">
                        <form action="/search">
                            <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                        </form>
                    </div>

                    <div id="toc"></div>
                    <div id="toc1"></div>
                    <nav id="nav">
                        <ul class="nav-list">
                            <li class="nav-link">
                                <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                            </li>
                            <li class="nav-link">
                                <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                            </li>
                            <li class="nav-link">
                                <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>

            <div class="content pure-u-1 pure-u-md-3-4">
                <!--[if lt IE 8]>
<i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
<![endif]-->
                <div>
                    <div class="posts">

                        <div class="qrcodeTable"></div>
<header class="post-header">
    
    <img class="post-avatar" height="48" width="48"
         src="/img/head.jpg">
    

    <h2 class="post-title">Luminus手册-HTML模板</h2>

    <p class="post-meta">By 09月16日  2013
        
        
        
        
        <a class="post-categorybut " href="/type/#"><i class="fa fa-folder-open">luminus (19)</i></a>
        
        
        

        
        
        
        
        <a class="post-category " href="/tag/#clojure"><i class="fa fa-tags">clojure (22)</i></a>
        
        <a class="post-category " href="/tag/#clojure"><i class="fa fa-tags">luminus (19)</i></a>
        
        
    
    
</header>
<div class="article pure-u-22-24">
    <h1>Templating Options</h1>

<p>Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。
Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成
HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。
你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢
的模板框架，比如Enlive或者Stencil。</p>

<h1>HTML Templating Using Selmer</h1>

<p>Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语
言，那么你会感觉很熟悉.</p>

<h2>Creating Templates</h2>

<p>Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的
HTML文件。来看下面的例子。</p>

<pre><code class="{.html}">&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;My First Template&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h2&gt;Hello { {name}}&lt;/h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们
需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为
name的变量的值。
有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来
渲染模板。而render-file接收一个字符串作为路径来渲染模板。
如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染:</p>

<pre><code class="{.clojure}">(ns example.routes.home
  (:use [selmer.parser :only [render-file]]))

(defn index [request]
  (render-file "example/views/templates/index.html"
               {:name "John"}))
</code></pre>

<!-- more -->


<p>render-file函数将src目录作为根路径，使用相对路径来查找模板。
上面，我们传递了一个字符串作为变量name的值。实际上，我们可以传递任何类
型的值。比如，我们传递一个集合，在模板里我们可以使用tag来遍历这个集合。</p>

<pre><code class="{.html}">    &lt;ul&gt;
        { % for item in items %}
        &lt;li&gt; { {item}} &lt;/li&gt;
        { % endfor %}
    &lt;/ul&gt;
</code></pre>

<pre><code class="{.clojure}">(render-file "/example/views/templates/items.html {:items (range 10)}")
</code></pre>

<p>如果传递的是个map，我们可以这样访问:</p>

<pre><code class="{.clojure}">(render "&lt;p&gt;Hello { {user.first}} { {user.last}}&lt;/p&gt;"
        {:user {:first "John" :last "Doe"}})
</code></pre>

<p>如果没有指定的展示方式，那么默认调用toString方法。
默认情况下，Selmer会缓存编译后的模板。只有当文件发生变化时，才会触发
Selmer重新编译模板。你也可以选择Selmer是开启缓存还是关闭缓存。只需要调
用(selmer.parser/cache-on!)或(selmer.parser/cache-off!).</p>

<h2>Filters</h2>

<p>Filter允许我们在渲染变量之前对其做一些处理。比如将其值变为大写，计算一
个hash或者是计算长度。Filter的使用方法很简单，只需要在变量名后面跟一个
"|"接着是Filter即可。比如：</p>

<pre><code class="{.html}">    { {name|upper}}
</code></pre>

<p>下面是内置的filter:</p>

<p>*add*</p>

<pre><code class="{.clojure}">(render "{ {add_me|add:2:3:4}}" {:add_me 2}) =&gt; 11
</code></pre>

<p>*addslashes* 为了保留字符串中的转义符""</p>

<pre><code class="{.clojure}">(render "{ {name|addslashes}}" {:name "\"Russian tea is best tea\""}) =&gt; "\"Russian tea is best tea\""
</code></pre>

<p>*block.super* 在代码块中插入上级代码块中的内容。</p>

<pre><code class="{.clojure}">        { % block foo %} { {block.super}} some content{ % endblock %}
</code></pre>

<p>*capitalize*</p>

<pre><code class="{.clojure}">(render "{ {name|capitalize}}" {:name "russian tea is best tea"}) =&gt; "Russian tea is best tea"
</code></pre>

<p>*center*</p>

<pre><code class="{.clojure}">(render "{ {name|center:20}}" {:name "bitemyapp"}) =&gt; " bitemyapp "
</code></pre>

<p>*count*</p>

<pre><code class="{.clojure}">(render "{ {name|count}}" {:name "Yogthos"}) =&gt; "7"

(render "{ {items|count}}" {:items [1 2 3 4]}) =&gt; "4"
</code></pre>

<p>*date*</p>

<pre><code class="{.clojure}">(render "{ {creation-time|date:\"yyyy-MM-dd_HH:mm:ss\"}}" {:created-at (java.util.Date.)}) =&gt; "2013-07-28_20:51:48"
</code></pre>

<p>*default*</p>

<pre><code class="{.clojure}">(render "{ {name|default:"I &lt;3 ponies"}}" {:name "bitemyapp"}) =&gt; "bitemyapp"

(render "{ {name|default:"I &lt;3 ponies"}}" {:name nil}) =&gt; "I &lt;3 ponies"

(render "{ {name|default:"I &lt;3 ponies"}}" {:name []}) =&gt; "[]"

(render "{ {name|default:"I &lt;3 ponies"}}" {}) =&gt; "I &lt;3 ponies"
</code></pre>

<p>*default-if-empty*</p>

<pre><code class="{.clojure}">(render "{ {name|default-if-empty:"I &lt;3 ponies"}}" {:name "bitemyapp"}) =&gt; "bitemyapp"

(render "{ {name|default-if-empty:"I &lt;3 ponies"}}" {:name nil}) =&gt; "I &lt;3 ponies"

(render "{ {name|default-if-empty:"I &lt;3 ponies"}}" {:name []}) =&gt; "I &lt;3 ponies"

(render "{ {name|default-if-empty:"I &lt;3 ponies"}}" {}) =&gt; "I &lt;3 ponies"
</code></pre>

<p>*double-format*</p>

<pre><code class="{.clojure}">(render "{ {tis-a-number|double-format:2}}" {:tis-a-number 10.00001}) =&gt; 10.00

(render "{ {tis-a-number|double-format}}" {:tis-a-number 10.00001}) =&gt; 10.0
</code></pre>

<p>*first*</p>

<pre><code class="{.clojure}">(render "{ {seq-of-some-sort|first}}" {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]}) =&gt; :dog
</code></pre>

<p>*get-digit* 从右边返回相应位数的数据。</p>

<pre><code class="{.clojure}">(render "{ {tis-a-number|get-digit:1}}" {:tis-a-number 12.34567}) =&gt; 7
</code></pre>

<p>*hash* 有效的hash方式: md5, sha, sha256, sha384, sha512</p>

<pre><code class="{.clojure}">(render "{ {domain|hash:\"md5\"}}" {:domain "example.org"}) =&gt; "1bdf72e04d6b50c82a48c7e4dd38cc69"
</code></pre>

<p>*join*</p>

<pre><code class="{.clojure}">(render "{ {sequence|join}}" {:sequence [1 2 3 4]}) =&gt; "1234"
</code></pre>

<p>*json* 生成json格式，默认情况下特殊字符会被编码.</p>

<pre><code class="{.clojure}">(render "{ {data|json}}" {:data [1 2 {:foo 27 :dan "awesome"}]})
               =&gt; "[1,2,{&amp;quot;foo&amp;quot;:27,&amp;quot;dan&amp;quot;:&amp;quot;awesome&amp;quot;}]"
</code></pre>

<p>如果你不希望被编码则使用safe过滤器</p>

<pre><code class="{.clojure}">(render "{ {f|json|safe}}" {:f {:foo 27 :dan "awesome"}})
</code></pre>

<p>*last*</p>

<pre><code class="{.clojure}">(render "{ {sequence|last}}" {:sequence 12.34567}) =&gt; 7

(render "{ {sequence|last}}" {:sequence [1 2 3 4]}) =&gt; 4
</code></pre>

<p>*length*</p>

<pre><code class="{.clojure}">(render "{ {sequence|length}}" {:sequence [1 2 3 4]}) =&gt; 4
</code></pre>

<p>*length-is*</p>

<pre><code class="{.clojure}">(render "{ {sequence|length-is:4}}" {:sequence [1 2 3 4]}) =&gt; true
</code></pre>

<p>*linebreaks* 普通换行替换为html换行,结果在\&lt;p>标签内</p>

<pre><code class="{.clojure}">(render "{ {foo|linebreaks|safe}}" {:foo "\nbar\nbaz"}) =&gt; "&lt;p&gt;&lt;br /&gt;bar&lt;br /&gt;baz&lt;/p&gt;"
</code></pre>

<p>*linebreaks-br* 和linebreaks功能相同，但是没有\&lt;p>标签</p>

<pre><code class="{.clojure}">(render "{ {foo|linebreaks-br|safe}}" {:foo "\nbar\nbaz"}) =&gt; "bar&lt;br /&gt;baz"
</code></pre>

<p>*linenumbers* 显示行号</p>

<pre><code class="{.clojure}">(render "{ {foo|linenumbers" {:foo "foo\n\bar\nbaz"}) =&gt; "1. foo\n2. \bar\n3. baz"
</code></pre>

<p>*lower*</p>

<pre><code class="{.clojure}">(render "{ {foo|lower}}" {:foo "FOOBaR"}) =&gt; "foobar"
</code></pre>

<p>*pluralize* 返回单词的复数</p>

<pre><code class="{.clojure}">(render "{ {items|count}} item{ {items|pluralize}}" {:items []}) =&gt; "0 items"

(render "{ {items|count}} item{ {items|pluralize}}" {:items [1]}) =&gt; "1 item"

(render "{ {items|count}} item{ {items|pluralize}}" {:items [1 2]}) =&gt; "2 items"

(render "{ {fruit|count}} tomato{ {fruit|pluralize:\"es\"}}" {:fruit []}) =&gt; "0 tomatoes"

(render "{ {people|count}} lad{ {people|pluralize:\"y\":\"ies\"}}" {:people [1]}) =&gt; "1 lady"

(render "{ {people|count}} lad{ {people|pluralize:\"y\":\"ies\"}}" {:people [1 2]}) =&gt; "2 ladies"
</code></pre>

<p>*rand-nth* 从集合中返回rand-nths值</p>

<pre><code class="{.clojure}">(render "{ {foo|rand-nth}}" {:foo [1 2 3]}) =&gt; "2"
</code></pre>

<p>*remove* 从字符串中去除特殊字符</p>

<pre><code class="{.clojure}">(render "{ {foo|remove:\"aeiou\"}}" {:foo "abcdefghijklmnop"}) =&gt; "bcdfghjklmnp"
</code></pre>

<p>*remove-tags* 去除html标签</p>

<pre><code class="{.clojure}">(render "{ { value|remove-tags:b:span }}" {:value "&lt;b&gt;&lt;span&gt;foobar&lt;/span&gt;&lt;/b&gt;"}) =&gt; "foobar"
</code></pre>

<p>*safe* 默认情况下Selmer会编码所有的内容，此过滤器时Selmer不去编码</p>

<pre><code class="{.clojure}">(render "{ {data}}" {:data "&lt;foo&gt;"}) =&gt; "&amp;lt;foo&amp;gt;"

(render "{ {data|safe}}" {:data "&lt;foo&gt;"}) =&gt; "&lt;foo&gt;"
</code></pre>

<p>*sort*</p>

<pre><code class="{.clojure}">(render "{ { value|sort }}" {:value [1 4 2 3 5]}) =&gt; "(1 2 3 4 5)"
</code></pre>

<p>*sort-by*</p>

<pre><code class="{.clojure}">(render "{ { value|sort-by:name }}" {:value [{:name "John"} {:name "Jane"}]})
                     =&gt; "({:name &amp;quot;Jane&amp;quot;} {:name &amp;quot;John&amp;quot;})"
</code></pre>

<p>*sort-reversed* 反序排列</p>

<p>*sort-by-reversed* 和sort-by功能相同，反序</p>

<p>upper</p>

<pre><code class="{.clojure}">(render "{ {shout|upper}}" {:shout "hello"}) =&gt; "HELLO"
</code></pre>

<h2>Defining Custom Filters</h2>

<p>你可以使用selmer.filters/add-filter!函数来方便的添加自定义的Filter.此
函数以元素作为参数，并返回替换后的值.</p>

<pre><code class="{.clojure}">(use 'selmer.filters)

(add-filter! :embiginate #(.toUpperCase %))
 (render "{ {shout|embiginate}}" {:shout "hello"})

(add-filter! :count count)
(render "{ {foo|count}}" {:foo (range 3)})
</code></pre>

<p>Filters可以链式使用</p>

<pre><code class="{.clojure}">(add-filter! :empty? empty?)
(render "{ {foo|upper|empty?}}" {:foo "Hello"})
</code></pre>

<h2>Tags</h2>

<p>Selmer提供了两种类型的Tag。一种是类似extends和include这样的内联tag。这
种tag不需要结束tag。另一种形式的tag是块tag。这种tag有开始和结束tag，以
及代码块。比如if ... endif块。 让我们先来看看默认的tag:</p>

<p>*include* 将引用的模板内容替换其自身</p>

<pre><code class="{.html}">{ % include "path/to/comments.html" %}
</code></pre>

<p>你可以提供默认的参数，如果tag有匹配上上的参数，则会获取它的值。</p>

<pre><code class="{.clojure}">{ % include "templates/inheritance/child.html" with name="Jane Doe" greeting="Hello!" %}
</code></pre>

<p>*block*
定义一个块，可以使用模板继承的方式来覆盖，类似Java中的父类方法.</p>

<pre><code class="{.html}">    { % block foo %}This text can be overridden later{ % endblock %}
</code></pre>

<p>*cycle* 循环提供的参数</p>

<pre><code class="{.clojure}">(render "{ % for i in items %}&lt;li class={ % cycle \"blue\" \"white\"%}&gt;{ {i}}&lt;/li&gt;{ % endfor %}" {:items (range 5)})
                        =&gt; "&lt;li class=\"blue\"&gt;0&lt;/li&gt;&lt;li class=\"white\"&gt;1&lt;/li&gt;&lt;li class=\"blue\"&gt;2&lt;/li&gt;
                            &lt;li class=\"white\"&gt;3&lt;/li&gt;&lt;li class=\"blue\"&gt;4&lt;/li&gt;"
</code></pre>

<p>*extends* 引用父模板。父模板中的块会被子模板中相应的块覆盖。</p>

<ul>
<li>Note: 子模板只能包含块。任何块以外的tag或文本都被忽略</li>
</ul>


<p>例如有一个叫base.html的父模板和一个叫child.html的子模板</p>

<pre><code class="{.html}">&lt;html&gt;
  &lt;body&gt;
    { % block foo %}This text can be overridden later{ % endblock %}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="{.html}">    { % extends "base.html" %}
    { % block foo %}
      &lt;p&gt;This text will override the text in the parent&lt;/p&gt;
    { % endblock %}
</code></pre>

<p>*if*</p>

<pre><code class="{.html}">{ % if condition %}yes!{ % endif %}

{ % if condition %}yes!{ % else %}no!{ % endif %}
</code></pre>

<p>配合filter使用</p>

<pre><code class="{.clojure}">(add-filter! :empty? empty?)
(render "{ % if files|empty? %}no files{ % else %}files{ % endif %}"
  {:files []})
</code></pre>

<p>*ifequal* 之用当两个参数相等时才执行</p>

<pre><code class="{.html}">{ % ifequal foo bar %}yes!{ % endifequal %}

{ % ifequal foo bar %}yes!{ % else %}no!{ % endifequal %}

{ % ifequal foo "this also works" %}yes!{ % endifequal %}
</code></pre>

<p>*for* 遍历集合中的元素。同时可以使用如下参数。
-   forloop.first
-   forloop.last
-   forloop.counter
-   forloop.counter0
-   forloop.revcounter
-   forloop.revcounter0
-   forloop.length</p>

<pre><code class="{.html}">{ % for x in some-list %}element: { {x}} first? { {forloop.first}} last? { {forloop.last}}{ % endfor %}
</code></pre>

<p>可以直接访问结构化的数据</p>

<pre><code class="{.html}">{ % for item in items %} &lt;tr&gt;&lt;td&gt;{ {item.name}}&lt;/td&gt;&lt;td&gt;{ {item.age}}&lt;/td&gt;&lt;/tr&gt; { % endfor %}
</code></pre>

<p>*now* 当前时间</p>

<pre><code class="{.html}">(render (str "{ % now \"" date-format "\"%}") {}) =&gt; "\"01 08 2013\""
</code></pre>

<p>*comment* 注释</p>

<pre><code class="{.html}">(render "foo bar { % comment %} baz test { {x}} { % endcomment %} blah" {}) =&gt; "foo bar baz test blah"
</code></pre>

<p>*firstof* 取得第一个不是false的值</p>

<pre><code class="{.html}">(render "{ % firstof var1 var2 var3 %}" {:var2 "x" :var3 "not me"}) =&gt; "x"
</code></pre>

<p>*script*
生成一个html的script标签，并以servlet-context键提供的值类作为文件的前
置目录.</p>

<pre><code class="{.html}">(render "{ % script \"/js/site.js\" %}" {:servlet-context "/myapp"}) =&gt;
"&lt;script src=\"/myapp/js/site.js\" type=\"text/javascript\"&gt;&lt;/script&gt;"
</code></pre>

<p>*style*</p>

<p>生成一个html的style标签，并以servlet-context键提供的值类作为文件的前置目录.</p>

<pre><code class="{.clojure}">(render "{ % style \"/css/screen.css\" %}" {:servlet-context "/myapp"}) =&gt;
"&lt;link href=\"/myapp/css/screen.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;"
</code></pre>

<p>*verbatim* 阻止内容中的parseeither解析</p>

<pre><code class="{.clojure}">(render "{ % verbatim %}{ {if dying}}Still alive.{ {/if}}{ % endverbatim %}" {}) =&gt; "{ {if dying}}Still alive.{ {/if}}"
</code></pre>

<p>*with* 向上下文map中新增一个值</p>

<pre><code class="{.clojure}">(render "{ % with total=business.employees|count %}{ { total }}{ % endwith %}"
         {:business {:employees (range 5)}})
=&gt; "5 employees"
</code></pre>

<h2>Defining Custom Tags</h2>

<p>除了上面已经提供的tag。你也可以自定义tag。使用add-tag!宏就可以了。</p>

<pre><code class="{.clojure}">(use 'selmer.parser)

(add-tag! :foo
  (fn [args context-map]
    (str "foo " (first args))))

(render "{ % foo quux %} { % foo baz %}" {})

(add-tag! :bar
  (fn [args context-map content]
    (str content))
  :baz :endbar)

(render "{ % bar %} some text { % baz %} some more text { % endbar %}" {})
</code></pre>

<p>可以看出，我们定义的tag提供了一个关键字作为tag的名称后面是tag体,结尾的
tag不是必须的。
当没有结尾的tag时,tag不包含任何内容。这种tag获取参数类进行处理。
当有结尾tag时，每个块内的内容都会被作为开头那个tag所对应的map的键.开头
tag对应的map包含:args和:content键，content的内容就对应到了:content.</p>

<h2>Template inheritance</h2>

<p>Selmer模板可以使用块tag来引用其他的模板。有两种方法可以引用模板，一个
是extends一个是include.</p>

<h3>Extending Templates</h3>

<p>当我们使用extends这个tag时，当前的模板将会将引用的模板作为父模板。
任何在base模板中的块，会被子模板中相同名字的块给覆盖.
子模板中的内容需要在块tag中。不在块中的内容将会被忽略。
我们来看个例子,我们创建一个叫base.html的父模板.</p>

<pre><code class="{.html}">&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;link rel="stylesheet" href="style.css" /&gt;
        &lt;title&gt;{ % block title %}My amazing site{ % endblock %}&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="content"&gt;
        { % block content %}{ % endblock %}
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>然后我们创建一个home.html模板来继承base.html。</p>

<pre><code class="{.html}">{ % extends "base.html" %}

    { % block content %}
        { % for entry in entries %}
            &lt;h2&gt;{ { entry.title }}&lt;/h2&gt;
            &lt;p&gt;{ { entry.body }}&lt;/p&gt;
        { % endfor %}
    { % endblock %}
</code></pre>

<p>当渲染home.html时entries的内容将会被打印出来。而在home.html中，我们没
有定义title块，在渲染时会获取base.html中的title块的定义。</p>

<ul>
<li>注意，你可以多层级的继承模板。引擎会渲染最后的那个块.</li>
</ul>


<h3>Including Templates</h3>

<p>include这个tag允许你包含一个模板。
我们还是来看一个例子，我们有一个base.html这个模板，它包含了一个叫做
register.html的模板和一个home.html的模板：</p>

<pre><code class="{.html}">&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;link rel="stylesheet" href="style.css" /&gt;
        &lt;title&gt;{ % block title %}My amazing site{ % endblock %}&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="content"&gt;
        { % if user %}
        { % include "templates_path/home.html" %}
        { % else %}
        { % include "templates_path/register.html" %}
        { % endif %}
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>现在我们能定义register.html</p>

<pre><code class="{.html}">    { % block register %}
      &lt;form action="/register" method="POST"&gt;
          &lt;label for="id"&gt;user id&lt;/label&gt;
          &lt;input id="id" name="id" type="text"&gt;&lt;/input&gt;
          &lt;input pass="pass" name="pass" type="text"&gt;&lt;/input&gt;
          &lt;input type="submit" value="register"&gt;
      &lt;/form&gt;
    { % endblock %}
</code></pre>

<p>和home.html:</p>

<pre><code class="{.html}">    { % block home %}
    &lt;h1&gt;Hello { {user}}&lt;/h1&gt;
    { % endblock %}
</code></pre>

<p>当渲染base.html时，将会引入register.html和home.html。
更多信息请见<a href="https://github.com/yogthos/Selmer">官方文档</a></p>

<h1>HTML Templating Using Hiccup</h1>

<p><a href="https://github.com/weavejester/hiccup">Hiccup</a>
是另一个Clojure的HTML模板引擎。它的优势是我们可以使用纯正的
Clojure代码来生成页面。也就是说我们不需要学习第三方的语法了。
Hiccup主要使用Clojure的vector来渲染页面。</p>

<pre><code class="{.clojure}">[:tag-name {:attribute-key "attribute value"} tag-body]
</code></pre>

<p>例如，如果我们想创建一个包含内容的div，我们可以这样写：</p>

<pre><code class="{.clojure}">[:div {:id "hello", :class "content"} [:p "Hello world!"]]
</code></pre>

<p>这将生成如下的html代码</p>

<pre><code class="{.html}">        &lt;div id="hello" class="content"&gt;&lt;p&gt;Hello world!&lt;/p&gt;&lt;/div&gt;
</code></pre>

<p>Hiccup提供了简化设置id和class的方法，简写如下</p>

<pre><code class="{.clojure}">[:div#hello.content [:p "Hello world!"]]
</code></pre>

<p>Hiccup还提供了一些帮助类函数来创建元素，比如: forms, links, images, 等
等.所有这些函数只是简单的返回类似上面格式的vector。也就是说，如果一个
函数无法达到你的要求，你可以手写相应代码或者获取函数的返回值进行修改。
每个函数可以使用一个map作为其第一个参数，来描绘属性:</p>

<pre><code class="{.clojure}">(image {:align "left"} "foo.png")
</code></pre>

<p>生成html代码如下</p>

<pre><code class="{.clojure}">&lt;img align=\"left\" src=\"foo.png\"&gt;
</code></pre>

<p>但是最佳实践还是将其保存到独立的CSS文件中。</p>

<h2>Forms and Input</h2>

<p>Hiccup还提供了form助手函数，看例子</p>

<pre><code class="{.clojure}">(form-to [:post "/login"]
  (text-field {:placeholder "screen name"} "id")
  (password-field {:placeholder "password"} "pass")
  (submit-button "login"))
</code></pre>

<p>这个函数第一个参数是一个vector，以HTTP请求类型为关键字，紧接着是请求
url。其余的参数必须是HTML元素。生成的HTML代码如下:</p>

<pre><code class="{.html}">&lt;form action="/login" method="POST"&gt;
  &lt;input id="id" name="id" placeholder="screen name" type="text" /&gt;
  &lt;input id="pass" name="pass" placeholder="password" type="password" /&gt;
  &lt;input type="submit" value="login" /&gt;
&lt;/form&gt;
</code></pre>

<p>最后LUminus模板在你的应用下面提供了一辅助函数。叫做md->html,这个函数能
渲染载resources/public/目录下的markdown文件并返回一个HTML字符串。这个
可以和Hiccup函数一起使用:</p>

<pre><code class="{.clojure}">(:require [&lt;yourapp&gt;.util :as util])
...
(html [:div.contenr [:p (util/md-&gt;html "/md/paragraph.md")]])
</code></pre>

<p>markdown生成由markdown-clj来处理，具体信息请见其<a href="https://github.com/yogthos/markdown-clj">Github</a>
页。</p>

<h1>Content caching</h1>

<p>lib-noir通过cache!宏提供了基本的内存式缓存，相应的宏在noir.util.cache
下。如果想缓存一个页面，你是需要：</p>

<pre><code class="{.clojure}">(require '[noir.util.cache :as cache])

(defn slow-loading-page []
  (cache/cache!
   :slow-page
   (common/layout
    [:div "I load slowly"]
     (parse-lots-of-files))))
</code></pre>

<p>通过调用invalidate!来取消缓存,需要提供需要取消的缓存的key。</p>

<pre><code class="{.clojure}">(cache/invalidate! :slow-page)
</code></pre>

<p>使用clear!来清除当前所有的缓存</p>

<pre><code class="{.clojure}">(cache/clear!)
</code></pre>

<p>使用set-timeout!来设置缓存时间(单位：秒)，超时后会重新加载。</p>

<pre><code class="{.clojure}">(cache/set-timeout! 10)
</code></pre>

<p>最后你可以通过set-size!来设置缓存的大小。当缓存超出了限定的大小，最先
使用的数据将被被替换。</p>

<pre><code class="{.clojure}">(cache/set-size! 10)
</code></pre>

<ul>
<li>注意，缓存会在操作成功后才重新加载。也就是说，比如程序去获取一个远程
文件，但是失败了，那么缓存是不会被重新加载的。</li>
</ul>


</div>

<div class="pure-g pagination">
    
    <a class="pure-u-1-2 pagination-item " href="/2013/09/15/application_profile.html" title="Luminus手册-应用配置 "><p> <i class="fa fa-mail-reply"></i>&nbsp;Luminus手册-应用配置</p></a>
    
    
    <a class="pure-u-1-2 pagination-item " href="/2013/09/17/clojurescript.html" title="Luminus手册-ClojureScript"><p>Luminus手册-ClojureScript&nbsp;<i class="fa fa-mail-forward"></i></p></a>
    
</div>
<link href="/css/code.css" rel="stylesheet">
<link href="/css/min/fancybox.css" rel="stylesheet">
<script src="/js/min/jquery.toc.min.js" ></script>
<script src="/js/min/jquery.qrcode.min.js" ></script>
<script src="/js/min/jquery.fancybox.pack.js" ></script>
<script src="/js/page.js" ></script>






<a name="comments"> </a>
<div id="comment">
    <div class="ds-thread" data-title="Luminus手册-HTML模板" data-thread-key="/2013/09/16/html_templating" data-url="/2013/09/16/html_templating.html"></div>
    <script type="text/javascript">
        var duoshuoQuery = {short_name:"ivanpig"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = '/js/min/duoshuo.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0]
                    || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
</div>








                    </div>
                </div>
                <div class="footer">
                    <a href="/love/welcome-my-blog.html">About</a>
                    <a href="/1">Collecting</a>
                    <a href="tencent://message/?uin=561802774">QQ</a>
                    <a href="https://github.com/ivanpig">GitHub</a>
                    <script src="/js/min/nprogress.min.js"></script>
                    <script src="/js/index.js"></script>
                </div>
                <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

            </div>

        </div>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F2278992c92bf7ea162797e107e900616' type='text/javascript'%3E%3C/script%3E"));
</script>

    </body>

</html>
