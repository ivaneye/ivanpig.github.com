<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="keywords" content="clojure"/>
    <meta name="author" content="liyouhai.com"> 
    <link rel="canonical" href="http://liyouhai.com/clojure/clojure%25e6%2595%2599%25e7%25a8%258b%25e5%2591%25bd%25e5%2590%258d%25e7%25a9%25ba%25e9%2597%25b4-4.html">
    <link href="http://liyouhai.com/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
    <title>Clojure教程:命名空间 - IvanPig's Blog</title>
    <link rel="stylesheet" href="/css/min/pure-min.css">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
    <!--<![endif]-->

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/JekyllPure.css">
    <!--<![endif]-->

    <link href="/css/min/font-awesome.min.css" rel="stylesheet">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
    <![endif]-->
    <script src="/js/min/jquery-1.7.2.min.js"></script>
    <!--
     /\_ \    __                         /\ \                __
     \//\ \  /\_\  __  __    ___   __  __\ \ \___      __   /\_\
       \ \ \ \/\ \/\ \/\ \  / __`\/\ \/\ \\ \  _ `\  /'__`\ \/\ \
        \_\ \_\ \ \ \ \_\ \/\ \L\ \ \ \_\ \\ \ \ \ \/\ \L\.\_\ \ \
        /\____\\ \_\/`____ \ \____/\ \____/ \ \_\ \_\ \__/.\_\\ \_\
        \/____/ \/_/`/___/> \/___/  \/___/   \/_/\/_/\/__/\/_/ \/_/
                       /\___/
                       \/__/
     图像可以到http://asciigen.com/  生成..记得翻墙才能正常生成.如不方便可以博客留言我帮你生成
     -->
</head>

<body>







<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
        <div class="header">
            <div class="headerpic">
                <a href="/">
                    <img src="/img/op.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                </a>
            </div>
            <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
            <h2 class="brand-tagline">IvanPig's Blog</h2>

            <nav class="nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a class="pure-button" href="/Timing">时间轴</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/tag">标签库</a>
                    </li>
                    <!--<li class="nav-item">
                        <a class="pure-button" href="/1">收藏站</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/1">音乐屋</a>-->

                </ul>
            </nav>
            <div class="search">
                <form action="/search">
                    <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                </form>
            </div>
            <div id="toc"></div>
            <nav id="nav">
                <ul class="nav-list">
                    <li class="nav-link">
                    <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <!--[if lt IE 8]>
        <i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
        <![endif]-->
        <div>
            <div class="posts">

                <div class="qrcodeTable"></div>
<header class="post-header">
    <img class="post-avatar" height="48" width="48"
         src="">

    <h2 class="post-title">Clojure教程:命名空间</h2>

    <p class="post-meta">By 08月29日  2014  



 
<a class="post-categorybut " href="/type/#"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#clojure"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  
</header>
<div class="article pure-u-22-24">
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {<br />
  margin: 0; padding: 0; vertical-align: baseline; border: none; }<br />
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }<br />
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }<br />
td.sourceCode { padding-left: 5px; }<br />
pre, code { background-color: #f8f8f8; }<br />
code > span.kw { color: #204a87; font-weight: bold; }<br />
code > span.dt { color: #204a87; }<br />
code > span.dv { color: #0000cf; }<br />
code > span.bn { color: #0000cf; }<br />
code > span.fl { color: #0000cf; }<br />
code > span.ch { color: #4e9a06; }<br />
code > span.st { color: #4e9a06; }<br />
code > span.co { color: #8f5902; font-style: italic; }<br />
code > span.ot { color: #8f5902; }<br />
code > span.al { color: #ef2929; }<br />
code > span.fu { color: #000000; }<br />
code > span.er { font-weight: bold; }<br />
  </style>
<style type="text/css">
code {<br />
background-color: #f7f7f9;<br />
border: none;<br />
padding: 2px 4px;<br />
padding: 0.125rem 0.25rem;<br />
}<br />
pre.sourceCode{<br />
border : 1px solid #e1e1e8;<br />
}<br />
</style>
<div class="container">
<div class="row">
<div id="side-navigation">
<div id="TOC" class="bs-sidebar hidden-print">
<ul>
<li><a href="#版本">版本</a></li>
<li><a href="#概述">概述</a></li>
<li><a href="#定义一个命名空间">定义一个命名空间</a>
<ul>
<li><a href="#require">:require</a>
<ul>
<li><a href="#refer选项">:refer选项</a></li>
</ul>
</li>
<li><a href="#import">:import</a></li>
<li><a href="#当前命名空间">当前命名空间</a></li>
<li><a href="#refer-clojure">:refer-clojure</a></li>
<li><a href="#use">:use</a></li>
<li><a href="#文档与元数据">文档与元数据</a></li>
</ul>
</li>
<li><a href="#如何在repl里使用其它命名空间的函数">如何在REPL里使用其它命名空间的函数</a></li>
<li><a href="#命名空间和编译">命名空间和编译</a></li>
<li><a href="#私有vars">私有Vars</a></li>
<li><a href="#常量vars">常量Vars</a></li>
<li><a href="#如何通过名称来查找和执行函数">如何通过名称来查找和执行函数</a></li>
<li><a href="#编译异常">编译异常</a>
<ul>
<li><a href="#classnotfoundexception">ClassNotFoundException</a></li>
<li><a href="#compilerexception-java.lang.runtimeexception-no-such-var">CompilerException java.lang.RuntimeException: No such var</a></li>
</ul>
</li>
</ul></div>
</p></div>
<div class="col-md-9">
<div id="content">
<h1 id="版本"><a href="#版本">版本</a></h1>
<p>本文翻译自<a href="http://clojure-doc.org/articles/language/namespaces.html">Clojure Namespaces and Vars</a> 本文涵盖如下内容: + Clojure命名空间和var概述 + 如何定义命名空间 + 如何使用其它命名空间里的函数 + require,refer和use + 常见错误和典型错误,以及导致这些错误的原因 + 命名空间和代码管理</p>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<p>涵盖Clojure版本:Clojure 1.5</p>
<h1 id="概述"><a href="#概述">概述</a></h1>
<p>Clojure的函数通过命名空间来组织.Clojure命名空间和Java的包或者Python的模块很类似.命名空间实际上就是个map,将名字映射到了var上.在大部分情况下,这些var持有这些函数.</p>
<h1 id="定义一个命名空间"><a href="#定义一个命名空间">定义一个命名空间</a></h1>
<p>一般情况下使用clojure.core/ns宏来定义命名空间.最基本的形式下,它将名字作为符号.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> superlib.core)</code></pre>
<p>命名空间可以由点号切割的好多段组成</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.service.core)</code></pre>
<p>需要注意的是,请尽量避免使用单段的命名空间,以免与其它开发人员的命名空间相冲突.如果库或者应用属于某个组织,那么建议以如下形式作为命名空间.[组织名称].[包名|应用名].[函数组名] 例如</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> clojurewerkz.welle.kv)
          
          (<span class="kw">ns</span> megacorp.search.indexer.core)</code></pre>
<p>另外,ns宏可以包含如下形式: + (:require ...) + (:import ...) + (:use ...) + (:refer-clojure ...) + (:gen-class ...)</p>
<p>这些其实就是clojure.core/import,clojure.core/require等等这些的简写形式而已</p>
<h2 id="require"><a href="#require">:require</a></h2>
<p>:require形式可以使你的代码能访问其它命名空间的Clojure代码.例如</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> clojure.<span class="kw">set</span>))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (clojure.set/difference #{1 2 3} #{3 4 5})</span></code></pre>
<p>此代码将保证clojure.set命名空间被加载,编译并且可以通过clojure.set名来调用.当然可以给加载的命名空间取个别名:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:as</span> cs]))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (cs/difference #{1 2 3} #{3 4 5})</span></code></pre>
<p>一次导入两个命名空间的例子;</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span>  <span class="kw">:as</span> cs]
                      [clojure.<span class="kw">walk</span> <span class="kw">:as</span> <span class="kw">walk</span>]))</code></pre>
<h3 id="refer选项"><a href="#refer选项">:refer选项</a></h3>
<p>如果想在当前命名空间里通过简写名称来引用clojure.set空间里的函数,可以通过refer来实现:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">difference</span> <span class="kw">intersection</span>]]))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (difference #{1 2 3} #{3 4 5})</span></code></pre>
<p>:require形式中的:refer特性为Clojure1.4新增特性.</p>
<p>可能有时需要引入某个命名空间下所有的函数:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> <span class="kw">:all</span>]))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (difference #{1 2 3} #{3 4 5})</span></code></pre>
<h2 id="import"><a href="#import">:import</a></h2>
<p>:import的作用是在当前命名空间引入Java类:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:import</span> java.util.concurrent.Executors))</code></pre>
<p>执行上面的代码后,java.util.concurrent.Executors类将会被引入,请可以直接通过名字Executors来使用.可以同时引入多个类.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:import</span> java.util.concurrent.Executors
                     java.util.concurrent.TimeUnit
                     java.util.Date))</code></pre>
<p>如果引入的多个类在同一个包下面,就像上面那样,可以使用如下的简介方式:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:import</span> [java.util.concurrent Executors TimeUnit]
                     java.util.Date))</code></pre>
<p>虽然导入的list被叫做list,实际上可以使用任意的Clojure的集合(一般使用vector)</p>
<h2 id="当前命名空间"><a href="#当前命名空间">当前命名空间</a></h2>
<p>Clojure将通过*ns*来持有当前的命名空间.使用def形式定义的var被添加到了当前命名空间中.</p>
<h2 id="refer-clojure"><a href="#refer-clojure">:refer-clojure</a></h2>
<p>我们在使用像clojure.core/get这样的函数和clojure.core/defn这样的宏的时候我们不需要使用它的全限定名.这是因为Clojure默认将clojure.core下的内容全部加载进了当前命名空间里了.所以如果你定义了一个函数名和clojure.core里的重复了(比如find),你将会得到一个警告.</p>
<pre class="sh"><code>WARNING: find already refers to: #&#39;clojure.core/find in namespace:    megacorp.profitd.scheduling, being replaced by: #&#39;megacorp.profitd.scheduling/find</code></pre>
<p>这个警告的意思是在megacorp.profitd.scheduling这个命名空间里,已经有一个clojure.core/find了,但是现在它被你定义的函数覆盖了.请记住,Clojure是很动态的语言,命名空间就是map而已.</p>
<p>解决这个问题的办法有:你可以重命名你的函数或者不引入clojure.core里的这个函数</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:refer-clojure</span> <span class="kw">:exclude</span> [<span class="kw">find</span>]))
          
          (<span class="kw">defn</span><span class="fu"> find</span>
            <span class="st">&quot;Finds a needle in the haystack.&quot;</span>
            [^String haystack]
            (<span class="kw">comment</span> ...))</code></pre>
<p>在这里,如果你想使用clojure.core/find的话,你需要通过全限定名来使用:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:refer-clojure</span> <span class="kw">:exclude</span> [<span class="kw">find</span>]))
          
          (<span class="kw">defn</span><span class="fu"> find</span>
            <span class="st">&quot;Finds a needle in the haystack.&quot;</span>
            [^String haystack]
            (clojure.core/find haystack <span class="kw">:needle</span>))</code></pre>
<h2 id="use"><a href="#use">:use</a></h2>
<p>Clojure在1.4之前,:require是不支持:refer的,只能使用:use</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling-test
            (<span class="kw">:use</span> clojure.<span class="kw">test</span>))</code></pre>
<p>在上面的例子中,clojure.test里的所有内容都被引入到了当前命名空间中.但是一般不会这样使用,建议是只引入需要的函数:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling-test
            (<span class="kw">:use</span> clojure.<span class="kw">test</span> <span class="kw">:only</span> [<span class="kw">deftest</span><span class="fu"> testing </span><span class="kw">is</span>]))</code></pre>
<p>1.4以前的做法</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling-test
            (<span class="kw">:require</span> clojure.<span class="kw">test</span> <span class="kw">:refer</span> [<span class="kw">deftest</span><span class="fu"> testing </span><span class="kw">is</span>]))</code></pre>
<p>而现在鼓励的做法是使用:require,通过:refer来进行限制.</p>
<h2 id="文档与元数据"><a href="#文档与元数据">文档与元数据</a></h2>
<p>命名空间可以包含说明文档.你可以在ns宏里添加:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> superlib.core
            <span class="st">&quot;Core functionality of Superlib.</span>
          
          <span class="st">   Other parts of Superlib depend on functions and macros in this namespace.&quot;</span>
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">union</span> <span class="kw">difference</span>]]))</code></pre>
<p>或者元数据</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> ^{<span class="kw">:doc</span> <span class="st">&quot;Core functionality of Superlib.</span>
          <span class="st">            Other parts of Superlib depend on functions and macros in this namespace.&quot;</span>
                <span class="kw">:author</span> <span class="st">&quot;Joe Smith&quot;</span>}
             superlib.core
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">union</span> <span class="kw">difference</span>]]))</code></pre>
<p>元数据可以包含任意的键,例如:author,很多工具可以使用(像Codox,Cadastre或者lein-clojuredocs)</p>
<h1 id="如何在repl里使用其它命名空间的函数"><a href="#如何在repl里使用其它命名空间的函数">如何在REPL里使用其它命名空间的函数</a></h1>
<p>ns宏是你经常需要使用的,它引入其它命名空间的函数.但是它在REPL里不太方便.这里可以直接使用require:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; Will be available as clojure.set, e.g. clojure.set/difference.</span>
          (<span class="kw">require</span> &#39;clojure.<span class="kw">set</span>)
          
          <span class="co">;; Will be available as io, e.g. io/resource.</span>
          (<span class="kw">require</span> &#39;[clojure.java.io <span class="kw">:as</span> io])
          It takes a quoted libspec. The libspec <span class="kw">is</span> either a <span class="kw">namespace</span> <span class="kw">name</span> <span class="kw">or</span> a collection (typically a <span class="kw">vector</span>) of [<span class="kw">name</span> <span class="kw">:as</span> <span class="kw">alias</span>] <span class="kw">or</span> [<span class="kw">name</span> <span class="kw">:refer</span> [fns]]:
          
          (<span class="kw">require</span> &#39;[clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">difference</span>]])
          
          (<span class="kw">difference</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>})  <span class="co">; ⇒ #{1 2}</span></code></pre>
<p>:as和:refer可以一起使用</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">require</span> &#39;[clojure.<span class="kw">set</span> <span class="kw">:as</span> cs <span class="kw">:refer</span> [<span class="kw">difference</span>]])
          
          (<span class="kw">difference</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>})  <span class="co">; ⇒ #{1 2}</span>
          (cs/union #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>})    <span class="co">; ⇒ #{1 2 3 4 5 6}</span></code></pre>
<p>clojure.core/use可以做和clojure.core/require一样的事情,但是不推荐使用了.</p>
<h1 id="命名空间和编译"><a href="#命名空间和编译">命名空间和编译</a></h1>
<p>Clojure是一个需要编译的语言:代码在被加载的时候进行编译.</p>
<p>命名空间可以包含var或者去继承协议,添加多重方法实现或载入其它库.所以为了完成编译,你需要引入需要的命名空间.</p>
<h1 id="私有vars"><a href="#私有vars">私有Vars</a></h1>
<p>Vars(包括defn宏定义的函数)可以设为私有的.有两种方法可以来做这件事情:使用元数据或者defn-宏</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.superlib)
          
          <span class="co">;;</span>
          <span class="co">;; Implementation</span>
          <span class="co">;;</span>
          
          (<span class="kw">def</span><span class="fu"> </span>^{<span class="kw">:private</span> true}
            source-name <span class="st">&quot;supersource&quot;</span>)
          
          (<span class="kw">defn-</span><span class="fu"> data-stream</span>
            [source]
            (<span class="kw">comment</span> ...))</code></pre>
<h1 id="常量vars"><a href="#常量vars">常量Vars</a></h1>
<p>Vars可以设为常量,通过:const元数据来设置.这将会促使Clojure编译器将其编译为常量:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.epicgame)
          
          <span class="co">;;</span>
          <span class="co">;; Implementation</span>
          <span class="co">;;</span>
          
          (<span class="kw">def</span><span class="fu"> </span>^{<span class="kw">:const</span> true}
            default-score <span class="dv">100</span>)</code></pre>
<h1 id="如何通过名称来查找和执行函数"><a href="#如何通过名称来查找和执行函数">如何通过名称来查找和执行函数</a></h1>
<p>可以通过clojure.core/resolve在制定的命名空间里通过名字查找函数.名字需要使用引号修饰.返回值可以直接当做函数使用,比如,当做参数传递给高阶函数:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">resolve</span> &#39;clojure.<span class="kw">set</span> &#39;difference)  <span class="co">; ⇒ #&#39;clojure.set/difference</span>
          
          (<span class="kw">let</span> [f (<span class="kw">resolve</span> &#39;clojure.<span class="kw">set</span> &#39;difference)]
             (f #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>}))  <span class="co">; ⇒ #{1 2}</span></code></pre>
<h1 id="编译异常"><a href="#编译异常">编译异常</a></h1>
<p>本节讨论一些常见的编译错误.</p>
<h2 id="classnotfoundexception"><a href="#classnotfoundexception">ClassNotFoundException</a></h2>
<p>这个异常的意思是JVM无法加载类.可能是因为拼写错误,或者在classpath上没有这个类.可能是你的项目没有很好的处理依赖关系.</p>
<pre><code>user=&gt; (import java.uyil.concurrent.TimeUnit)
          ClassNotFoundException java.uyil.concurrent.TimeUnit  java.net.URLClassLoader$1.run (URLClassLoader.java:366)</code></pre>
<p>在上面的例子中,java.uyil.concurrent.TimeUnit拼写错误,应该是java.util.concurrent.TimeUnit</p>
<h2 id="compilerexception-java.lang.runtimeexception-no-such-var"><a href="#compilerexception-java.lang.runtimeexception-no-such-var">CompilerException java.lang.RuntimeException: No such var</a></h2>
<p>这个错误的意思是,使用了一个不存在的var.这可能是拼写错误,或者不正确的宏展开等类似问题.</p>
<pre><code>user=&gt; (clojure.java.io/resouce &quot;thought_leaders_quotes.csv&quot;)
          CompilerException java.lang.RuntimeException: No such var: clojure.java.io/resouce, compiling:(NO_SOURCE_PATH:1)</code></pre>
<p>在上面的例子中,clojure.java.io/resouce应该写成clojure.java.io/resource.NO_SOURCE_PATH的意思是编译是在repl里触发的,而不是一个Clojure源文件.</p>
</p></div>
</p></div>
</p></div>
</p></div>

</div>

    <div class="pure-g pagination">
        
        <a class="pure-u-1-2 pagination-item " href="/%E5%BB%BA%E7%AB%99%E6%97%A5%E8%AE%B0/%25e5%259c%25a8github%25e9%2583%25a8%25e7%25bd%25b2octopress.html" title="在GitHub部署OctoPress "><p> <i class="fa fa-mail-reply"></i>&nbsp;在GitHub部署OctoPress</p></a>
        
        
        <a class="pure-u-1-2 pagination-item " href="/cat1/test.html" title="Sample2"><p>Sample2&nbsp;<i class="fa fa-mail-forward"></i></p></a>
        
    </div>
    <link href="/css/code.css" rel="stylesheet">
    <link href="/css/min/fancybox.css" rel="stylesheet">
    <script src="/js/min/jquery.toc.min.js" ></script>
    <script src="/js/min/jquery.qrcode.min.js" ></script>
    <script src="/js/min/jquery.fancybox.pack.js" ></script>
    <script src="/js/page.js" ></script>

    
    

    
    
    <a name="comments"> </a>
<div id="comment">
    <div class="ds-thread" data-title="Clojure教程:命名空间"></div>
    <script type="text/javascript">
        var duoshuoQuery = {short_name:""};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = '../js/min/duoshuo.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0]
                    || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
</div>

    






            </div>
            </div>
        <div class="footer">
                <a href="/love/welcome-my-blog.html">About</a>
                 <a href="/1">Collecting</a>
                <a href="tencent://message/?uin=561802774">QQ</a>
                <a href="https://github.com/ivanpig">GitHub</a>
            <script src="/js/min/nprogress.min.js"></script>
            <script src="/js/index.js"></script>
        </div>
        <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

    </div>

</div>

</body>

</html>
