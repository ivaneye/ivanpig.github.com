<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>IvanPig's Blog</title>
    <link href="http://ivanpig.github.io/rss.xml" rel="self"/>
    <link href="http://ivanpig.github.io/"/>
    <updated>2015-03-10T21:12:53+08:00</updated>
    <id>http://ivanpig.github.io/</id>
    <author>
        <name>Ivan</name>
        <email>ivan.pig@foxmail.com</email>
    </author>

    
    <entry>
        <title>一图胜千言:事务管理</title>
        <link href="http://ivanpig.github.io/2015/03/10/transactional.html"/>
        <updated>2015-03-10T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/03/10/transactional</id>
        <content type="html">&lt;p&gt;&lt;img src=&quot;/mind/transaction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/mind/transaction.xmind&quot;&gt;xmind文件下载&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;&lt;img src=&quot;/mind/transaction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/mind/transaction.xmind&quot;&gt;xmind文件下载&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>传统软件OR互联网软件?</title>
        <link href="http://ivanpig.github.io/2015/03/08/soft.html"/>
        <updated>2015-03-08T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/03/08/soft</id>
        <content type="html">&lt;p&gt;人近而立之年，考虑以后的目标和发展。自身有4年的传统软件经验，3年多的互联网软件经验。&lt;/p&gt;

&lt;p&gt;就个人经历来看，传统软件和互联网软件区别并没有想象中大，只是关注点有些区别!&lt;/p&gt;

&lt;h1&gt;概念区分&lt;/h1&gt;

&lt;p&gt;一般来说传统软件指的就是针对甲方用户定制的软件，此类软件安装在甲方内部服务器，一般不会接到互联网上。&lt;/p&gt;

&lt;p&gt;互联网软件则是部署在互联网上供普通网民使用，给网民提供服务的软件。此类软件由开发方自主部署，维护，运营。&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;人近而立之年，考虑以后的目标和发展。自身有4年的传统软件经验，3年多的互联网软件经验。&lt;/p&gt;

&lt;p&gt;就个人经历来看，传统软件和互联网软件区别并没有想象中大，只是关注点有些区别!&lt;/p&gt;

&lt;h1&gt;概念区分&lt;/h1&gt;

&lt;p&gt;一般来说传统软件指的就是针对甲方用户定制的软件，此类软件安装在甲方内部服务器，一般不会接到互联网上。&lt;/p&gt;

&lt;p&gt;互联网软件则是部署在互联网上供普通网民使用，给网民提供服务的软件。此类软件由开发方自主部署，维护，运营。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>刨根问底-02为什么Java接口中的成员变量被设计为必须是public static final的？</title>
        <link href="http://ivanpig.github.io/2015/03/03/interface_field.html"/>
        <updated>2015-03-03T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/03/03/interface_field</id>
        <content type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;此为&quot;刨根问底&quot;系列文章的第二篇，接上篇，为什么Java接口中的成员变量被设计为必须是public static final的？&lt;/p&gt;

&lt;h1&gt;网络答案&lt;/h1&gt;

&lt;p&gt;在网络上搜索到了如下两篇还算靠谱的解答!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://shaomeng95.iteye.com/blog/998820&quot;&gt;网络解答1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.xyzws.com/javafaq/why-do-we-have-only-public-static-final-variables-in-interfaces/129&quot;&gt;网络解答2&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;解释&lt;/h1&gt;

&lt;p&gt;上篇我们用反证法来证明了接口方法设为public为最合适选择!&lt;/p&gt;

&lt;p&gt;这里我们依然可以使用反证法来解释!&lt;/p&gt;

&lt;p&gt;假设接口中的成员变量不是public static final的!&lt;/p&gt;

&lt;p&gt;先将属性设置为private的!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  private int num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK!private的属性，当然只能在接口内部使用了!但是在接口里面给谁使用呢？接口里的方法只有方法头可没方法体！所以设为private，那就永远都访问不到了！&lt;/p&gt;

&lt;p&gt;好，那我们改成protected!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  protected int num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子类就能访问了！但是外部如何访问呢？方法是有的:&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  protected int num;

  int getNum();
  void setNum(int num);
}

class PersonA implements Person{
  public int getNum(){
    return num;
  }
  public void setNum(int num){
    this.num = num;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有100个类实现了Person接口！请问有多少重复代码?&lt;/p&gt;

&lt;p&gt;接着是默认访问权限控制符:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  //非public static final
  int num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于包外的类来说，和protected一样的问题!这里不废话了！&lt;/p&gt;

&lt;p&gt;最后就只剩下public了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  public int num;
}

public class PersonA implements Person{
  public int num = 2;
}

public class Test{
  public static void main(String[] args){
    PersonA pa = new PersonA();
    System.out.println(pa.num); //打印结果是？
    Person p = pa;
    System.out.println(p.num); //打印结果是？
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码你会发现，两者打印结果居然不相同！这就好像是，这个&quot;协议&quot;公开是一套，而如果你有关系，会给你另一套&quot;内部协议&quot;!&lt;/p&gt;

&lt;p&gt;究其原因，就是这个成员变量是属于实现了这个接口的对象的，并不属于接口本身。因为你需要先实例化实现了此接口的类才可以操作这个成员变量，而接口本身并不能实例化！&lt;/p&gt;

&lt;p&gt;所以如果想这个成员变量为接口所有，只能将其设为static!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  public static int num;
}

public class PersonA implements Person{}
public class PersonB implements Person{}

public class Test{
  public static void main(String[] args){
    System.out.println(Person.num); //结果？
    PersonA.num = 2;
    System.out.println(Person.num); //结果？
    PersonB.num = 2;
    System.out.println(Person.num); //结果？
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码的意思就是，A和B遵循了&quot;协议&quot;Person，但是只要A或B感觉不满意就可以随便改！那还叫&quot;协议&quot;吗?&lt;/p&gt;

&lt;p&gt;所以只能加上final来限制修改!&lt;/p&gt;

&lt;p&gt;而对于添加public final的效果，和只添加public的问题相同！不多说！&lt;/p&gt;

&lt;p&gt;从上面的修改可以看出，public static final修饰符，缺少任何之一都会导致&quot;协议&quot;的不公正!&lt;/p&gt;

&lt;p&gt;你可以把接口看作是合同!成员变量看作合同说明，确定后当然是不能变的!至于如何去执行这个合同，那就随便了！&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;此为&quot;刨根问底&quot;系列文章的第二篇，接上篇，为什么Java接口中的成员变量被设计为必须是public static final的？&lt;/p&gt;

&lt;h1&gt;网络答案&lt;/h1&gt;

&lt;p&gt;在网络上搜索到了如下两篇还算靠谱的解答!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://shaomeng95.iteye.com/blog/998820&quot;&gt;网络解答1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.xyzws.com/javafaq/why-do-we-have-only-public-static-final-variables-in-interfaces/129&quot;&gt;网络解答2&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;解释&lt;/h1&gt;

&lt;p&gt;上篇我们用反证法来证明了接口方法设为public为最合适选择!&lt;/p&gt;

&lt;p&gt;这里我们依然可以使用反证法来解释!&lt;/p&gt;

&lt;p&gt;假设接口中的成员变量不是public static final的!&lt;/p&gt;

&lt;p&gt;先将属性设置为private的!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  private int num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK!private的属性，当然只能在接口内部使用了!但是在接口里面给谁使用呢？接口里的方法只有方法头可没方法体！所以设为private，那就永远都访问不到了！&lt;/p&gt;

&lt;p&gt;好，那我们改成protected!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  protected int num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子类就能访问了！但是外部如何访问呢？方法是有的:&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  protected int num;

  int getNum();
  void setNum(int num);
}

class PersonA implements Person{
  public int getNum(){
    return num;
  }
  public void setNum(int num){
    this.num = num;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有100个类实现了Person接口！请问有多少重复代码?&lt;/p&gt;

&lt;p&gt;接着是默认访问权限控制符:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  //非public static final
  int num;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于包外的类来说，和protected一样的问题!这里不废话了！&lt;/p&gt;

&lt;p&gt;最后就只剩下public了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  public int num;
}

public class PersonA implements Person{
  public int num = 2;
}

public class Test{
  public static void main(String[] args){
    PersonA pa = new PersonA();
    System.out.println(pa.num); //打印结果是？
    Person p = pa;
    System.out.println(p.num); //打印结果是？
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码你会发现，两者打印结果居然不相同！这就好像是，这个&quot;协议&quot;公开是一套，而如果你有关系，会给你另一套&quot;内部协议&quot;!&lt;/p&gt;

&lt;p&gt;究其原因，就是这个成员变量是属于实现了这个接口的对象的，并不属于接口本身。因为你需要先实例化实现了此接口的类才可以操作这个成员变量，而接口本身并不能实例化！&lt;/p&gt;

&lt;p&gt;所以如果想这个成员变量为接口所有，只能将其设为static!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  public static int num;
}

public class PersonA implements Person{}
public class PersonB implements Person{}

public class Test{
  public static void main(String[] args){
    System.out.println(Person.num); //结果？
    PersonA.num = 2;
    System.out.println(Person.num); //结果？
    PersonB.num = 2;
    System.out.println(Person.num); //结果？
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码的意思就是，A和B遵循了&quot;协议&quot;Person，但是只要A或B感觉不满意就可以随便改！那还叫&quot;协议&quot;吗?&lt;/p&gt;

&lt;p&gt;所以只能加上final来限制修改!&lt;/p&gt;

&lt;p&gt;而对于添加public final的效果，和只添加public的问题相同！不多说！&lt;/p&gt;

&lt;p&gt;从上面的修改可以看出，public static final修饰符，缺少任何之一都会导致&quot;协议&quot;的不公正!&lt;/p&gt;

&lt;p&gt;你可以把接口看作是合同!成员变量看作合同说明，确定后当然是不能变的!至于如何去执行这个合同，那就随便了！&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>刨根问底-01为什么Java接口中的方法默认是public？</title>
        <link href="http://ivanpig.github.io/2015/03/02/interface_method.html"/>
        <updated>2015-03-02T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/03/02/interface_method</id>
        <content type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;去年担任了公司Java培训班的培训讲师！由于时间关系，课堂上只是讲了How，而很少涉及到Why!&lt;/p&gt;

&lt;p&gt;故计划编写此&quot;刨根问底&quot;系列文章，主要解释Java中的Why!&lt;/p&gt;

&lt;p&gt;此为该系列文章的第一篇，为什么Java接口中的方法默认是public的？&lt;/p&gt;

&lt;h1&gt;解释&lt;/h1&gt;

&lt;p&gt;首先我们来看下接口的定义，在《Thinking in Java》中，对接口做了如下定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;example&quot;&gt;An interface says, &quot;All classes that implement this particular interface will look like this.&quot; Thus, any code that uses a particular interface knows what methods might be called for that interface, and that’s all. So the interface is used to establish a &quot;protocol&quot; between classes. (Some object-oriented programming languages have a keyword called protocol to do the
same thing.)

接口意味着：&quot;所有实现了这个特定接口的类都应该可以被当作这个接口来看待&quot;。也就是说，所有使用此特定接口的代码都应该知道该接口有哪些方法可以被调用，而且仅此而已！所以接口被用来定义接口之间的协议！(有些语言使用protocol这个关键字来做Java中interface关键字所要做的事情，例如:Clojure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说来，接口就是用来定义一个&quot;协议&quot;的！这么看来，protocol这个关键字应该比interface这个关键字更加的准确！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//Java接口定义
public interface Person{
  void say();
}

//这样会不会更合理？
public protocol Person{
  void say();
}

//Clojure类似代码
(defprotocol Person
  (say [this]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的接口就定义了一个&quot;协议&quot;,这个协议就是:&quot;所有遵循这个协议(实现此接口)的类，必然有一个叫做say()的方法&quot;。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class PersonA implements Person{
  public void say(){
    System.out.println(&quot;Hello PersonA&quot;);
  }
}

public class PersonB implements Person{
  public void say(){
    System.out.println(&quot;Hello PersonB&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里PersonA遵循了这个协议，PersonB也遵循了这个协议。那在我们使用的时候，我们完全就没必要关心是PersonA还是PersonB，我们只关心它是不是一个Person就可以了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Test{
  public static void main(String[] args){
    //不管是PersonA还是PersonB，肯定是个Person
    Person p = new PersonA(); //或 new PersonB();
    //不管是PersonA还是PersonB，肯定有say()方法
    p.say();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道Java里面有四种访问权限控制符！private,protected,package(default),public!&lt;/p&gt;

&lt;p&gt;那为什么接口的方法默认是public的呢？我们使用假设法来一个个的看！&lt;/p&gt;

&lt;p&gt;假设接口的方法是private的！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  private void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;private的访问控制是只在类内部可见！这里就相当于说:&quot;所有遵循这个协议(实现此接口)的类，必然有一个方法，至于方法是什么，呵呵，你们猜！&quot;。这是作死的节奏！&lt;/p&gt;

&lt;p&gt;假设接口的方法是protected的！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  protected void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;protected的访问控制是只在类或子类内部可见！这里就相当于说:&quot;所有遵循这个协议(实现此接口)的类，必然有一个方法，至于方法是什么，你来当我儿子啊，我再告诉你！&quot;。这个就更是作死了～&lt;/p&gt;

&lt;p&gt;最后，假设接口的方法是默认修饰符！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
   //假设这里不会自动加public修饰符
   void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认访问控制是只在相同的包下的类可见！这里就相当于说:&quot;所有遵循这个协议(实现此接口)的类，必然有一个方法，至于方法是什么，你到我包间来，我再告诉你！&quot;。这个好像还能接受！但是你进去你看，全是人，感觉像传销啊！原因是所有需要和此协议交互的类都必须要在协议所在的包内，导致此包过大，且杂乱！&lt;/p&gt;

&lt;p&gt;最后看public修饰:&lt;/p&gt;

&lt;p&gt;public访问控制是任何的类都可以访问！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不像private,不告诉你方法是什么&lt;/li&gt;
&lt;li&gt;不像protected，需要继承才告诉你&lt;/li&gt;
&lt;li&gt;不像默认访问控制符，需要在相同的包下才告诉你&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;综上所述，接口方法设为public为最合适选择!&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;去年担任了公司Java培训班的培训讲师！由于时间关系，课堂上只是讲了How，而很少涉及到Why!&lt;/p&gt;

&lt;p&gt;故计划编写此&quot;刨根问底&quot;系列文章，主要解释Java中的Why!&lt;/p&gt;

&lt;p&gt;此为该系列文章的第一篇，为什么Java接口中的方法默认是public的？&lt;/p&gt;

&lt;h1&gt;解释&lt;/h1&gt;

&lt;p&gt;首先我们来看下接口的定义，在《Thinking in Java》中，对接口做了如下定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;example&quot;&gt;An interface says, &quot;All classes that implement this particular interface will look like this.&quot; Thus, any code that uses a particular interface knows what methods might be called for that interface, and that’s all. So the interface is used to establish a &quot;protocol&quot; between classes. (Some object-oriented programming languages have a keyword called protocol to do the
same thing.)

接口意味着：&quot;所有实现了这个特定接口的类都应该可以被当作这个接口来看待&quot;。也就是说，所有使用此特定接口的代码都应该知道该接口有哪些方法可以被调用，而且仅此而已！所以接口被用来定义接口之间的协议！(有些语言使用protocol这个关键字来做Java中interface关键字所要做的事情，例如:Clojure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说来，接口就是用来定义一个&quot;协议&quot;的！这么看来，protocol这个关键字应该比interface这个关键字更加的准确！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//Java接口定义
public interface Person{
  void say();
}

//这样会不会更合理？
public protocol Person{
  void say();
}

//Clojure类似代码
(defprotocol Person
  (say [this]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的接口就定义了一个&quot;协议&quot;,这个协议就是:&quot;所有遵循这个协议(实现此接口)的类，必然有一个叫做say()的方法&quot;。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class PersonA implements Person{
  public void say(){
    System.out.println(&quot;Hello PersonA&quot;);
  }
}

public class PersonB implements Person{
  public void say(){
    System.out.println(&quot;Hello PersonB&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里PersonA遵循了这个协议，PersonB也遵循了这个协议。那在我们使用的时候，我们完全就没必要关心是PersonA还是PersonB，我们只关心它是不是一个Person就可以了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Test{
  public static void main(String[] args){
    //不管是PersonA还是PersonB，肯定是个Person
    Person p = new PersonA(); //或 new PersonB();
    //不管是PersonA还是PersonB，肯定有say()方法
    p.say();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道Java里面有四种访问权限控制符！private,protected,package(default),public!&lt;/p&gt;

&lt;p&gt;那为什么接口的方法默认是public的呢？我们使用假设法来一个个的看！&lt;/p&gt;

&lt;p&gt;假设接口的方法是private的！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  private void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;private的访问控制是只在类内部可见！这里就相当于说:&quot;所有遵循这个协议(实现此接口)的类，必然有一个方法，至于方法是什么，呵呵，你们猜！&quot;。这是作死的节奏！&lt;/p&gt;

&lt;p&gt;假设接口的方法是protected的！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
  protected void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;protected的访问控制是只在类或子类内部可见！这里就相当于说:&quot;所有遵循这个协议(实现此接口)的类，必然有一个方法，至于方法是什么，你来当我儿子啊，我再告诉你！&quot;。这个就更是作死了～&lt;/p&gt;

&lt;p&gt;最后，假设接口的方法是默认修饰符！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Person{
   //假设这里不会自动加public修饰符
   void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认访问控制是只在相同的包下的类可见！这里就相当于说:&quot;所有遵循这个协议(实现此接口)的类，必然有一个方法，至于方法是什么，你到我包间来，我再告诉你！&quot;。这个好像还能接受！但是你进去你看，全是人，感觉像传销啊！原因是所有需要和此协议交互的类都必须要在协议所在的包内，导致此包过大，且杂乱！&lt;/p&gt;

&lt;p&gt;最后看public修饰:&lt;/p&gt;

&lt;p&gt;public访问控制是任何的类都可以访问！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不像private,不告诉你方法是什么&lt;/li&gt;
&lt;li&gt;不像protected，需要继承才告诉你&lt;/li&gt;
&lt;li&gt;不像默认访问控制符，需要在相同的包下才告诉你&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;综上所述，接口方法设为public为最合适选择!&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言和并发-01启动线程</title>
        <link href="http://ivanpig.github.io/2015/03/01/start.html"/>
        <updated>2015-03-01T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/03/01/start</id>
        <content type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;本系列文章意在比较Java与Clojure在线程实现上的区别！&lt;/p&gt;

&lt;p&gt;Java的线程主要基于锁机制，而Clojure主要模拟了数据库事务操作，所谓的STM(软事务模型)。主要从代码层面给出两者的区别，孰优孰劣请自行判断！&lt;/p&gt;

&lt;h1&gt;启动线程&lt;/h1&gt;

&lt;h2&gt;Java代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Java实例中，两个线程类A和B，分别通过实现Runnable接口和继承Thread类来实现&lt;/li&gt;
&lt;li&gt;两各类启动线程的方式有差异，详见代码&lt;/li&gt;
&lt;li&gt;JDK5中提供了线程启动类Executors来执行&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package concurrent;

import java.util.concurrent.*;

/**
 * Created by ivan on 15-2-22.
 * Java启动线程
 */
public class Start {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //实现Runnable接口，需要通过一个Thread实例来启动线程
        new Thread(new A()).start();
        //继承Thread类，直接通过自身来启动线程
        new B().start();

        //JDK1.5开始，可以通过Executor来执行线程.效果和上面没有区别
        ExecutorService e = Executors.newCachedThreadPool();
        e.execute(new A());
        e.execute(new B());
        //Callable需要submit,返回Future
        Future&amp;lt;String&amp;gt; f = e.submit(new C());
        //get方法是个阻塞方法
        System.out.println(&quot;Future f = &quot; + f.get());
        e.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 线程类可以实现Runnable接口
 */
class A implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 9; i++) {
            System.out.println(&quot;ThreadID:&quot; + Thread.currentThread().getId() + &quot; | i = &quot; + i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 线程类也可以继承Thread类
 */
class B extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 9; i++) {
            System.out.println(&quot;ThreadID:&quot; + Thread.currentThread().getId() + &quot; | i = &quot; + i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 如果想线程返回结果，则实现Callable接口
 */
class C implements Callable&amp;lt;String&amp;gt; {

    @Override
    public String call() throws Exception {
        for (int i = 0; i &amp;lt; 9; i++) {
            System.out.println(&quot;ThreadID:&quot; + Thread.currentThread().getId() + &quot; | i = &quot; + i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return &quot;End&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Clojure代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Clojure可以直接对函数进行多线程执行，因为它没有类的概念&lt;/li&gt;
&lt;li&gt;Clojure可以直接通过Java的Thread类来启动多线程&lt;/li&gt;
&lt;li&gt;也可以通过future来执行多线程&lt;/li&gt;
&lt;li&gt;future可以返回值，可对其进行解引用，获得返回值，如果线程未执行完，则阻塞。&lt;/li&gt;
&lt;li&gt;future实际上就是Java中Future实例，可以直接调用future的get方法获取返回值，效果和解引用相同&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns concurrent.start)

;Clojure没有类的概念，直接给出函数
(defn f []
  (dotimes [i 9]
    (println  &quot; | i = &quot; i)
    (Thread/sleep 300))
  :End)

;可以通过Java的Thread来执行
(.start (Thread. f))

;Clojure提供了future宏，可以方便的在另一个线程内执行
(def fu (future  (f)))

;主线程结束
(println &quot;End&quot;)

;对future可以解引用，获取计算结果，如果解引用时，future没执行完，会阻塞
(println &quot;fu result = &quot; @fu)

;fu实际上就是Java中的Future,所以可以使用Future的get方法，效果和解引用相同
(println &quot;Future.get = &quot; (.get fu))

;调用此方法结束所有线程
(shutdown-agents)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;本系列文章意在比较Java与Clojure在线程实现上的区别！&lt;/p&gt;

&lt;p&gt;Java的线程主要基于锁机制，而Clojure主要模拟了数据库事务操作，所谓的STM(软事务模型)。主要从代码层面给出两者的区别，孰优孰劣请自行判断！&lt;/p&gt;

&lt;h1&gt;启动线程&lt;/h1&gt;

&lt;h2&gt;Java代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Java实例中，两个线程类A和B，分别通过实现Runnable接口和继承Thread类来实现&lt;/li&gt;
&lt;li&gt;两各类启动线程的方式有差异，详见代码&lt;/li&gt;
&lt;li&gt;JDK5中提供了线程启动类Executors来执行&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package concurrent;

import java.util.concurrent.*;

/**
 * Created by ivan on 15-2-22.
 * Java启动线程
 */
public class Start {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //实现Runnable接口，需要通过一个Thread实例来启动线程
        new Thread(new A()).start();
        //继承Thread类，直接通过自身来启动线程
        new B().start();

        //JDK1.5开始，可以通过Executor来执行线程.效果和上面没有区别
        ExecutorService e = Executors.newCachedThreadPool();
        e.execute(new A());
        e.execute(new B());
        //Callable需要submit,返回Future
        Future&amp;lt;String&amp;gt; f = e.submit(new C());
        //get方法是个阻塞方法
        System.out.println(&quot;Future f = &quot; + f.get());
        e.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 线程类可以实现Runnable接口
 */
class A implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 9; i++) {
            System.out.println(&quot;ThreadID:&quot; + Thread.currentThread().getId() + &quot; | i = &quot; + i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 线程类也可以继承Thread类
 */
class B extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 9; i++) {
            System.out.println(&quot;ThreadID:&quot; + Thread.currentThread().getId() + &quot; | i = &quot; + i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;/**
 * 如果想线程返回结果，则实现Callable接口
 */
class C implements Callable&amp;lt;String&amp;gt; {

    @Override
    public String call() throws Exception {
        for (int i = 0; i &amp;lt; 9; i++) {
            System.out.println(&quot;ThreadID:&quot; + Thread.currentThread().getId() + &quot; | i = &quot; + i);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return &quot;End&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Clojure代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Clojure可以直接对函数进行多线程执行，因为它没有类的概念&lt;/li&gt;
&lt;li&gt;Clojure可以直接通过Java的Thread类来启动多线程&lt;/li&gt;
&lt;li&gt;也可以通过future来执行多线程&lt;/li&gt;
&lt;li&gt;future可以返回值，可对其进行解引用，获得返回值，如果线程未执行完，则阻塞。&lt;/li&gt;
&lt;li&gt;future实际上就是Java中Future实例，可以直接调用future的get方法获取返回值，效果和解引用相同&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns concurrent.start)

;Clojure没有类的概念，直接给出函数
(defn f []
  (dotimes [i 9]
    (println  &quot; | i = &quot; i)
    (Thread/sleep 300))
  :End)

;可以通过Java的Thread来执行
(.start (Thread. f))

;Clojure提供了future宏，可以方便的在另一个线程内执行
(def fu (future  (f)))

;主线程结束
(println &quot;End&quot;)

;对future可以解引用，获取计算结果，如果解引用时，future没执行完，会阻塞
(println &quot;fu result = &quot; @fu)

;fu实际上就是Java中的Future,所以可以使用Future的get方法，效果和解引用相同
(println &quot;Future.get = &quot; (.get fu))

;调用此方法结束所有线程
(shutdown-agents)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-23迭代器模式</title>
        <link href="http://ivanpig.github.io/2015/02/25/iterator.html"/>
        <updated>2015-02-25T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/25/iterator</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/iterator.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;访问一个聚合对象的内容而无需暴露它的内部表示。&lt;/li&gt;
&lt;li&gt;支持对聚合对象的多种遍历。&lt;/li&gt;
&lt;li&gt;为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;Java提供了Iterable接口，直接实现此接口即可!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class AList implements Iterable{
    ...
    private int idx;

    public static void main(String[] args) {
        AList list = new AList();
        list.add(1);
        list.add(2);
        list.add(3);
        for(Object o : list){
            System.out.println(o);
        }
    }

    @Override
    public Iterator iterator() {
        return new Iterator() {
            @Override
            public boolean hasNext() {
                return idx &amp;lt; length;
            }

            @Override
            public Object next() {
                return arr[idx++];
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;对于集合的操作都有相应的函数！一般不需要遍历就可以操作集合！比如map,reduce等函数！不需要此模式!&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;可以看出，对于Clojure来说，绝大部分的设计模式都不是必须的！很多所谓的设计模式，在Clojure中使用语言特性就可以轻松解决！&lt;/p&gt;

&lt;p&gt;同时可以看出，Java之所以需要设计模式的一个原因就是它的最小单元是类！也同时引起另一个思考，面向对象语言有鼓吹的那么好吗？&lt;/p&gt;

&lt;p&gt;至少目前我的观点是：OO强项在建模，弱项是计算，而计算正是函数式语言的强项！&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/iterator.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;访问一个聚合对象的内容而无需暴露它的内部表示。&lt;/li&gt;
&lt;li&gt;支持对聚合对象的多种遍历。&lt;/li&gt;
&lt;li&gt;为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;Java提供了Iterable接口，直接实现此接口即可!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class AList implements Iterable{
    ...
    private int idx;

    public static void main(String[] args) {
        AList list = new AList();
        list.add(1);
        list.add(2);
        list.add(3);
        for(Object o : list){
            System.out.println(o);
        }
    }

    @Override
    public Iterator iterator() {
        return new Iterator() {
            @Override
            public boolean hasNext() {
                return idx &amp;lt; length;
            }

            @Override
            public Object next() {
                return arr[idx++];
            }
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;对于集合的操作都有相应的函数！一般不需要遍历就可以操作集合！比如map,reduce等函数！不需要此模式!&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;可以看出，对于Clojure来说，绝大部分的设计模式都不是必须的！很多所谓的设计模式，在Clojure中使用语言特性就可以轻松解决！&lt;/p&gt;

&lt;p&gt;同时可以看出，Java之所以需要设计模式的一个原因就是它的最小单元是类！也同时引起另一个思考，面向对象语言有鼓吹的那么好吗？&lt;/p&gt;

&lt;p&gt;至少目前我的观点是：OO强项在建模，弱项是计算，而计算正是函数式语言的强项！&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-22访问者模式</title>
        <link href="http://ivanpig.github.io/2015/02/24/visitor.html"/>
        <updated>2015-02-24T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/24/visitor</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/visitor.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。&lt;/li&gt;
&lt;li&gt;需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。&lt;/li&gt;
&lt;li&gt;定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//访问者
public interface Visitor {
    public void visit(Park park);
    public void visit(ParkA parkA);
    public void visit(ParkB parkB);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//清洁工A,负责parkA的卫生情况
public class VisitorA implements Visitor {

    public void visit(Park park) {
    }

    public void visit(ParkA parkA) {
        System.out.println(&quot;清洁工A:完成公园&quot; + parkA.getName()+ &quot;的卫生&quot;);
    }

    public void visit(ParkB parkB) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//清洁工B，负责公园B部分的卫生
public class VisitorB implements Visitor {

    public void visit(Park park) {
    }

    public void visit(ParkA parkA) {
    }

    public void visit(ParkB parkB) {
        System.out.println(&quot;清洁工B:完成公园&quot; + parkB.getName()+&quot;的卫生&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class VisitorManager implements Visitor {

    public void visit(Park park) {
        System.out.println(&quot;管理员：负责&quot; + park.getName() + &quot;卫生检查&quot;);
    }

    public void visit(ParkA parkA) {
        System.out.println(&quot;管理员：负责公园&quot;+ parkA.getName() +&quot;部分卫生检查&quot;);
    }

    public void visit(ParkB parkB) {
        System.out.println(&quot;管理员：负责公园&quot;+ parkB.getName() +&quot;分部卫生检查&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//公园每一部分的抽象
public interface ParkElement {
    //用来接纳访问者
    public void accept(Visitor visitor);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Park implements ParkElement {
    private String name;
    private ParkA parkA;
    private ParkB parkB;

    public Park() {
        this.parkA = new ParkA();
        this.parkB = new ParkB();
        parkA.setName(&quot;A&quot;);
        parkB.setName(&quot;B&quot;);
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
        parkA.accept(visitor);
        parkB.accept(visitor);

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//公园的A部分
public class ParkA implements ParkElement {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//公园的B部分
public class ParkB implements ParkElement{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class MainClass {
    public static void main(String[] args) {
        Park park = new Park();
        park.setName(&quot;锦绣公园&quot;);
        VisitorA visitorA = new VisitorA();

        park.accept(visitorA);

        VisitorB visitorB = new VisitorB();
        park.accept(visitorB);

        VisitorManager visitorManager = new VisitorManager();
        park.accept(visitorManager);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;访问者模式干了什么呢？我自己(这里是Park)有个结构，我委托给其他对象(Visitor)来实现访问逻辑!&lt;/p&gt;

&lt;p&gt;Clojure没有类似的结构体！比如复杂的树结构，可以使用Clojure提供的数据操作函数来进行操作即可！没必要实现个模式！&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/visitor.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。&lt;/li&gt;
&lt;li&gt;需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。&lt;/li&gt;
&lt;li&gt;定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//访问者
public interface Visitor {
    public void visit(Park park);
    public void visit(ParkA parkA);
    public void visit(ParkB parkB);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//清洁工A,负责parkA的卫生情况
public class VisitorA implements Visitor {

    public void visit(Park park) {
    }

    public void visit(ParkA parkA) {
        System.out.println(&quot;清洁工A:完成公园&quot; + parkA.getName()+ &quot;的卫生&quot;);
    }

    public void visit(ParkB parkB) {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//清洁工B，负责公园B部分的卫生
public class VisitorB implements Visitor {

    public void visit(Park park) {
    }

    public void visit(ParkA parkA) {
    }

    public void visit(ParkB parkB) {
        System.out.println(&quot;清洁工B:完成公园&quot; + parkB.getName()+&quot;的卫生&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class VisitorManager implements Visitor {

    public void visit(Park park) {
        System.out.println(&quot;管理员：负责&quot; + park.getName() + &quot;卫生检查&quot;);
    }

    public void visit(ParkA parkA) {
        System.out.println(&quot;管理员：负责公园&quot;+ parkA.getName() +&quot;部分卫生检查&quot;);
    }

    public void visit(ParkB parkB) {
        System.out.println(&quot;管理员：负责公园&quot;+ parkB.getName() +&quot;分部卫生检查&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//公园每一部分的抽象
public interface ParkElement {
    //用来接纳访问者
    public void accept(Visitor visitor);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Park implements ParkElement {
    private String name;
    private ParkA parkA;
    private ParkB parkB;

    public Park() {
        this.parkA = new ParkA();
        this.parkB = new ParkB();
        parkA.setName(&quot;A&quot;);
        parkB.setName(&quot;B&quot;);
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
        parkA.accept(visitor);
        parkB.accept(visitor);

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//公园的A部分
public class ParkA implements ParkElement {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//公园的B部分
public class ParkB implements ParkElement{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class MainClass {
    public static void main(String[] args) {
        Park park = new Park();
        park.setName(&quot;锦绣公园&quot;);
        VisitorA visitorA = new VisitorA();

        park.accept(visitorA);

        VisitorB visitorB = new VisitorB();
        park.accept(visitorB);

        VisitorManager visitorManager = new VisitorManager();
        park.accept(visitorManager);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;访问者模式干了什么呢？我自己(这里是Park)有个结构，我委托给其他对象(Visitor)来实现访问逻辑!&lt;/p&gt;

&lt;p&gt;Clojure没有类似的结构体！比如复杂的树结构，可以使用Clojure提供的数据操作函数来进行操作即可！没必要实现个模式！&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-21解释器模式</title>
        <link href="http://ivanpig.github.io/2015/02/23/interpreter.html"/>
        <updated>2015-02-23T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/23/interpreter</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/interpreter.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：&lt;/li&gt;
&lt;li&gt;该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。&lt;/li&gt;
&lt;li&gt;效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;抽象表达式角色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public abstract class Expression {
    /**
     * 以环境为准，本方法解释给定的任何一个表达式
     */
    public abstract boolean interpret(Context ctx);
    /**
     * 检验两个表达式在结构上是否相同
     */
    public abstract boolean equals(Object obj);
    /**
     * 返回表达式的hash code
     */
    public abstract int hashCode();
    /**
     * 将表达式转换成字符串
     */
    public abstract String toString();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;一个Constant对象代表一个布尔常量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Constant extends Expression{

    private boolean value;

    public Constant(boolean value){
        this.value = value;
    }

    @Override
    public boolean equals(Object obj) {

        if(obj != null &amp;amp;&amp;amp; obj instanceof Constant){
            return this.value == ((Constant)obj).value;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return value;
    }

    @Override
    public String toString() {
        return new Boolean(value).toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个Variable对象代表一个有名变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Variable extends Expression {

    private String name;

    public Variable(String name){
        this.name = name;
    }
    @Override
    public boolean equals(Object obj) {

        if(obj != null &amp;amp;&amp;amp; obj instanceof Variable){
            return this.name.equals(
                    ((Variable)obj).name);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean interpret(Context ctx) {
        return ctx.lookup(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表逻辑“与”操作的And类，表示由两个布尔表达式通过逻辑“与”操作给出一个新的布尔表达式的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class And extends Expression {

    private Expression left,right;

    public And(Expression left , Expression right){
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean equals(Object obj) {
        if(obj != null &amp;amp;&amp;amp; obj instanceof And){
            return left.equals(((And)obj).left) &amp;amp;&amp;amp;
                right.equals(((And)obj).right);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return left.interpret(ctx) &amp;amp;&amp;amp; right.interpret(ctx);
    }

    @Override
    public String toString() {
        return &quot;(&quot; + left.toString() + &quot; AND &quot; + right.toString() + &quot;)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表逻辑“或”操作的Or类，代表由两个布尔表达式通过逻辑“或”操作给出一个新的布尔表达式的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Or extends Expression {
    private Expression left,right;

    public Or(Expression left , Expression right){
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean equals(Object obj) {
        if(obj != null &amp;amp;&amp;amp; obj instanceof Or){
            return this.left.equals(((Or)obj).left) &amp;amp;&amp;amp; this.right.equals(((Or)obj).right);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return left.interpret(ctx) || right.interpret(ctx);
    }

    @Override
    public String toString() {
        return &quot;(&quot; + left.toString() + &quot; OR &quot; + right.toString() + &quot;)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表逻辑“非”操作的Not类，代表由一个布尔表达式通过逻辑“非”操作给出一个新的布尔表达式的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Not extends Expression {

    private Expression exp;

    public Not(Expression exp){
        this.exp = exp;
    }
    @Override
    public boolean equals(Object obj) {
        if(obj != null &amp;amp;&amp;amp; obj instanceof Not){
            return exp.equals(
                    ((Not)obj).exp);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return !exp.interpret(ctx);
    }

    @Override
    public String toString() {
        return &quot;(Not &quot; + exp.toString() + &quot;)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;环境(Context)类定义出从变量到布尔值的一个映射&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Context {

    private Map&amp;lt;Variable,Boolean&amp;gt; map = new HashMap&amp;lt;Variable,Boolean&amp;gt;();

    public void assign(Variable var , boolean value){
        map.put(var, new Boolean(value));
    }

    public boolean lookup(Variable var) throws IllegalArgumentException{
        Boolean value = map.get(var);
        if(value == null){
            throw new IllegalArgumentException();
        }
        return value.booleanValue();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        Context ctx = new Context();
        Variable x = new Variable(&quot;x&quot;);
        Variable y = new Variable(&quot;y&quot;);
        Constant c = new Constant(true);
        ctx.assign(x, false);
        ctx.assign(y, true);

        Expression exp = new Or(new And(c,x) , new And(y,new Not(x)));
        System.out.println(&quot;x=&quot; + x.interpret(ctx));
        System.out.println(&quot;y=&quot; + y.interpret(ctx));
        System.out.println(exp.toString() + &quot;=&quot; + exp.interpret(ctx));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;解释器模式其实就是写了个包含上下文的解析器！这可是Clojure的强项!&lt;/p&gt;

&lt;p&gt;先演示不带上下文的解析器！其实就是内部DSL!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defmacro assign [a v]
   `(def ~a ~v))

(assign x false)
(assign y true)
(assign c true)

(assign exp '(or (and c x) (and y (not x))))

(println &quot;x =&quot; x)
(println &quot;y =&quot; y)
(println exp &quot;=&quot; (eval exp))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/designpattern/comp.clj&quot;&gt;这里&lt;/a&gt;是一个较完整的代码!&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/interpreter.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：&lt;/li&gt;
&lt;li&gt;该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。&lt;/li&gt;
&lt;li&gt;效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;抽象表达式角色&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public abstract class Expression {
    /**
     * 以环境为准，本方法解释给定的任何一个表达式
     */
    public abstract boolean interpret(Context ctx);
    /**
     * 检验两个表达式在结构上是否相同
     */
    public abstract boolean equals(Object obj);
    /**
     * 返回表达式的hash code
     */
    public abstract int hashCode();
    /**
     * 将表达式转换成字符串
     */
    public abstract String toString();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;一个Constant对象代表一个布尔常量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Constant extends Expression{

    private boolean value;

    public Constant(boolean value){
        this.value = value;
    }

    @Override
    public boolean equals(Object obj) {

        if(obj != null &amp;amp;&amp;amp; obj instanceof Constant){
            return this.value == ((Constant)obj).value;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return value;
    }

    @Override
    public String toString() {
        return new Boolean(value).toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个Variable对象代表一个有名变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Variable extends Expression {

    private String name;

    public Variable(String name){
        this.name = name;
    }
    @Override
    public boolean equals(Object obj) {

        if(obj != null &amp;amp;&amp;amp; obj instanceof Variable){
            return this.name.equals(
                    ((Variable)obj).name);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean interpret(Context ctx) {
        return ctx.lookup(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表逻辑“与”操作的And类，表示由两个布尔表达式通过逻辑“与”操作给出一个新的布尔表达式的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class And extends Expression {

    private Expression left,right;

    public And(Expression left , Expression right){
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean equals(Object obj) {
        if(obj != null &amp;amp;&amp;amp; obj instanceof And){
            return left.equals(((And)obj).left) &amp;amp;&amp;amp;
                right.equals(((And)obj).right);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return left.interpret(ctx) &amp;amp;&amp;amp; right.interpret(ctx);
    }

    @Override
    public String toString() {
        return &quot;(&quot; + left.toString() + &quot; AND &quot; + right.toString() + &quot;)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表逻辑“或”操作的Or类，代表由两个布尔表达式通过逻辑“或”操作给出一个新的布尔表达式的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Or extends Expression {
    private Expression left,right;

    public Or(Expression left , Expression right){
        this.left = left;
        this.right = right;
    }
    @Override
    public boolean equals(Object obj) {
        if(obj != null &amp;amp;&amp;amp; obj instanceof Or){
            return this.left.equals(((Or)obj).left) &amp;amp;&amp;amp; this.right.equals(((Or)obj).right);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return left.interpret(ctx) || right.interpret(ctx);
    }

    @Override
    public String toString() {
        return &quot;(&quot; + left.toString() + &quot; OR &quot; + right.toString() + &quot;)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代表逻辑“非”操作的Not类，代表由一个布尔表达式通过逻辑“非”操作给出一个新的布尔表达式的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Not extends Expression {

    private Expression exp;

    public Not(Expression exp){
        this.exp = exp;
    }
    @Override
    public boolean equals(Object obj) {
        if(obj != null &amp;amp;&amp;amp; obj instanceof Not){
            return exp.equals(
                    ((Not)obj).exp);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

    @Override
    public boolean interpret(Context ctx) {
        return !exp.interpret(ctx);
    }

    @Override
    public String toString() {
        return &quot;(Not &quot; + exp.toString() + &quot;)&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;环境(Context)类定义出从变量到布尔值的一个映射&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Context {

    private Map&amp;lt;Variable,Boolean&amp;gt; map = new HashMap&amp;lt;Variable,Boolean&amp;gt;();

    public void assign(Variable var , boolean value){
        map.put(var, new Boolean(value));
    }

    public boolean lookup(Variable var) throws IllegalArgumentException{
        Boolean value = map.get(var);
        if(value == null){
            throw new IllegalArgumentException();
        }
        return value.booleanValue();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        Context ctx = new Context();
        Variable x = new Variable(&quot;x&quot;);
        Variable y = new Variable(&quot;y&quot;);
        Constant c = new Constant(true);
        ctx.assign(x, false);
        ctx.assign(y, true);

        Expression exp = new Or(new And(c,x) , new And(y,new Not(x)));
        System.out.println(&quot;x=&quot; + x.interpret(ctx));
        System.out.println(&quot;y=&quot; + y.interpret(ctx));
        System.out.println(exp.toString() + &quot;=&quot; + exp.interpret(ctx));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;解释器模式其实就是写了个包含上下文的解析器！这可是Clojure的强项!&lt;/p&gt;

&lt;p&gt;先演示不带上下文的解析器！其实就是内部DSL!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defmacro assign [a v]
   `(def ~a ~v))

(assign x false)
(assign y true)
(assign c true)

(assign exp '(or (and c x) (and y (not x))))

(println &quot;x =&quot; x)
(println &quot;y =&quot; y)
(println exp &quot;=&quot; (eval exp))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;/assets/designpattern/comp.clj&quot;&gt;这里&lt;/a&gt;是一个较完整的代码!&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-20中介者模式</title>
        <link href="http://ivanpig.github.io/2015/02/22/mediator.html"/>
        <updated>2015-02-22T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/22/mediator</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/mediator.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。&lt;/li&gt;
&lt;li&gt;一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。&lt;/li&gt;
&lt;li&gt;想定制一个分布在多个类中的行为，而又不想生成太多的子类。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//抽象同事类
public abstract class Person {
    // 维持一个抽象中介者的引用
    protected Mediator mediator;

    protected String name;

    public Person(String name, Mediator mediator){
        this.mediator = mediator;
        this.name = name;
    }

    /**
     * 设置中介者对象
     * @param mediator
     */
    public void setMediator(Mediator mediator){
        this.mediator = mediator;
    }

    /**
     * 向中介 发送消息
     */
    protected abstract void sendMessage(String msg);

    /**
     * 从中介 获取消息
     */
    protected abstract void getMessage(String msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //具体同事类：这里的角色是 租房者
public class Renter extends Person {

    public Renter(String name, Mediator mediator) {
        super(name, mediator);
    }

    @Override
    protected void sendMessage(String msg) {
        mediator.operation(this, msg);
    }

    @Override
    protected void getMessage(String msg) {
        System.out.println(&quot;求租者[&quot; + name + &quot;]收到中介发来的消息： &quot; + msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //具体同事类：这里的角色是 房东
public class Landlord extends Person {

    public Landlord(String name, Mediator mediator) {
        super(name,mediator);
    }

    @Override
    protected void sendMessage(String msg) {
        mediator.operation(this, msg);
    }

    @Override
    protected void getMessage(String msg) {
        System.out.println(&quot;房东[&quot;+ name +&quot;]收到中介发来的消息：&quot; + msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //抽象中介者类
public abstract class Mediator {
    // 用于添加储存 &quot;房东&quot;角色
    protected List&amp;lt;Person&amp;gt; landlordList = new ArrayList&amp;lt;Person&amp;gt;();

    // 用于添加储存 &quot;求租者&quot;角色
    protected List&amp;lt;Person&amp;gt; renterList = new ArrayList&amp;lt;Person&amp;gt;();

    /**
     * 中介者注册房东信息
     * @param landlord 房东实体
     */
    public void registerLandlord(Person landlord){
        landlordList.add(landlord);
    }

    /**
     * 中介者注册 求租者信息
     * @param landlord 房东实体
     */
    public void registerRenter(Person landlord){
        renterList.add(landlord);
    }

    /**
     * 声明抽象方法 由具体中介者子类实现 消息的中转和协调
     */
    public abstract void operation(Person person, String message);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //具体中介者类：这里的角色是 房屋出租中介
public class HouseMediator extends Mediator {

    @Override
    public void operation(Person person, String message) {
        if(person instanceof Renter){
            // 将租屋的需求消息传递给 注册了的房东们
            for(Person landlord: landlordList){
                landlord.getMessage(message);
            }
        } else if(person instanceof Landlord){
            // 将房东的出租房消息传递给 注册了的 房屋求租者们
            for(Person renter : renterList){
                renter.getMessage(message);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//客户端测试类
public class Client {

    public static void main(String[] args) {
        // 实例化房屋中介
        Mediator mediator = new HouseMediator();

        Person landlordA, landlordB, renter;
        landlordA = new Landlord(&quot;房东李&quot;, mediator);
        landlordB = new Landlord(&quot;房东黎&quot;, mediator);

        renter = new Renter(&quot;小吕&quot;,mediator);

        // 房东注册中介
        mediator.registerLandlord(landlordA);
        mediator.registerLandlord(landlordB);
        // 求租者注册中介
        mediator.registerRenter(renter);

        // 求租者 发送求租消息
        renter.sendMessage(&quot;在天河公园附近租套房子，价格1000元左右一个月&quot;);
        System.out.println(&quot;--------------------------&quot;);
        // 房东A 发送房屋出租消息
        landlordA.sendMessage(&quot;天河公园学院站三巷27号四楼有一房一厅出租  1200/月  光线好 近公交站&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;中介者模式类似双向的观察者模式！&lt;/p&gt;

&lt;p&gt;观察者模式是单向的，从Subject向多个Observer传递信息！&lt;/p&gt;

&lt;p&gt;中介者模式相当与ObserverA向Subject传递信息，再通过Subject传递给ObserverB,反之亦然!&lt;/p&gt;

&lt;p&gt;那么就可以通过实现两个add-watch来实现类似中介者模式!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def a (atom {}))
(def b (atom {}))

(defn func-a []
   (println &quot;func-a invoke&quot;))

(defn func-b []
  (println &quot;func-b invoke&quot;))

(add-watch a :watcherA
           (fn [key atom old-state new-state]
             (func-a)))

(add-watch b :watcherB
           (fn [key atom old-state new-state]
             (func-b)))

(reset! a {:foo &quot;bar&quot;})
(reset! b {:foo &quot;bar&quot;})
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/mediator.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。&lt;/li&gt;
&lt;li&gt;一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。&lt;/li&gt;
&lt;li&gt;想定制一个分布在多个类中的行为，而又不想生成太多的子类。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//抽象同事类
public abstract class Person {
    // 维持一个抽象中介者的引用
    protected Mediator mediator;

    protected String name;

    public Person(String name, Mediator mediator){
        this.mediator = mediator;
        this.name = name;
    }

    /**
     * 设置中介者对象
     * @param mediator
     */
    public void setMediator(Mediator mediator){
        this.mediator = mediator;
    }

    /**
     * 向中介 发送消息
     */
    protected abstract void sendMessage(String msg);

    /**
     * 从中介 获取消息
     */
    protected abstract void getMessage(String msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //具体同事类：这里的角色是 租房者
public class Renter extends Person {

    public Renter(String name, Mediator mediator) {
        super(name, mediator);
    }

    @Override
    protected void sendMessage(String msg) {
        mediator.operation(this, msg);
    }

    @Override
    protected void getMessage(String msg) {
        System.out.println(&quot;求租者[&quot; + name + &quot;]收到中介发来的消息： &quot; + msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //具体同事类：这里的角色是 房东
public class Landlord extends Person {

    public Landlord(String name, Mediator mediator) {
        super(name,mediator);
    }

    @Override
    protected void sendMessage(String msg) {
        mediator.operation(this, msg);
    }

    @Override
    protected void getMessage(String msg) {
        System.out.println(&quot;房东[&quot;+ name +&quot;]收到中介发来的消息：&quot; + msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //抽象中介者类
public abstract class Mediator {
    // 用于添加储存 &quot;房东&quot;角色
    protected List&amp;lt;Person&amp;gt; landlordList = new ArrayList&amp;lt;Person&amp;gt;();

    // 用于添加储存 &quot;求租者&quot;角色
    protected List&amp;lt;Person&amp;gt; renterList = new ArrayList&amp;lt;Person&amp;gt;();

    /**
     * 中介者注册房东信息
     * @param landlord 房东实体
     */
    public void registerLandlord(Person landlord){
        landlordList.add(landlord);
    }

    /**
     * 中介者注册 求租者信息
     * @param landlord 房东实体
     */
    public void registerRenter(Person landlord){
        renterList.add(landlord);
    }

    /**
     * 声明抽象方法 由具体中介者子类实现 消息的中转和协调
     */
    public abstract void operation(Person person, String message);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt; //具体中介者类：这里的角色是 房屋出租中介
public class HouseMediator extends Mediator {

    @Override
    public void operation(Person person, String message) {
        if(person instanceof Renter){
            // 将租屋的需求消息传递给 注册了的房东们
            for(Person landlord: landlordList){
                landlord.getMessage(message);
            }
        } else if(person instanceof Landlord){
            // 将房东的出租房消息传递给 注册了的 房屋求租者们
            for(Person renter : renterList){
                renter.getMessage(message);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//客户端测试类
public class Client {

    public static void main(String[] args) {
        // 实例化房屋中介
        Mediator mediator = new HouseMediator();

        Person landlordA, landlordB, renter;
        landlordA = new Landlord(&quot;房东李&quot;, mediator);
        landlordB = new Landlord(&quot;房东黎&quot;, mediator);

        renter = new Renter(&quot;小吕&quot;,mediator);

        // 房东注册中介
        mediator.registerLandlord(landlordA);
        mediator.registerLandlord(landlordB);
        // 求租者注册中介
        mediator.registerRenter(renter);

        // 求租者 发送求租消息
        renter.sendMessage(&quot;在天河公园附近租套房子，价格1000元左右一个月&quot;);
        System.out.println(&quot;--------------------------&quot;);
        // 房东A 发送房屋出租消息
        landlordA.sendMessage(&quot;天河公园学院站三巷27号四楼有一房一厅出租  1200/月  光线好 近公交站&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;中介者模式类似双向的观察者模式！&lt;/p&gt;

&lt;p&gt;观察者模式是单向的，从Subject向多个Observer传递信息！&lt;/p&gt;

&lt;p&gt;中介者模式相当与ObserverA向Subject传递信息，再通过Subject传递给ObserverB,反之亦然!&lt;/p&gt;

&lt;p&gt;那么就可以通过实现两个add-watch来实现类似中介者模式!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def a (atom {}))
(def b (atom {}))

(defn func-a []
   (println &quot;func-a invoke&quot;))

(defn func-b []
  (println &quot;func-b invoke&quot;))

(add-watch a :watcherA
           (fn [key atom old-state new-state]
             (func-a)))

(add-watch b :watcherB
           (fn [key atom old-state new-state]
             (func-b)))

(reset! a {:foo &quot;bar&quot;})
(reset! b {:foo &quot;bar&quot;})
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-19策略模式</title>
        <link href="http://ivanpig.github.io/2015/02/21/strategy.html"/>
        <updated>2015-02-21T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/21/strategy</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/strategy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。&lt;/li&gt;
&lt;li&gt;需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。&lt;/li&gt;
&lt;li&gt;算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。&lt;/li&gt;
&lt;li&gt;一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Context {
    //持有一个具体策略的对象
    private Strategy strategy;
    /**
     * 构造函数，传入一个具体策略对象
     * @param strategy    具体策略对象
     */
    public Context(Strategy strategy){
        this.strategy = strategy;
    }
    /**
     * 策略方法
     */
    public void contextInterface(){
        strategy.strategyInterface();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Strategy {
    /**
     * 策略方法
     */
    public void strategyInterface();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteStrategyA implements Strategy {

    @Override
    public void strategyInterface() {
        //相关的业务
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteStrategyB implements Strategy {

    @Override
    public void strategyInterface() {
        //相关的业务
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteStrategyC implements Strategy {

    @Override
    public void strategyInterface() {
        //相关的业务
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;高阶函数轻松搞定!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn context [f]
   (f))

(defn strategy1 []
  (println &quot;Strategy1&quot;))

(defn strategy2 []
  (println &quot;Strategy2&quot;))

(context strategy1)
(context strategy2)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/strategy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。&lt;/li&gt;
&lt;li&gt;需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。&lt;/li&gt;
&lt;li&gt;算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。&lt;/li&gt;
&lt;li&gt;一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Context {
    //持有一个具体策略的对象
    private Strategy strategy;
    /**
     * 构造函数，传入一个具体策略对象
     * @param strategy    具体策略对象
     */
    public Context(Strategy strategy){
        this.strategy = strategy;
    }
    /**
     * 策略方法
     */
    public void contextInterface(){
        strategy.strategyInterface();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Strategy {
    /**
     * 策略方法
     */
    public void strategyInterface();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteStrategyA implements Strategy {

    @Override
    public void strategyInterface() {
        //相关的业务
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteStrategyB implements Strategy {

    @Override
    public void strategyInterface() {
        //相关的业务
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteStrategyC implements Strategy {

    @Override
    public void strategyInterface() {
        //相关的业务
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;高阶函数轻松搞定!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn context [f]
   (f))

(defn strategy1 []
  (println &quot;Strategy1&quot;))

(defn strategy2 []
  (println &quot;Strategy2&quot;))

(context strategy1)
(context strategy2)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-18状态模式</title>
        <link href="http://ivanpig.github.io/2015/02/20/state.html"/>
        <updated>2015-02-20T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/20/state</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/state.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。&lt;/li&gt;
&lt;li&gt;一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Order{
     private State unPayState;
     private State payedState;
     private State sendState;
     private State doneState;    //四种状态，四种类,对应的get,set方法省略

     private State state = unPayState;     //当前状态

     public Order(){
        unPayState = new UnPayState(this);
        payedState = new PayedState(this);            //传入Order对象，为了修改Order的状态
        ...
     }

     public void pay(){
          state.pay();
     }

     public void send(){
          state.send();
     }

     ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//State接口
public interface State{
     public void pay();
     public void send();
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//UnPayState
public class UnPayState implements State{

     private Order order;
     public UnPayState(Order order){
           this.order = order;
     }

     public void pay(){
         //pay money
         order.setState(order.getPayedState());
     }

     public void send(){
         //exception: can't send
     }
     .....
}

//其他实现略
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure模拟实现！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def order (atom {:status :unPay}))

(defmulti invoke (fn [ord] (:status @ord)))

(defmethod invoke
  :unPay
  [ord]
  (println &quot;UnPay&quot;)
  (swap! order assoc :status :send))

(defmethod invoke
  :send
  [ord]
  (println &quot;Send&quot;)
  (swap! order assoc :status :unPay))

(invoke order)
(invoke order)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/state.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。&lt;/li&gt;
&lt;li&gt;一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Order{
     private State unPayState;
     private State payedState;
     private State sendState;
     private State doneState;    //四种状态，四种类,对应的get,set方法省略

     private State state = unPayState;     //当前状态

     public Order(){
        unPayState = new UnPayState(this);
        payedState = new PayedState(this);            //传入Order对象，为了修改Order的状态
        ...
     }

     public void pay(){
          state.pay();
     }

     public void send(){
          state.send();
     }

     ....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//State接口
public interface State{
     public void pay();
     public void send();
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//UnPayState
public class UnPayState implements State{

     private Order order;
     public UnPayState(Order order){
           this.order = order;
     }

     public void pay(){
         //pay money
         order.setState(order.getPayedState());
     }

     public void send(){
         //exception: can't send
     }
     .....
}

//其他实现略
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure模拟实现！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def order (atom {:status :unPay}))

(defmulti invoke (fn [ord] (:status @ord)))

(defmethod invoke
  :unPay
  [ord]
  (println &quot;UnPay&quot;)
  (swap! order assoc :status :send))

(defmethod invoke
  :send
  [ord]
  (println &quot;Send&quot;)
  (swap! order assoc :status :unPay))

(invoke order)
(invoke order)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-17命令模式</title>
        <link href="http://ivanpig.github.io/2015/02/19/command.html"/>
        <updated>2015-02-19T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/19/command</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/command.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;像上面讨论的MenuItem对象那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调（callback）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。&lt;/li&gt;
&lt;li&gt;在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。&lt;/li&gt;
&lt;li&gt;支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Execute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。&lt;/li&gt;
&lt;li&gt;支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。&lt;/li&gt;
&lt;li&gt;用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;接收者角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Receiver {
    /**
     * 真正执行命令相应的操作
     */
    public void action(){
        System.out.println(&quot;执行操作&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽象命令角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Command {
    /**
     * 执行方法
     */
    void execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;具体命令角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteCommand implements Command {
    //持有相应的接收者对象
    private Receiver receiver = null;
    /**
     * 构造方法
     */
    public ConcreteCommand(Receiver receiver){
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        //通常会转调接收者对象的相应方法，让接收者来真正执行功能
        receiver.action();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求者角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Invoker {
    /**
     * 持有命令对象
     */
    private Command command = null;
    /**
     * 构造方法
     */
    public Invoker(Command command){
        this.command = command;
    }
    /**
     * 行动方法
     */
    public void action(){
        command.execute();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        //创建接收者
        Receiver receiver = new Receiver();
        //创建命令对象，设定它的接收者
        Command command = new ConcreteCommand(receiver);
        //创建请求者，把命令对象设置进去
        Invoker invoker = new Invoker(command);
        //执行方法
        invoker.action();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;还是first-class function!!!&lt;/p&gt;

&lt;p&gt;代码可以直接参考&lt;a href=&quot;/2015/02/13/bridge.html#top3&quot;&gt;桥接模式&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/command.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;像上面讨论的MenuItem对象那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调（callback）函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。&lt;/li&gt;
&lt;li&gt;在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。&lt;/li&gt;
&lt;li&gt;支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Execute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。&lt;/li&gt;
&lt;li&gt;支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。&lt;/li&gt;
&lt;li&gt;用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;接收者角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Receiver {
    /**
     * 真正执行命令相应的操作
     */
    public void action(){
        System.out.println(&quot;执行操作&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽象命令角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Command {
    /**
     * 执行方法
     */
    void execute();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;具体命令角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteCommand implements Command {
    //持有相应的接收者对象
    private Receiver receiver = null;
    /**
     * 构造方法
     */
    public ConcreteCommand(Receiver receiver){
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        //通常会转调接收者对象的相应方法，让接收者来真正执行功能
        receiver.action();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求者角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Invoker {
    /**
     * 持有命令对象
     */
    private Command command = null;
    /**
     * 构造方法
     */
    public Invoker(Command command){
        this.command = command;
    }
    /**
     * 行动方法
     */
    public void action(){
        command.execute();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户端角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        //创建接收者
        Receiver receiver = new Receiver();
        //创建命令对象，设定它的接收者
        Command command = new ConcreteCommand(receiver);
        //创建请求者，把命令对象设置进去
        Invoker invoker = new Invoker(command);
        //执行方法
        invoker.action();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;还是first-class function!!!&lt;/p&gt;

&lt;p&gt;代码可以直接参考&lt;a href=&quot;/2015/02/13/bridge.html#top3&quot;&gt;桥接模式&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-16责任链模式</title>
        <link href="http://ivanpig.github.io/2015/02/18/chain_of_responsibility.html"/>
        <updated>2015-02-18T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/18/chain_of_responsibility</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/chain.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。&lt;/li&gt;
&lt;li&gt;你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/li&gt;
&lt;li&gt;可处理一个请求的对象集合应被动态指定。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public abstract class Handler {

    protected Handler successor;

    public abstract void handlerRequest(String condition);


    public Handler getSuccessor() {
        return successor;
    }
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteHandler1 extends Handler {

    @Override
    public void handlerRequest(String condition) {
        // 如果是自己的责任，就自己处理，负责传给下家处理
        if(condition.equals(&quot;ConcreteHandler1&quot;)){
            System.out.println( &quot;ConcreteHandler1 handled &quot;);
            return ;
        }else{
            System.out.println( &quot;ConcreteHandler1 passed &quot;);
            getSuccessor().handlerRequest(condition);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteHandler2 extends Handler {

    @Override
    public void handlerRequest(String condition) {
        // 如果是自己的责任，就自己处理，负责传给下家处理
        if(condition.equals(&quot;ConcreteHandler2&quot;)){
            System.out.println( &quot;ConcreteHandler2 handled &quot;);
            return ;
        }else{
            System.out.println( &quot;ConcreteHandler2 passed &quot;);
            getSuccessor().handlerRequest(condition);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteHandlerN extends Handler {

    /**
     * 这里假设n是链的最后一个节点必须处理掉
     * 在实际情况下，可能出现环，或者是树形，
     * 这里并不一定是最后一个节点。
     */
    @Override
    public void handlerRequest(String condition) {
        System.out.println( &quot;ConcreteHandlerN handled&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {

        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        Handler handlern = new ConcreteHandlerN();

        //链起来
        handler1.setSuccessor(handler2);
        handler2.setSuccessor(handlern);

        //假设这个请求是ConcreteHandler2的责任
        handler1.handlerRequest(&quot;ConcreteHandler2&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;
(defn handler-request1 [condition]
  (if (= &quot;ConcreteHandler1&quot; condition)
    (println &quot;ConcreteHandler1 handled &quot;)
    (println &quot;ConcreteHandler1 passed &quot;)))

(defn handler-request2 [condition]
  (if (= &quot;ConcreteHandler2&quot; condition)
    (println &quot;ConcreteHandler2 handled &quot;)
    (println &quot;ConcreteHandler2 passed &quot;)))

(defn handler-requestn [condition]
  (println &quot;ConcreteHandlern handled &quot;))

(-&amp;gt;&amp;gt; &quot;ConcreteHandler2&quot;
    handler-request1
    handler-request2
    handler-requestn)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/chain.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。&lt;/li&gt;
&lt;li&gt;你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。&lt;/li&gt;
&lt;li&gt;可处理一个请求的对象集合应被动态指定。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public abstract class Handler {

    protected Handler successor;

    public abstract void handlerRequest(String condition);


    public Handler getSuccessor() {
        return successor;
    }
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteHandler1 extends Handler {

    @Override
    public void handlerRequest(String condition) {
        // 如果是自己的责任，就自己处理，负责传给下家处理
        if(condition.equals(&quot;ConcreteHandler1&quot;)){
            System.out.println( &quot;ConcreteHandler1 handled &quot;);
            return ;
        }else{
            System.out.println( &quot;ConcreteHandler1 passed &quot;);
            getSuccessor().handlerRequest(condition);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteHandler2 extends Handler {

    @Override
    public void handlerRequest(String condition) {
        // 如果是自己的责任，就自己处理，负责传给下家处理
        if(condition.equals(&quot;ConcreteHandler2&quot;)){
            System.out.println( &quot;ConcreteHandler2 handled &quot;);
            return ;
        }else{
            System.out.println( &quot;ConcreteHandler2 passed &quot;);
            getSuccessor().handlerRequest(condition);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteHandlerN extends Handler {

    /**
     * 这里假设n是链的最后一个节点必须处理掉
     * 在实际情况下，可能出现环，或者是树形，
     * 这里并不一定是最后一个节点。
     */
    @Override
    public void handlerRequest(String condition) {
        System.out.println( &quot;ConcreteHandlerN handled&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {

        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        Handler handlern = new ConcreteHandlerN();

        //链起来
        handler1.setSuccessor(handler2);
        handler2.setSuccessor(handlern);

        //假设这个请求是ConcreteHandler2的责任
        handler1.handlerRequest(&quot;ConcreteHandler2&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;
(defn handler-request1 [condition]
  (if (= &quot;ConcreteHandler1&quot; condition)
    (println &quot;ConcreteHandler1 handled &quot;)
    (println &quot;ConcreteHandler1 passed &quot;)))

(defn handler-request2 [condition]
  (if (= &quot;ConcreteHandler2&quot; condition)
    (println &quot;ConcreteHandler2 handled &quot;)
    (println &quot;ConcreteHandler2 passed &quot;)))

(defn handler-requestn [condition]
  (println &quot;ConcreteHandlern handled &quot;))

(-&amp;gt;&amp;gt; &quot;ConcreteHandler2&quot;
    handler-request1
    handler-request2
    handler-requestn)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-15观察者模式</title>
        <link href="http://ivanpig.github.io/2015/02/17/observer.html"/>
        <updated>2015-02-17T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/17/observer</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/observer.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。&lt;/li&gt;
&lt;li&gt;当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。&lt;/li&gt;
&lt;li&gt;当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public abstract class Subject {
    /**
     * 用来保存注册的观察者对象
     */
    private    List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
    /**
     * 注册观察者对象
     * @param observer    观察者对象
     */
    public void attach(Observer observer){

        list.add(observer);
        System.out.println(&quot;Attached an observer&quot;);
    }
    /**
     * 删除观察者对象
     * @param observer    观察者对象
     */
    public void detach(Observer observer){

        list.remove(observer);
    }
    /**
     * 通知所有注册的观察者对象
     */
    public void nodifyObservers(String newState){

        for(Observer observer : list){
            observer.update(newState);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteSubject extends Subject{

    private String state;

    public String getState() {
        return state;
    }

    public void change(String newState){
        state = newState;
        System.out.println(&quot;主题状态为：&quot; + state);
        //状态发生改变，通知各个观察者
        this.nodifyObservers(state);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Observer {
    /**
     * 更新接口
     * @param state    更新的状态
     */
    public void update(String state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteObserver implements Observer {
    //观察者的状态
    private String observerState;

    @Override
    public void update(String state) {
        /**
         * 更新观察者的状态，使其与目标的状态保持一致
         */
        observerState = state;
        System.out.println(&quot;状态为：&quot;+observerState);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        //创建主题对象
        ConcreteSubject subject = new ConcreteSubject();
        //创建观察者对象
        Observer observer = new ConcreteObserver();
        //将观察者对象登记到主题对象上
        subject.attach(observer);
        //改变主题对象的状态
        subject.change(&quot;new state&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure有add-watch函数可实现此模式.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def a (atom {}))

(defn func-a []
   (println &quot;func-a invoke&quot;))

(defn func-b []
  (println &quot;func-b invoke&quot;))

(add-watch a :watcherA
           (fn [key atom old-state new-state]
             (func-a)))

(add-watch a :watcherB
           (fn [key atom old-state new-state]
             (func-b)))

(reset! a {:foo &quot;bar&quot;})
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/observer.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。&lt;/li&gt;
&lt;li&gt;当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。&lt;/li&gt;
&lt;li&gt;当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public abstract class Subject {
    /**
     * 用来保存注册的观察者对象
     */
    private    List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
    /**
     * 注册观察者对象
     * @param observer    观察者对象
     */
    public void attach(Observer observer){

        list.add(observer);
        System.out.println(&quot;Attached an observer&quot;);
    }
    /**
     * 删除观察者对象
     * @param observer    观察者对象
     */
    public void detach(Observer observer){

        list.remove(observer);
    }
    /**
     * 通知所有注册的观察者对象
     */
    public void nodifyObservers(String newState){

        for(Observer observer : list){
            observer.update(newState);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteSubject extends Subject{

    private String state;

    public String getState() {
        return state;
    }

    public void change(String newState){
        state = newState;
        System.out.println(&quot;主题状态为：&quot; + state);
        //状态发生改变，通知各个观察者
        this.nodifyObservers(state);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Observer {
    /**
     * 更新接口
     * @param state    更新的状态
     */
    public void update(String state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteObserver implements Observer {
    //观察者的状态
    private String observerState;

    @Override
    public void update(String state) {
        /**
         * 更新观察者的状态，使其与目标的状态保持一致
         */
        observerState = state;
        System.out.println(&quot;状态为：&quot;+observerState);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        //创建主题对象
        ConcreteSubject subject = new ConcreteSubject();
        //创建观察者对象
        Observer observer = new ConcreteObserver();
        //将观察者对象登记到主题对象上
        subject.attach(observer);
        //改变主题对象的状态
        subject.change(&quot;new state&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure有add-watch函数可实现此模式.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def a (atom {}))

(defn func-a []
   (println &quot;func-a invoke&quot;))

(defn func-b []
  (println &quot;func-b invoke&quot;))

(add-watch a :watcherA
           (fn [key atom old-state new-state]
             (func-a)))

(add-watch a :watcherB
           (fn [key atom old-state new-state]
             (func-b)))

(reset! a {:foo &quot;bar&quot;})
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-14备忘录模式</title>
        <link href="http://ivanpig.github.io/2015/02/16/memento.html"/>
        <updated>2015-02-16T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/16/memento</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/memento.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。&lt;/li&gt;
&lt;li&gt;如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Memento {

    private String state;

    public Memento(String state){
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Originator {

    private String state;

    public Memento createMemento(){
        return new Memento(state);
    }

    public void restoreMemento(Memento memento){
        this.state = memento.getState();
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Caretaker {

    private Memento memento;

    public Memento retrieveMemento(){
        return memento;
    }

    public void saveMemento(Memento memento){
        this.memento = memento;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    private static Originator o = new Originator();
    private static Caretaker c = new Caretaker();

    public static void main(String[] args) {
        //改变发起人的状态
        o.setState(&quot;on&quot;);
        //创建备忘录对象，并保持于管理保持
        c.saveMemento(o.createMemento());
        //改变发起人的状态
        o.setState(&quot;off&quot;);
        //还原状态
        o.restoreMemento(c.retrieveMemento());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure没有对象的概念，直接对数据进行操作！&lt;/p&gt;

&lt;p&gt;想想如何保存数据到文件，或从文件恢复数据！需要模式吗？&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/memento.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。&lt;/li&gt;
&lt;li&gt;如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Memento {

    private String state;

    public Memento(String state){
        this.state = state;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Originator {

    private String state;

    public Memento createMemento(){
        return new Memento(state);
    }

    public void restoreMemento(Memento memento){
        this.state = memento.getState();
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Caretaker {

    private Memento memento;

    public Memento retrieveMemento(){
        return memento;
    }

    public void saveMemento(Memento memento){
        this.memento = memento;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    private static Originator o = new Originator();
    private static Caretaker c = new Caretaker();

    public static void main(String[] args) {
        //改变发起人的状态
        o.setState(&quot;on&quot;);
        //创建备忘录对象，并保持于管理保持
        c.saveMemento(o.createMemento());
        //改变发起人的状态
        o.setState(&quot;off&quot;);
        //还原状态
        o.restoreMemento(c.retrieveMemento());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure没有对象的概念，直接对数据进行操作！&lt;/p&gt;

&lt;p&gt;想想如何保存数据到文件，或从文件恢复数据！需要模式吗？&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-13模板模式</title>
        <link href="http://ivanpig.github.io/2015/02/15/template.html"/>
        <updated>2015-02-15T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/15/template</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/template.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。&lt;/li&gt;
&lt;li&gt;各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。&lt;/li&gt;
&lt;li&gt;控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;web开发中使用的布局就是模板模式的典型应用！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public abstract class Layout{

     public void show(){
          System.out.println(&quot;Header&quot;);
          body();
          System.out.println(&quot;Footer&quot;);
     }

     public abstract void body();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Index extends Layout{

     public void body(){
       System.out.println(&quot;Index&quot;);
     }
}

public class Detail extends Layout{

     public void body(){
       System.out.println(&quot;Detail&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Layout layout = new Index();
layout.show();
layout = new Detail();
layout.show();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;直接上代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn show [body]
  (println &quot;Header&quot;)
  (body)
  (println &quot;Footer&quot;))

(defn index []
  (println &quot;Index&quot;))

(defn detail []
  (println &quot;Detail&quot;))

(show index)
(show detail)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/template.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。&lt;/li&gt;
&lt;li&gt;各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。&lt;/li&gt;
&lt;li&gt;控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;web开发中使用的布局就是模板模式的典型应用！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public abstract class Layout{

     public void show(){
          System.out.println(&quot;Header&quot;);
          body();
          System.out.println(&quot;Footer&quot;);
     }

     public abstract void body();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Index extends Layout{

     public void body(){
       System.out.println(&quot;Index&quot;);
     }
}

public class Detail extends Layout{

     public void body(){
       System.out.println(&quot;Detail&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Layout layout = new Index();
layout.show();
layout = new Detail();
layout.show();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;直接上代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn show [body]
  (println &quot;Header&quot;)
  (body)
  (println &quot;Footer&quot;))

(defn index []
  (println &quot;Index&quot;))

(defn detail []
  (println &quot;Detail&quot;))

(show index)
(show detail)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-12享元模式</title>
        <link href="http://ivanpig.github.io/2015/02/14/flyweight.html"/>
        <updated>2015-02-14T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/14/flyweight</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;运用共享技术有效地支持大量细粒度的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/flyweight.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个应用程序使用了大量的对象。&lt;/li&gt;
&lt;li&gt;完全由于使用大量的对象，造成很大的存储开销。&lt;/li&gt;
&lt;li&gt;对象的大多数状态都可变为外部状态。&lt;/li&gt;
&lt;li&gt;如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。&lt;/li&gt;
&lt;li&gt;应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;抽象享元角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Flyweight {
    //一个示意性方法，参数state是外蕴状态
    public void operation(String state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteFlyweight implements Flyweight {
    private Character intrinsicState = null;
    /**
     * 构造函数，内蕴状态作为参数传入
     * @param state
     */
    public ConcreteFlyweight(Character state){
        this.intrinsicState = state;
    }


    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，
     * 但是并不改变对象的内蕴状态。
     */
    @Override
    public void operation(String state) {
        // TODO Auto-generated method stub
        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);
        System.out.println(&quot;Extrinsic State = &quot; + state);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class FlyweightFactory {
    private Map&amp;lt;Character,Flyweight&amp;gt; files = new HashMap&amp;lt;Character,Flyweight&amp;gt;();

    public Flyweight factory(Character state){
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if(fly == null){
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight fly = factory.factory(new Character('a'));
        fly.operation(&quot;First Call&quot;);

        fly = factory.factory(new Character('b'));
        fly.operation(&quot;Second Call&quot;);

        fly = factory.factory(new Character('a'));
        fly.operation(&quot;Third Call&quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure就不需要这种模式！其所有数据都是唯一的！&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;运用共享技术有效地支持大量细粒度的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/flyweight.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个应用程序使用了大量的对象。&lt;/li&gt;
&lt;li&gt;完全由于使用大量的对象，造成很大的存储开销。&lt;/li&gt;
&lt;li&gt;对象的大多数状态都可变为外部状态。&lt;/li&gt;
&lt;li&gt;如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。&lt;/li&gt;
&lt;li&gt;应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;抽象享元角色类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public interface Flyweight {
    //一个示意性方法，参数state是外蕴状态
    public void operation(String state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class ConcreteFlyweight implements Flyweight {
    private Character intrinsicState = null;
    /**
     * 构造函数，内蕴状态作为参数传入
     * @param state
     */
    public ConcreteFlyweight(Character state){
        this.intrinsicState = state;
    }


    /**
     * 外蕴状态作为参数传入方法中，改变方法的行为，
     * 但是并不改变对象的内蕴状态。
     */
    @Override
    public void operation(String state) {
        // TODO Auto-generated method stub
        System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState);
        System.out.println(&quot;Extrinsic State = &quot; + state);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class FlyweightFactory {
    private Map&amp;lt;Character,Flyweight&amp;gt; files = new HashMap&amp;lt;Character,Flyweight&amp;gt;();

    public Flyweight factory(Character state){
        //先从缓存中查找对象
        Flyweight fly = files.get(state);
        if(fly == null){
            //如果对象不存在则创建一个新的Flyweight对象
            fly = new ConcreteFlyweight(state);
            //把这个新的Flyweight对象添加到缓存中
            files.put(state, fly);
        }
        return fly;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Client {

    public static void main(String[] args) {
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight fly = factory.factory(new Character('a'));
        fly.operation(&quot;First Call&quot;);

        fly = factory.factory(new Character('b'));
        fly.operation(&quot;Second Call&quot;);

        fly = factory.factory(new Character('a'));
        fly.operation(&quot;Third Call&quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;Clojure就不需要这种模式！其所有数据都是唯一的！&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-11桥接模式</title>
        <link href="http://ivanpig.github.io/2015/02/13/bridge.html"/>
        <updated>2015-02-13T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/13/bridge</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/bridge.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。&lt;/li&gt;
&lt;li&gt;类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。&lt;/li&gt;
&lt;li&gt;对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。&lt;/li&gt;
&lt;li&gt;（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。&lt;/li&gt;
&lt;li&gt;有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”（nested generalizations ）。&lt;/li&gt;
&lt;li&gt;你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类中多个对象可以共享同一个字符串表示（StringRep）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//电视机的接口
public interface ITV {
    public void on();
    public void off();
    public void switchChannel(int channel);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//三星的ITV
public class SamsungTV implements ITV {
    @Override
    public void on() {
        System.out.println(&quot;Samsung is turned on.&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;Samsung is turned off.&quot;);
    }

    @Override
    public void switchChannel(int channel) {
        System.out.println(&quot;Samsung: channel - &quot; + channel);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//索尼的ITV
public class SonyTV implements ITV {

    @Override
    public void on() {
        System.out.println(&quot;Sony is turned on.&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;Sony is turned off.&quot;);
    }

    @Override
    public void switchChannel(int channel) {
        System.out.println(&quot;Sony: channel - &quot; + channel);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//遥控器要包含对TV的引用
public abstract class AbstractRemoteControl {

    private ITV tv;

    public AbstractRemoteControl(ITV tv){
        this.tv = tv;
    }

    public void turnOn(){
        tv.on();
    }

    public void turnOff(){
        tv.off();
    }

    public void setChannel(int channel){
        tv.switchChannel(channel);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//定义遥控器的具体类
public class LogitechRemoteControl extends AbstractRemoteControl {

    public LogitechRemoteControl(ITV tv) {
        super(tv);
    }

    public void setChannelKeyboard(int channel){
        setChannel(channel);
        System.out.println(&quot;Logitech use keyword to set channel.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//调用
public class Main {
    public static void main(String[] args){
        ITV tv = new SonyTV();
        LogitechRemoteControl lrc = new LogitechRemoteControl(tv);
        lrc.setChannelKeyboard(100);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;first-class function轻松解决！&lt;/p&gt;

&lt;p&gt;三星命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns samsung)

(defn on []
  (println &quot;Samsung is turned on.&quot;))

(defn off []
  (println &quot;Samsung is turned off.&quot;))

(defn switch-channel [channel]
  (println &quot;Samsung: channel - &quot; + channel))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;索尼命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns sony)

(defn on []
  (println &quot;Sony is turned on.&quot;))

(defn off []
  (println &quot;Sony is turned off.&quot;))

(defn switch-channel [channel]
  (println &quot;Sony: channel - &quot; + channel))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RemoteController:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns remotecontroller)

(defn turn-on [f]
   (f))

(defn turn-off [f]
   (f))

(defn set-channel [f arg]
   (f arg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns client
  (:require [sony :as tv]
            [remotecontroller :as c]))

(c/turn-on tv/on)
(c/set-channel tv/switch-channel 3)
(c/trun-off tv/off)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么实现简直就是脱裤子放屁～～！&lt;/p&gt;

&lt;p&gt;直接调用sony或samsung里的函数就行了！多此一举！&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/bridge.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。&lt;/li&gt;
&lt;li&gt;类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。&lt;/li&gt;
&lt;li&gt;对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。&lt;/li&gt;
&lt;li&gt;（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。&lt;/li&gt;
&lt;li&gt;有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”（nested generalizations ）。&lt;/li&gt;
&lt;li&gt;你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类中多个对象可以共享同一个字符串表示（StringRep）。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//电视机的接口
public interface ITV {
    public void on();
    public void off();
    public void switchChannel(int channel);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//三星的ITV
public class SamsungTV implements ITV {
    @Override
    public void on() {
        System.out.println(&quot;Samsung is turned on.&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;Samsung is turned off.&quot;);
    }

    @Override
    public void switchChannel(int channel) {
        System.out.println(&quot;Samsung: channel - &quot; + channel);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//索尼的ITV
public class SonyTV implements ITV {

    @Override
    public void on() {
        System.out.println(&quot;Sony is turned on.&quot;);
    }

    @Override
    public void off() {
        System.out.println(&quot;Sony is turned off.&quot;);
    }

    @Override
    public void switchChannel(int channel) {
        System.out.println(&quot;Sony: channel - &quot; + channel);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//遥控器要包含对TV的引用
public abstract class AbstractRemoteControl {

    private ITV tv;

    public AbstractRemoteControl(ITV tv){
        this.tv = tv;
    }

    public void turnOn(){
        tv.on();
    }

    public void turnOff(){
        tv.off();
    }

    public void setChannel(int channel){
        tv.switchChannel(channel);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//定义遥控器的具体类
public class LogitechRemoteControl extends AbstractRemoteControl {

    public LogitechRemoteControl(ITV tv) {
        super(tv);
    }

    public void setChannelKeyboard(int channel){
        setChannel(channel);
        System.out.println(&quot;Logitech use keyword to set channel.&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//调用
public class Main {
    public static void main(String[] args){
        ITV tv = new SonyTV();
        LogitechRemoteControl lrc = new LogitechRemoteControl(tv);
        lrc.setChannelKeyboard(100);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;first-class function轻松解决！&lt;/p&gt;

&lt;p&gt;三星命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns samsung)

(defn on []
  (println &quot;Samsung is turned on.&quot;))

(defn off []
  (println &quot;Samsung is turned off.&quot;))

(defn switch-channel [channel]
  (println &quot;Samsung: channel - &quot; + channel))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;索尼命名空间:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns sony)

(defn on []
  (println &quot;Sony is turned on.&quot;))

(defn off []
  (println &quot;Sony is turned off.&quot;))

(defn switch-channel [channel]
  (println &quot;Sony: channel - &quot; + channel))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RemoteController:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns remotecontroller)

(defn turn-on [f]
   (f))

(defn turn-off [f]
   (f))

(defn set-channel [f arg]
   (f arg))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns client
  (:require [sony :as tv]
            [remotecontroller :as c]))

(c/turn-on tv/on)
(c/set-channel tv/switch-channel 3)
(c/trun-off tv/off)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这么实现简直就是脱裤子放屁～～！&lt;/p&gt;

&lt;p&gt;直接调用sony或samsung里的函数就行了！多此一举！&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-10装饰模式</title>
        <link href="http://ivanpig.github.io/2015/02/12/decorator.html"/>
        <updated>2015-02-12T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/12/decorator</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/decorator.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/li&gt;
&lt;li&gt;处理那些可以撤消的职责。&lt;/li&gt;
&lt;li&gt;当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;JavaIO库的使用可能如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;BufferedInputStream bi = new BufferedInputStream(new FileInputStream(filename));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们都知道FileInputStream是用来读取文件的，BufferedInputStream是提供了缓存的能力。我们分别看下他们的源代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class BufferedInputStream extends FilterInputStream
...

public class FilterInputStream extends InputStream
...

public class FileInputStream extends InputStream
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BufferedInputStream继承了FilterInputStream，FilterInputStream和FileInputStream一样都继承自InputStream.&lt;/p&gt;

&lt;p&gt;可以看出InputStream是公共父类。&lt;/p&gt;

&lt;p&gt;FilterInputStream是装饰类的公共父类，看看FilterInputStream的源代码就知道了，他只是做了简单的方法委托。&lt;/p&gt;

&lt;p&gt;BufferedInputStream继承了FilterInputStream，并添加了缓存的方法（其实就是用一个字节数组保存字节，一次性读出）。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;笑而不语～&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/decorator.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。&lt;/li&gt;
&lt;li&gt;处理那些可以撤消的职责。&lt;/li&gt;
&lt;li&gt;当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;JavaIO库的使用可能如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;BufferedInputStream bi = new BufferedInputStream(new FileInputStream(filename));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们都知道FileInputStream是用来读取文件的，BufferedInputStream是提供了缓存的能力。我们分别看下他们的源代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class BufferedInputStream extends FilterInputStream
...

public class FilterInputStream extends InputStream
...

public class FileInputStream extends InputStream
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BufferedInputStream继承了FilterInputStream，FilterInputStream和FileInputStream一样都继承自InputStream.&lt;/p&gt;

&lt;p&gt;可以看出InputStream是公共父类。&lt;/p&gt;

&lt;p&gt;FilterInputStream是装饰类的公共父类，看看FilterInputStream的源代码就知道了，他只是做了简单的方法委托。&lt;/p&gt;

&lt;p&gt;BufferedInputStream继承了FilterInputStream，并添加了缓存的方法（其实就是用一个字节数组保存字节，一次性读出）。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;笑而不语～&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-09组合模式</title>
        <link href="http://ivanpig.github.io/2015/02/11/composite.html"/>
        <updated>2015-02-11T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/11/composite</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/composite.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你想表示对象的部分—整体层次结构。&lt;/li&gt;
&lt;li&gt;你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public interface Node {
    void check();
    void add(Node node) throws Exception;
    void remove(Node node) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class ParentNode implements Node {
    private List&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;Node&amp;gt;();

    public void check() {
        System.out.println(&quot;ParentNode is checked&quot;);
        for(Node n : list){
          n.check();
        }
    }

    public void add(Node node) {
        list.add(node);
    }

    public void remove(Node node) {
        list.remove(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;public class ChildNode implements Node {
    public void check() {
        System.out.println(&quot;ChildNode is Checked&quot;);
    }

    public void add(Node node) throws Exception {
        throw new Exception(&quot;This node can not add&quot;);
    }

    public void remove(Node node) throws Exception {
        throw new Exception(&quot;This node can not remove&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws Exception {
        Node node1 = new ChildNode();
        Node node2 = new ChildNode();
        Node node3 = new ParentNode();
        node3.add(node1);
        node3.add(node2);
        node1.check();
        node2.check();
        node3.check();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;实际上就是对树的操作！Clojure提供了clojure.zip,clojure.walk或者tree-seq来进行对树的操作！&lt;/p&gt;

&lt;p&gt;操作起来也不是很方便就是了！&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/composite.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你想表示对象的部分—整体层次结构。&lt;/li&gt;
&lt;li&gt;你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public interface Node {
    void check();
    void add(Node node) throws Exception;
    void remove(Node node) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class ParentNode implements Node {
    private List&amp;lt;Node&amp;gt; list = new ArrayList&amp;lt;Node&amp;gt;();

    public void check() {
        System.out.println(&quot;ParentNode is checked&quot;);
        for(Node n : list){
          n.check();
        }
    }

    public void add(Node node) {
        list.add(node);
    }

    public void remove(Node node) {
        list.remove(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;public class ChildNode implements Node {
    public void check() {
        System.out.println(&quot;ChildNode is Checked&quot;);
    }

    public void add(Node node) throws Exception {
        throw new Exception(&quot;This node can not add&quot;);
    }

    public void remove(Node node) throws Exception {
        throw new Exception(&quot;This node can not remove&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class Main {

    public static void main(String[] args) throws Exception {
        Node node1 = new ChildNode();
        Node node2 = new ChildNode();
        Node node3 = new ParentNode();
        node3.add(node1);
        node3.add(node2);
        node1.check();
        node2.check();
        node3.check();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;实际上就是对树的操作！Clojure提供了clojure.zip,clojure.walk或者tree-seq来进行对树的操作！&lt;/p&gt;

&lt;p&gt;操作起来也不是很方便就是了！&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-08适配器模式</title>
        <link href="http://ivanpig.github.io/2015/02/10/adapter.html"/>
        <updated>2015-02-10T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/10/adapter</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/adapter.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你想使用一个已经存在的类，而它的接口不符合你的需求。&lt;/li&gt;
&lt;li&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。&lt;/li&gt;
&lt;li&gt;（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;假设目前做一个新系统，有如下代码结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public interface Car{
     public void drive();
}

public class Benz implements Car{
     public void drive(){
          System.out.println(&quot;Benz run&quot;);
     }
}

public class Cruze implements Car{
     public void drive(){
          System.out.println(&quot;Cruze run&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个老系统，里面有如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Smart{
     public void run(){
         System.out.println(&quot;Smart run&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;类适配器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class SmartCar extends Smart implements Car{
      public void drive(){
           this.run();
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象适配器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class SmartCar implements Car{
     private Smart smart = new Smart();

     public void drive(){
          smart.run();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;first-class function轻松解决!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn drive []
  (println &quot;drive&quot;))

(defn run []
  (println &quot;run&quot;))

(defn do-drive [f]
  (f))

(do-drive drive)
(do-drive run)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将一个类的接口转换成另外一个客户希望的接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/adapter.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;你想使用一个已经存在的类，而它的接口不符合你的需求。&lt;/li&gt;
&lt;li&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。&lt;/li&gt;
&lt;li&gt;（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;假设目前做一个新系统，有如下代码结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public interface Car{
     public void drive();
}

public class Benz implements Car{
     public void drive(){
          System.out.println(&quot;Benz run&quot;);
     }
}

public class Cruze implements Car{
     public void drive(){
          System.out.println(&quot;Cruze run&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个老系统，里面有如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Smart{
     public void run(){
         System.out.println(&quot;Smart run&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;类适配器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class SmartCar extends Smart implements Car{
      public void drive(){
           this.run();
      }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象适配器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class SmartCar implements Car{
     private Smart smart = new Smart();

     public void drive(){
          smart.run();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;first-class function轻松解决!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn drive []
  (println &quot;drive&quot;))

(defn run []
  (println &quot;run&quot;))

(defn do-drive [f]
  (f))

(do-drive drive)
(do-drive run)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-07代理模式</title>
        <link href="http://ivanpig.github.io/2015/02/09/proxy.html"/>
        <updated>2015-02-09T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/09/proxy</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/proxy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;p&gt;在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式常见情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。&lt;/li&gt;
&lt;li&gt;虚代理（Virtual Proxy）根据需要创建开销很大的对象。&lt;/li&gt;
&lt;li&gt;保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。&lt;/li&gt;
&lt;li&gt;智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：&lt;/li&gt;
&lt;li&gt;对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。&lt;/li&gt;
&lt;li&gt;当第一次引用一个持久对象时，将它装入内存。&lt;/li&gt;
&lt;li&gt;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//工厂接口
public interface ItemFactory{
     public Item getItem();
}

//工厂实现,Item就不实现了，随便怎么写都行
public class ItemFactoryImpl implements ItemFactory{
      public Item getItem(){
          return new Item();
      }
}

//商店类，就是代理
public class Shop implements ItemFactory{

     private ItemFactory factory = new ItemFactoryImpl();

     public Item getItem(){
          System.out.println(&quot;附加服务&quot;);
          return factory.getItem();
     }
}

//实际调用
public class Main{
     public static void main(String[] args){
          ItemFactory f = new Shop();
          f.getItem();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn factory []
  (println &quot;Return item&quot;))

(defn shop [f]
  (println &quot;附加服务&quot;)
  (f))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说到底还是因为Java的粒度只能到类，而不能到方法(函数)。&lt;/p&gt;

&lt;p&gt;简单的一个高阶函数就搞定了!&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/proxy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;p&gt;在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一些可以使用Proxy模式常见情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。&lt;/li&gt;
&lt;li&gt;虚代理（Virtual Proxy）根据需要创建开销很大的对象。&lt;/li&gt;
&lt;li&gt;保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。&lt;/li&gt;
&lt;li&gt;智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：&lt;/li&gt;
&lt;li&gt;对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。&lt;/li&gt;
&lt;li&gt;当第一次引用一个持久对象时，将它装入内存。&lt;/li&gt;
&lt;li&gt;在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//工厂接口
public interface ItemFactory{
     public Item getItem();
}

//工厂实现,Item就不实现了，随便怎么写都行
public class ItemFactoryImpl implements ItemFactory{
      public Item getItem(){
          return new Item();
      }
}

//商店类，就是代理
public class Shop implements ItemFactory{

     private ItemFactory factory = new ItemFactoryImpl();

     public Item getItem(){
          System.out.println(&quot;附加服务&quot;);
          return factory.getItem();
     }
}

//实际调用
public class Main{
     public static void main(String[] args){
          ItemFactory f = new Shop();
          f.getItem();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn factory []
  (println &quot;Return item&quot;))

(defn shop [f]
  (println &quot;附加服务&quot;)
  (f))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说到底还是因为Java的粒度只能到类，而不能到方法(函数)。&lt;/p&gt;

&lt;p&gt;简单的一个高阶函数就搞定了!&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-06门面模式</title>
        <link href="http://ivanpig.github.io/2015/02/08/facade.html"/>
        <updated>2015-02-08T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/08/facade</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/facade.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。&lt;/li&gt;
&lt;li&gt;客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。&lt;/li&gt;
&lt;li&gt;当你需要构建一个层次结构的子系统时，使用门面模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public class Camara {
    public void turnOn(){
        System.out.println(&quot;开启摄像头！&quot;);
    }

    public void turnOff(){
        System.out.println(&quot;关闭摄像头！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class Light {
    public void turnOn(){
        System.out.println(&quot;开灯！&quot;);
    }

    public void turnOff(){
        System.out.println(&quot;关灯！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;public class Sensor {
    public void activate(){
        System.out.println(&quot;开启感应器！&quot;);
    }

    public void deactivate(){
        System.out.println(&quot;关闭感应器！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class CamaraFacade {
    private Camara c1, c2;
    private Light l1, l2, l3;
    private Sensor s;

   {
        c1 = new Camara();
        c2 = new Camara();
        l1 = new Light();
        l2 = new Light();
        l3 = new Light();
        s = new Sensor();
    }

    public void activate(){
        c1.turnOn();
        c2.turnOn();

        l1.turnOn();
        l2.turnOn();
        l3.turnOn();

        s.activate();
    }

    public void deactivate(){
        c1.turnOff();
        c2.turnOff();

        l1.turnOff();
        l2.turnOff();
        l3.turnOff();

        s.deactivate();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class ClientTest {

    public static void main(String[] args) {
        CamaraFacade facade = new CamaraFacade();
        //打开
        facade.activate();
        //关闭
        facade.deactivate();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;函数组合轻松搞定！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn turn-on-camara []
  (println &quot;开启摄像头&quot;))

(defn turn-on-light []
  (println &quot;打开闪光灯&quot;))

(defn turn-on-sensor []
  (println &quot;开启感应器&quot;))

(defn turn-on-facade []
  (turn-on-camara)
  (turn-on-light)
  (turn-on-sensor))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/facade.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。&lt;/li&gt;
&lt;li&gt;客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。&lt;/li&gt;
&lt;li&gt;当你需要构建一个层次结构的子系统时，使用门面模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public class Camara {
    public void turnOn(){
        System.out.println(&quot;开启摄像头！&quot;);
    }

    public void turnOff(){
        System.out.println(&quot;关闭摄像头！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class Light {
    public void turnOn(){
        System.out.println(&quot;开灯！&quot;);
    }

    public void turnOff(){
        System.out.println(&quot;关灯！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;public class Sensor {
    public void activate(){
        System.out.println(&quot;开启感应器！&quot;);
    }

    public void deactivate(){
        System.out.println(&quot;关闭感应器！&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class CamaraFacade {
    private Camara c1, c2;
    private Light l1, l2, l3;
    private Sensor s;

   {
        c1 = new Camara();
        c2 = new Camara();
        l1 = new Light();
        l2 = new Light();
        l3 = new Light();
        s = new Sensor();
    }

    public void activate(){
        c1.turnOn();
        c2.turnOn();

        l1.turnOn();
        l2.turnOn();
        l3.turnOn();

        s.activate();
    }

    public void deactivate(){
        c1.turnOff();
        c2.turnOff();

        l1.turnOff();
        l2.turnOff();
        l3.turnOff();

        s.deactivate();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class ClientTest {

    public static void main(String[] args) {
        CamaraFacade facade = new CamaraFacade();
        //打开
        facade.activate();
        //关闭
        facade.deactivate();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;函数组合轻松搞定！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn turn-on-camara []
  (println &quot;开启摄像头&quot;))

(defn turn-on-light []
  (println &quot;打开闪光灯&quot;))

(defn turn-on-sensor []
  (println &quot;开启感应器&quot;))

(defn turn-on-facade []
  (turn-on-camara)
  (turn-on-light)
  (turn-on-sensor))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-05生成器模式</title>
        <link href="http://ivanpig.github.io/2015/02/07/builder.html"/>
        <updated>2015-02-07T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/07/builder</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/builder.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。&lt;/li&gt;
&lt;li&gt;当构造过程必须允许被构造的对象有不同的表示时。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;// 待构建产品
class Starbucks {
    private String size;
    private String drink;

    public void setSize(String size) {
        this.size = size;
    }

    public void setDrink(String drink) {
        this.drink = drink;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//抽象builder
abstract class StarbucksBuilder {
    protected Starbucks starbucks;

    public Starbucks getStarbucks() {
        return starbucks;
    }

    public void createStarbucks() {
        starbucks = new Starbucks();
        System.out.println(&quot;a drink is created&quot;);
    }

    public abstract void buildSize();
    public abstract void buildDrink();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;// 泡茶builder
class TeaBuilder extends StarbucksBuilder {
    public void buildSize() {
        starbucks.setSize(&quot;large&quot;);
        System.out.println(&quot;build large size&quot;);
    }

    public void buildDrink() {
        starbucks.setDrink(&quot;tea&quot;);
        System.out.println(&quot;build tea&quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 泡咖啡builder
class CoffeeBuilder extends StarbucksBuilder {
    public void buildSize() {
        starbucks.setSize(&quot;medium&quot;);
        System.out.println(&quot;build medium size&quot;);
    }

    public void buildDrink() {
        starbucks.setDrink(&quot;coffee&quot;);
        System.out.println(&quot;build coffee&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//指导如何封装builder
class Waiter {
    private StarbucksBuilder starbucksBuilder;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setStarbucksBuilder(StarbucksBuilder builder) {
    starbucksBuilder = builder;
}

public Starbucks getstarbucksDrink() {
    return starbucksBuilder.getStarbucks();
}

public void constructStarbucks() {
    starbucksBuilder.createStarbucks();
    starbucksBuilder.buildDrink();
    starbucksBuilder.buildSize();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//客户
public class Customer {
    public static void main(String[] args) {
        Waiter waiter = new Waiter();
        StarbucksBuilder coffeeBuilder = new CoffeeBuilder();

        //也可以用泡茶builder沏茶
        //StarbucksBuilder teaBuilder = new TeaBuilder();

        waiter.setStarbucksBuilder(coffeeBuilder);
        waiter.constructStarbucks();

        //取到饮料
        Starbucks drink = waiter.getstarbucksDrink();

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;在Clojure里也是个没必要的模式！因为根本就不需要构建对象啊！&lt;/p&gt;

&lt;p&gt;可以使用multimethod模拟,或者直接简单模拟如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn type [d t]
  (assoc d :type t))

(defn size [d t]
  (assoc d :size t))

(def drink {})

(-&amp;gt; drink (type :tea) (size :large))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/builder.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。&lt;/li&gt;
&lt;li&gt;当构造过程必须允许被构造的对象有不同的表示时。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;// 待构建产品
class Starbucks {
    private String size;
    private String drink;

    public void setSize(String size) {
        this.size = size;
    }

    public void setDrink(String drink) {
        this.drink = drink;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//抽象builder
abstract class StarbucksBuilder {
    protected Starbucks starbucks;

    public Starbucks getStarbucks() {
        return starbucks;
    }

    public void createStarbucks() {
        starbucks = new Starbucks();
        System.out.println(&quot;a drink is created&quot;);
    }

    public abstract void buildSize();
    public abstract void buildDrink();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;// 泡茶builder
class TeaBuilder extends StarbucksBuilder {
    public void buildSize() {
        starbucks.setSize(&quot;large&quot;);
        System.out.println(&quot;build large size&quot;);
    }

    public void buildDrink() {
        starbucks.setDrink(&quot;tea&quot;);
        System.out.println(&quot;build tea&quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 泡咖啡builder
class CoffeeBuilder extends StarbucksBuilder {
    public void buildSize() {
        starbucks.setSize(&quot;medium&quot;);
        System.out.println(&quot;build medium size&quot;);
    }

    public void buildDrink() {
        starbucks.setDrink(&quot;coffee&quot;);
        System.out.println(&quot;build coffee&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//指导如何封装builder
class Waiter {
    private StarbucksBuilder starbucksBuilder;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void setStarbucksBuilder(StarbucksBuilder builder) {
    starbucksBuilder = builder;
}

public Starbucks getstarbucksDrink() {
    return starbucksBuilder.getStarbucks();
}

public void constructStarbucks() {
    starbucksBuilder.createStarbucks();
    starbucksBuilder.buildDrink();
    starbucksBuilder.buildSize();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//客户
public class Customer {
    public static void main(String[] args) {
        Waiter waiter = new Waiter();
        StarbucksBuilder coffeeBuilder = new CoffeeBuilder();

        //也可以用泡茶builder沏茶
        //StarbucksBuilder teaBuilder = new TeaBuilder();

        waiter.setStarbucksBuilder(coffeeBuilder);
        waiter.constructStarbucks();

        //取到饮料
        Starbucks drink = waiter.getstarbucksDrink();

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;在Clojure里也是个没必要的模式！因为根本就不需要构建对象啊！&lt;/p&gt;

&lt;p&gt;可以使用multimethod模拟,或者直接简单模拟如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn type [d t]
  (assoc d :type t))

(defn size [d t]
  (assoc d :size t))

(def drink {})

(-&amp;gt; drink (type :tea) (size :large))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-04原型模式</title>
        <link href="http://ivanpig.github.io/2015/02/06/prototype.html"/>
        <updated>2015-02-06T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/06/prototype</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/prototype.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者&lt;/li&gt;
&lt;li&gt;为了避免创建一个与产品类层次平行的工厂类层次时；或者&lt;/li&gt;
&lt;li&gt;当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;//浅拷贝
public class A implements Cloneable{

    private String str;
    private B b;

    public void setStr(String str){
        this.str = str;
    }

    public String getStr(){
        return str;
    }

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    @Override
    protected Object clone(){
        A a = null;
        try {
            a = (A) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return a;
    }

    public static void main(String[] args) {
        A a = new A();
        a.setStr(&quot;Hello&quot;);
        B b = new B();
        b.setStr(&quot;Hello B&quot;);
        a.setB(b);
        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        A ac = null;
        ac = (A) a.clone();
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());

        a.setStr(&quot;Hello A&quot;);
        b.setStr(&quot;Hello BB&quot;);
        a.setB(b);

        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;public class B{
     private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//输出结果
a-str:Hello
a-b:Hello B
ac-str:Hello
ac-b:Hello B
a-str:Hello A
a-b:Hello BB
ac-str:Hello
ac-b:Hello BB       --浅拷贝导致了，ac和a中的B是相同的引用，a中的b被修改后，ac中的b也被修改，这应该是不想要的结果
                    --所以需要深拷贝。深拷贝就是将所有涉及到的对象都进行Clone
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;//深拷贝
public class A implements Cloneable{

    private String str;
    private B b;

    public void setStr(String str){
        this.str = str;
    }

    public String getStr(){
        return str;
    }

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    @Override
    protected Object clone(){
        A a = null;
        try {
            a = (A) super.clone();
            a.b = (B) b.clone();       //此处对b进行clone
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return a;
    }

    public static void main(String[] args) {
        A a = new A();
        a.setStr(&quot;Hello&quot;);
        B b = new B();
        b.setStr(&quot;Hello B&quot;);
        a.setB(b);
        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        A ac = null;
        ac = (A) a.clone();
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());

        a.setStr(&quot;Hello A&quot;);
        b.setStr(&quot;Hello BB&quot;);
        a.setB(b);

        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//B也要实现Cloneable并重写clone方法
public class B implements Cloneable{
     private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//输出结果
/*
a-str:Hello
a-b:Hello B
ac-str:Hello
ac-b:Hello B
a-str:Hello A
a-b:Hello BB
ac-str:Hello
ac-b:Hello B        --此处a中的b被修改后，ac中的b不会被影响
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;对于Clojure来说，根本就不需要原型模式！&lt;/p&gt;

&lt;p&gt;首先请想想为什么Java需要原型模式？&lt;/p&gt;

&lt;p&gt;根本原因是Java中的对象是可变的！就像上面的str属性，如果不拷贝，则两个引用指向同一个对象，当其中一个引用改变了str的值，那么另一个引用也会受到影响！&lt;/p&gt;

&lt;p&gt;而在Clojure中，所有数据都是不可变的！当你修改了一个数据，原来的数据并没有变化，而是返回了一个新的数据。这样的话，在Clojure中根本就不需要原型模式。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/prototype.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者&lt;/li&gt;
&lt;li&gt;为了避免创建一个与产品类层次平行的工厂类层次时；或者&lt;/li&gt;
&lt;li&gt;当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;//浅拷贝
public class A implements Cloneable{

    private String str;
    private B b;

    public void setStr(String str){
        this.str = str;
    }

    public String getStr(){
        return str;
    }

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    @Override
    protected Object clone(){
        A a = null;
        try {
            a = (A) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return a;
    }

    public static void main(String[] args) {
        A a = new A();
        a.setStr(&quot;Hello&quot;);
        B b = new B();
        b.setStr(&quot;Hello B&quot;);
        a.setB(b);
        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        A ac = null;
        ac = (A) a.clone();
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());

        a.setStr(&quot;Hello A&quot;);
        b.setStr(&quot;Hello BB&quot;);
        a.setB(b);

        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code&gt;public class B{
     private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//输出结果
a-str:Hello
a-b:Hello B
ac-str:Hello
ac-b:Hello B
a-str:Hello A
a-b:Hello BB
ac-str:Hello
ac-b:Hello BB       --浅拷贝导致了，ac和a中的B是相同的引用，a中的b被修改后，ac中的b也被修改，这应该是不想要的结果
                    --所以需要深拷贝。深拷贝就是将所有涉及到的对象都进行Clone
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;//深拷贝
public class A implements Cloneable{

    private String str;
    private B b;

    public void setStr(String str){
        this.str = str;
    }

    public String getStr(){
        return str;
    }

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    @Override
    protected Object clone(){
        A a = null;
        try {
            a = (A) super.clone();
            a.b = (B) b.clone();       //此处对b进行clone
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return a;
    }

    public static void main(String[] args) {
        A a = new A();
        a.setStr(&quot;Hello&quot;);
        B b = new B();
        b.setStr(&quot;Hello B&quot;);
        a.setB(b);
        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        A ac = null;
        ac = (A) a.clone();
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());

        a.setStr(&quot;Hello A&quot;);
        b.setStr(&quot;Hello BB&quot;);
        a.setB(b);

        System.out.println(&quot;a-str:&quot; + a.getStr());
        System.out.println(&quot;a-b:&quot; + a.getB().getStr());
        System.out.println(&quot;ac-str:&quot; + ac.getStr());
        System.out.println(&quot;ac-b:&quot; + ac.getB().getStr());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//B也要实现Cloneable并重写clone方法
public class B implements Cloneable{
     private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//输出结果
/*
a-str:Hello
a-b:Hello B
ac-str:Hello
ac-b:Hello B
a-str:Hello A
a-b:Hello BB
ac-str:Hello
ac-b:Hello B        --此处a中的b被修改后，ac中的b不会被影响
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;对于Clojure来说，根本就不需要原型模式！&lt;/p&gt;

&lt;p&gt;首先请想想为什么Java需要原型模式？&lt;/p&gt;

&lt;p&gt;根本原因是Java中的对象是可变的！就像上面的str属性，如果不拷贝，则两个引用指向同一个对象，当其中一个引用改变了str的值，那么另一个引用也会受到影响！&lt;/p&gt;

&lt;p&gt;而在Clojure中，所有数据都是不可变的！当你修改了一个数据，原来的数据并没有变化，而是返回了一个新的数据。这样的话，在Clojure中根本就不需要原型模式。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-03抽象工厂模式</title>
        <link href="http://ivanpig.github.io/2015/02/05/abstract_factory.html"/>
        <updated>2015-02-05T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/05/abstract_factory</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/abstract_factory.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个系统要独立于它的产品的创建、组合和表示时。&lt;/li&gt;
&lt;li&gt;一个系统要由多个产品系列中的一个来配置时。&lt;/li&gt;
&lt;li&gt;当你要强调一系列相关的产品对象的设计以便进行联合使用时。&lt;/li&gt;
&lt;li&gt;当你提供一个产品类库，而只想显示它们的接口而不是实现时。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;表现在代码层面就是一个工厂可以返回多个不同的实例！&lt;/p&gt;

&lt;p&gt;比如:Pig不仅分颜色，还分国家，比如荷兰Pig，新西兰Pig。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class RedPigFactory implements PigFactory{
     public Pig getNetherlandsPig(){
          return new RedNetherlandsPig();
     }

     public Pig getNewZealandPig(){
          return new RedNewZealandPig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;而在Clojure中就是选择函数的条件多了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defmulti run (fn [t] t))

(defmethod run
  [:RedPig :Netherlands]
  [t]
  (println &quot;Netherlands RedPig run&quot;))

(defmethod run
  [:GreenPig :Netherlands]
  [t]
  (println &quot;Netherlands GreenPig run&quot;))

(defmethod run
  [:BluePig :Netherlands]
  [t]
  (println &quot;Netherlands BluePig run&quot;))

(defmethod run
  [:RedPig :NewZealand]
  [t]
  (println &quot;NewZealand RedPig run&quot;))

(defmethod run
  [:GreenPig :NewZealand]
  [t]
  (println &quot;NewZealand GreenPig run&quot;))

(defmethod run
  [:BluePig :NewZealand]
  [t]
  (println &quot;NewZealand BluePig run&quot;))

(run [:BluePig :Netherlands])
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/abstract_factory.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;一个系统要独立于它的产品的创建、组合和表示时。&lt;/li&gt;
&lt;li&gt;一个系统要由多个产品系列中的一个来配置时。&lt;/li&gt;
&lt;li&gt;当你要强调一系列相关的产品对象的设计以便进行联合使用时。&lt;/li&gt;
&lt;li&gt;当你提供一个产品类库，而只想显示它们的接口而不是实现时。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;表现在代码层面就是一个工厂可以返回多个不同的实例！&lt;/p&gt;

&lt;p&gt;比如:Pig不仅分颜色，还分国家，比如荷兰Pig，新西兰Pig。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class RedPigFactory implements PigFactory{
     public Pig getNetherlandsPig(){
          return new RedNetherlandsPig();
     }

     public Pig getNewZealandPig(){
          return new RedNewZealandPig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;而在Clojure中就是选择函数的条件多了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defmulti run (fn [t] t))

(defmethod run
  [:RedPig :Netherlands]
  [t]
  (println &quot;Netherlands RedPig run&quot;))

(defmethod run
  [:GreenPig :Netherlands]
  [t]
  (println &quot;Netherlands GreenPig run&quot;))

(defmethod run
  [:BluePig :Netherlands]
  [t]
  (println &quot;Netherlands BluePig run&quot;))

(defmethod run
  [:RedPig :NewZealand]
  [t]
  (println &quot;NewZealand RedPig run&quot;))

(defmethod run
  [:GreenPig :NewZealand]
  [t]
  (println &quot;NewZealand GreenPig run&quot;))

(defmethod run
  [:BluePig :NewZealand]
  [t]
  (println &quot;NewZealand BluePig run&quot;))

(run [:BluePig :Netherlands])
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-02工厂模式</title>
        <link href="http://ivanpig.github.io/2015/02/04/factory.html"/>
        <updated>2015-02-04T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/04/factory</id>
        <content type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/factory.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当一个类不知道它所必须创建的对象的类的时候。&lt;/li&gt;
&lt;li&gt;当一个类希望由它的子类来指定它所创建的对象的时候。&lt;/li&gt;
&lt;li&gt;当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public interface Pig{
     public void run();
}

public interface PigFactory{
     public Pig getPig();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class RedPig{
     public void run(){
       System.out.println(&quot;RedPig run&quot;);
     }
}

public class RedPigFactory implements PigFactory{
     public Pig getPig(){
          return new RedPig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class GreenPig{
     public void run(){
       System.out.println(&quot;GreenPig run&quot;);
     }
}

public class GreenPigFactory implements PigFactory{
     public Pig getPig(){
          return new GreenPig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class BluePig{
     public void run(){
       System.out.println(&quot;BluePig run&quot;);
     }
}

public class BluePigFactory implements PigFactory{
     public Pig getPig(){
          return new BluePig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;PigFactory factory = new BluePigFactory();
factory.getPig().run();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure&lt;/h1&gt;

&lt;p&gt;这里的核心是什么？根据不同的需要返回了不同的对象，然后呢？执行返回对象的方法！&lt;/p&gt;

&lt;p&gt;在Clojure里就是根据不同的需要直接执行不同的函数！Clojure有默认支持！MultiMethod!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defmulti run (fn [t] t))

(defmethod run
  :RedPig
  [t]
  (println &quot;RedPig run&quot;))

(defmethod run
  :GreenPig
  [t]
  (println &quot;GreenPig run&quot;))

(defmethod run
  :BluePig
  [t]
  (println &quot;BluePig run&quot;))

(run :RedPig)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/factory.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当一个类不知道它所必须创建的对象的类的时候。&lt;/li&gt;
&lt;li&gt;当一个类希望由它的子类来指定它所创建的对象的时候。&lt;/li&gt;
&lt;li&gt;当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public interface Pig{
     public void run();
}

public interface PigFactory{
     public Pig getPig();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class RedPig{
     public void run(){
       System.out.println(&quot;RedPig run&quot;);
     }
}

public class RedPigFactory implements PigFactory{
     public Pig getPig(){
          return new RedPig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class GreenPig{
     public void run(){
       System.out.println(&quot;GreenPig run&quot;);
     }
}

public class GreenPigFactory implements PigFactory{
     public Pig getPig(){
          return new GreenPig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class BluePig{
     public void run(){
       System.out.println(&quot;BluePig run&quot;);
     }
}

public class BluePigFactory implements PigFactory{
     public Pig getPig(){
          return new BluePig();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;PigFactory factory = new BluePigFactory();
factory.getPig().run();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure&lt;/h1&gt;

&lt;p&gt;这里的核心是什么？根据不同的需要返回了不同的对象，然后呢？执行返回对象的方法！&lt;/p&gt;

&lt;p&gt;在Clojure里就是根据不同的需要直接执行不同的函数！Clojure有默认支持！MultiMethod!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defmulti run (fn [t] t))

(defmethod run
  :RedPig
  [t]
  (println &quot;RedPig run&quot;))

(defmethod run
  :GreenPig
  [t]
  (println &quot;GreenPig run&quot;))

(defmethod run
  :BluePig
  [t]
  (println &quot;BluePig run&quot;))

(run :RedPig)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>语言与模式-01单例模式</title>
        <link href="http://ivanpig.github.io/2015/02/03/singleton.html"/>
        <updated>2015-02-03T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2015/02/03/singleton</id>
        <content type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;设计模式是什么？如果要我现在来回答，那我的答案是：&lt;strong&gt;设计模式是对于语言本身缺陷的一种补充！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本系列文章通过对各个设计模式在Java与Clojure之间的实现比较来说明这一点！&lt;/p&gt;

&lt;p&gt;关于Clojure相关内容，可以查看&lt;a href=&quot;/tag/#clojure&quot;&gt;这里&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;其实使用Clojure来实现设计模式并不合适！因为Clojure是函数式语言，而设计模式是针对面向对象语言的。但是Clojure能提供近似的解决方案或者根本不需要此设计模式，且Clojure的解决方案更简单！简单到都不好意思叫做模式！&lt;/p&gt;

&lt;p&gt;当然我也不是要黑Java，毕竟还要靠Java吃饭！Java作为工业化标准开发还是很不错的，只是表现力不足，模板代码较多而已！但是足够简单，易标准化。这就够了！&lt;/p&gt;

&lt;p&gt;废话不多说，开始第一个设计模式！单例模式！&lt;/p&gt;

&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/singleton.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。&lt;/li&gt;
&lt;li&gt;当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;懒汉式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public synchronized static Singleton getInstance(){
           if(single==null){
                single=new Singleton();
           }
           return single;
       }

      private static Singleton single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;饿汉式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public static Singleton getInstance(){
                  return single;
       }
      private static Singleton single=new Singleton();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;double-checked locking：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public static Singleton getInstance(){
           if(single==null){
               synchronized(Singleton.class){
                  if(single==null){
                     single=new Singleton();
                  }
               }
           }
           return single;
       }
      private volatile static Singleton single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;请问你获取对象是干嘛用的？&lt;/p&gt;

&lt;p&gt;还不是为了调用它的属性或方法？只是因为Java最小粒度到Class，所以才要先创建对象，所以才导致了如上这么多的问题！所以才要所谓单例模式！&lt;/p&gt;

&lt;p&gt;而Clojure最小粒度到函数(也就是Java中的方法)，也就没有所谓创建对象导致的开销！所以你需要什么方法就定义什么方法，直接调用就行了!&lt;/p&gt;

&lt;p&gt;对于上面的例子，假设你是要调用Singleton里的prt方法，代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public static Singleton getInstance(){
           if(single==null){
               synchronized(Singleton.class){
                  if(single==null){
                     single=new Singleton();
                  }
               }
           }
           return single;
       }

       public void prt(){
         System.out.println(&quot;This is Singleton&quot;);
       }

      private volatile static Singleton single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Clojure里面你可以这么写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn prt []
  (println &quot;This is Singleton&quot;))

;调用
(prt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要模式吗？&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;设计模式是什么？如果要我现在来回答，那我的答案是：&lt;strong&gt;设计模式是对于语言本身缺陷的一种补充！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本系列文章通过对各个设计模式在Java与Clojure之间的实现比较来说明这一点！&lt;/p&gt;

&lt;p&gt;关于Clojure相关内容，可以查看&lt;a href=&quot;/tag/#clojure&quot;&gt;这里&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;其实使用Clojure来实现设计模式并不合适！因为Clojure是函数式语言，而设计模式是针对面向对象语言的。但是Clojure能提供近似的解决方案或者根本不需要此设计模式，且Clojure的解决方案更简单！简单到都不好意思叫做模式！&lt;/p&gt;

&lt;p&gt;当然我也不是要黑Java，毕竟还要靠Java吃饭！Java作为工业化标准开发还是很不错的，只是表现力不足，模板代码较多而已！但是足够简单，易标准化。这就够了！&lt;/p&gt;

&lt;p&gt;废话不多说，开始第一个设计模式！单例模式！&lt;/p&gt;

&lt;h1&gt;意图&lt;/h1&gt;

&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/designpattern/singleton.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;适用性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。&lt;/li&gt;
&lt;li&gt;当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java实现&lt;/h1&gt;

&lt;p&gt;懒汉式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public synchronized static Singleton getInstance(){
           if(single==null){
                single=new Singleton();
           }
           return single;
       }

      private static Singleton single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;饿汉式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public static Singleton getInstance(){
                  return single;
       }
      private static Singleton single=new Singleton();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;double-checked locking：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public static Singleton getInstance(){
           if(single==null){
               synchronized(Singleton.class){
                  if(single==null){
                     single=new Singleton();
                  }
               }
           }
           return single;
       }
      private volatile static Singleton single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Clojure实现&lt;/h1&gt;

&lt;p&gt;请问你获取对象是干嘛用的？&lt;/p&gt;

&lt;p&gt;还不是为了调用它的属性或方法？只是因为Java最小粒度到Class，所以才要先创建对象，所以才导致了如上这么多的问题！所以才要所谓单例模式！&lt;/p&gt;

&lt;p&gt;而Clojure最小粒度到函数(也就是Java中的方法)，也就没有所谓创建对象导致的开销！所以你需要什么方法就定义什么方法，直接调用就行了!&lt;/p&gt;

&lt;p&gt;对于上面的例子，假设你是要调用Singleton里的prt方法，代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Singleton{
       private Singleton(){}

       public static Singleton getInstance(){
           if(single==null){
               synchronized(Singleton.class){
                  if(single==null){
                     single=new Singleton();
                  }
               }
           }
           return single;
       }

       public void prt(){
         System.out.println(&quot;This is Singleton&quot;);
       }

      private volatile static Singleton single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Clojure里面你可以这么写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn prt []
  (println &quot;This is Singleton&quot;))

;调用
(prt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要模式吗？&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>LightTable Theme</title>
        <link href="http://ivanpig.github.io/2014/11/28/pigtheme.html"/>
        <updated>2014-11-28T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/11/28/pigtheme</id>
        <content type="html">&lt;h1&gt;LightTable Theme&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;自用LightTable代码高亮配色,修改自solarized!&lt;/li&gt;
&lt;li&gt;从LightTable插件管理搜索pigtheme下载即可!&lt;/li&gt;
&lt;li&gt;主题修改为pigtheme生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/lighttable/shot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;LightTable Theme&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;自用LightTable代码高亮配色,修改自solarized!&lt;/li&gt;
&lt;li&gt;从LightTable插件管理搜索pigtheme下载即可!&lt;/li&gt;
&lt;li&gt;主题修改为pigtheme生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/lighttable/shot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure进阶:使用Clojure编写文字冒险游戏</title>
        <link href="http://ivanpig.github.io/2014/10/02/clojure_spels.html"/>
        <updated>2014-10-02T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/10/02/clojure_spels</id>
        <content type="html">&lt;p&gt;本文翻译自:&lt;a href=&quot;http://www.lisperati.com/clojure-spels/casting.html&quot;&gt;Casting SPELs in Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;p&gt;任何学过Lisp的人都会说List和其它语言有很大的不同.它有很多不可思议的地方.本文将告诉你它有哪些独特之处!&lt;/p&gt;

&lt;p&gt;本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和
Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程.&lt;/p&gt;

&lt;p&gt;在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通用的.我们会指出Clojure特有的内容.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已经被安装过了.如果是Linux或者Windows系统,你需要到&lt;a href=&quot;http://java.sun.com/javase/downloads/index.jsp&quot;&gt;Oracle Java官网&lt;/a&gt;下载对应版本的Java.&lt;/p&gt;

&lt;p&gt;而Clojure,你可以从它的&lt;a href=&quot;http://clojure.org/&quot;&gt;官网&lt;/a&gt;获得最新版本.下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;java -jar clojure.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有问题,那么你将会看到Clojure输出提示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;Clojure 1.6.0
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;教程中有很多Clojure代码片段,类似下面的样子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;'(these kinds of boxes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教程,你将会有一个你自己的文字冒险游戏了!&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;语法和语义&lt;/h1&gt;

&lt;p&gt;每一个编程语言是由语法和语义组成的.语法是组成你的程序的骨架,你必须要遵循它们,这样编译器才能知道你的程序里什么是什么,比如说什么是函数,什么是变量,等等!&lt;/p&gt;

&lt;p&gt;而语义是个比较&quot;随便&quot;的东西,例如你的程序里有哪些不同的命令,或者在程序的哪个部分能访问到哪些变量!这里Lisp比较特别的地方就是,Lisp的语法比其它任何语言都要简单.&lt;/p&gt;

&lt;p&gt;首先,Lisp语法规定,所有传递给Lisp编译器的文本需要是个list,当然这个list可以无限嵌套.每个list都必须使用括号包裹.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外,Lisp编译器使用两种模式来读取你的代码:代码模式和数据模式.当你在数据模式下,你可以将任何东西塞到你的list中.但是在代码模式下,你的list需要是叫做form的特殊类型.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;form也是个list,不过它的第一个符号被lisp编译器特殊对待了---一般被当做函数的名字.在这种情况下,编译器会将list中的其它元素作为函数参数传递给这个函数.默认情况下,编译器运行在代码模式下,除非你特意告诉它进入数据模式.&lt;/p&gt;

&lt;h1&gt;为我们的游戏世界定义数据&lt;/h1&gt;

&lt;p&gt;为了进一步的学习form,让我们来创建一些form,来定义我们游戏世界里的数据.首先,我们的游戏有一些对象,玩家可以使用他们--让我们来定义吧:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def objects '(whiskey-bottle bucket frog chain))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们来看看这行代码是什么意思:Lisp编译器总是使用代码模式来读取内容,所以第一个符号(这里是def),肯定是个命令.&lt;/p&gt;

&lt;p&gt;在这里,它的作用就是给某个变量设值:这里变量就是objects,而值是一个包含四个对象的list.这个list是数据(我们可不想编译器去调用一个叫做whiskey-bottle的函数),所以在读取这个list时
我们需要将其设值为数据模式.在list前面的哪个单引号就是干这个的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;def命令就是用来设值的(如果你学过Common Lisp,你应该会知道它和CommonLisp中的setf命令等价,但是Clojure中没有setf命令)&lt;/p&gt;

&lt;p&gt;现在我们在游戏里定义了一些对象,现在让我们来定义一下游戏地图.下面是我们的游戏世界:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个简单的游戏里,只有三个地点:一个房子,它包含起居室,阁楼和花园.让我们来定义一个新变量,叫做game-map来描述这个游戏地图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def game-map (hash-map
   'living-room '((you are in the living room
                   of a wizards house - there is a wizard
                   snoring loudly on the couch -)
                  (west door garden)
                  (upstairs stairway attic))
   'garden '((you are in a beautiful garden -
              there is a well in front of you -)
             (east door living-room))
   'attic '((you are in the attic of the
             wizards house - there is a giant
             welding torch in the corner -)
            (downstairs stairway living-room))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个map包含了三个地点的所有重要信息:每个地点都有个独立的名字,一个简短的描述,描述了我们能在这些地点看到什么,以及如何进入此处或从此处出去.&lt;/p&gt;

&lt;p&gt;请注意这个包含了丰富信息的变量是如何定义的---Lisp程序员更喜欢用小巧的代码片段而不是一大片代码,因为小代码更容易理解.&lt;/p&gt;

&lt;p&gt;现在我们有了一个地图和一组对象,让我们来创建另一个变量,来描述这些对象在地图的哪些地方.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def object-locations (hash-map
                       'whiskey-bottle 'living-room
                       'bucket 'living-room
                       'chain 'garden
                       'frog 'garden))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们将每个对象和地点进行了关联.Clojure提供了Map这个数据结构.Map使用hash-map函数来创建,它需要一组参数类似(key1 value1 keys value2...).我们的game-map变量也是个Map---三个key分别是living-room,garden和attic.&lt;/p&gt;

&lt;p&gt;我们定义了游戏世界,以及游戏世界中的对象,现在就剩下一件事了,就是描述玩家的地点!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def location 'living-room)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定,现在让我们来定义游戏操作吧!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;环顾我们的游戏世界&lt;/h1&gt;

&lt;p&gt;我们想要的第一个命令能够告诉我们当前地点的描述.那么我们该怎么定义这个函数呢?它要知道我们想要描述的地点以及能够从map中查找地点的描述.如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-location [location game-map]
  (first (location game-map)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defn定义了一个函数.函数的名字叫做describe-location,它需要两个参数:地点和游戏地图.这两个变量在函数定义的括号内,所以它们是局部变量,因此对于全局的location和game-map没有关系.&lt;/p&gt;

&lt;p&gt;注意到了吗?Lisp中的函数与其它语言中的函数定义相比,更像是数学中的函数:它不打印信息或者弹出消息框:它所作的就是返回结果.&lt;/p&gt;

&lt;p&gt;我们假设现在我们在起居室里!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了能找到起居室的描述,describe-locatin函数首先需要从地图中找到起居室.(location game-map)就是进行从game-map中查找内容的,并返回起居室的描述.然后first命令来处理返回值,取得返回的list的第一个元素,这个就是起居室的描述了. 现在我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(describe-location 'living-room game-map)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt; user=&amp;gt; (describe-location 'living-room game-map)
 (you are in the living-room of a wizard's house -
 there is a wizard snoring loudly on the couch -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很完美!这就是我们要的结果!请注意我们在living-room前添加了一个单引号,因为这个符号是地点map的一个名称!但是,为什么我们没有在game-map前面添加单引号呢?这是因为我们需要编译器去查询这个符号所指向的数据(就是那个map)&lt;/p&gt;

&lt;h1&gt;函数式编码风格&lt;/h1&gt;

&lt;p&gt;你可能已经发现了describe-location函数有几个让人不太舒服的地方.&lt;/p&gt;

&lt;p&gt;第一,为什么要传递位置和map参数,而不是直接使用已经定义的全局变量?原因是Lisp程
序员喜欢写函数式风格的代码.函数式风格的代码,主要遵循下面三条规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只读取函数传递的参数或在函数内创建的变量&lt;/li&gt;
&lt;li&gt;不改变已经被设值的变量的值&lt;/li&gt;
&lt;li&gt;除了返回值,不去影响函数外的任何内容&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你也许会怀疑在这种限制下你还能写代码吗?答案是:可以!为什么很多人对这些规则感到疑惑呢?一个很重要的原因是:遵循此种风格的代码更加的引用透明(referential transparency):这意味着,对于给定的代码,你传入相同的参数,永远返回相同的结果---这能减少程序的错误,也能提高程序的生产力!&lt;/p&gt;

&lt;p&gt;当然了,你也会有一些非函数式风格的代码,因为不这么做,你无法和其它用户或外部内容进行交互.教程后面会有这些函数,他们不遵循上面的规则.&lt;/p&gt;

&lt;p&gt;describe-location函数的另一个问题是,它没告诉我们怎么进入一个位置或者怎么从某个位置出来.让我们来编写这样的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-path [path]
  `(there is a ~(second path) going ~(first path) from here -))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数看起来很明了:它看起来更像是数据而不是函数.我们先来尝试调用它,看它做了些什么:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(describe-path '(west door garden))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (describe-path '(west door garden))
(user/there user/is user/a door user/going west user/from user/here clojure.core/-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是什么?!结果看起来很乱,包含了很多的/和一些其它的文字!这是因为Clojure会将命名空间的名字添加到表达式的前面.我们这里不深究细节,只给你提供消除这些内容的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn spel-print [list] (map (fn [x] (symbol (name x))) list))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改调用方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spel-print (describe-path '(west door garden)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (spel-print (describe-path '(west door garden)))
(there is a door going west from here -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在结果很清晰了:这个函数接收一个描述路径的list然后将其解析到一个句子里面.我们回过头来看这个函数,这个函数和它产生的数据非常的像:它就是拼接第一个和第二个list的元素到语句中!它是怎么做到的?使用语法quote!&lt;/p&gt;

&lt;p&gt;还记得我们使用quote来从代码模式切换到数据模式吗?语法quote的功能类似,但是还不只这样.在语法quote里,我们还能使用'\~'再次从数据模式切换回代码模式.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;语法quote是List的一个很强大的功能!它能使我们的代码看起来像它创建的数据.这在函数式编码中很常见:创建这种样子的函数,使得我们的代码更易读也更稳健:&lt;/p&gt;

&lt;p&gt;只要数据不变,函数就不需要修改.想象一下,你能否在VB或C中编写类似的代码?你可能需要将文字切成小块,然后在一点点的组装-这和数据本身看起来差距很大,更别说代码的稳健性了!&lt;/p&gt;

&lt;p&gt;现在我们能描述一个路径,但是一个地点可能会有多个路径,所以让我们来创建一个函数叫做describe-paths:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-paths [location game-map]
  (apply concat (map describe-path (rest (get game-map location)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数使用了另一个在函数式编程中很常用的技术:高阶函数.apply和map这两个函数能将其它的函数作为参数.map函数将另一个函数分别作用到list中的每个对象上,这里是调用describe-path函数.apply concat是为了减少多余的括号,没有多少功能性操作!我们来试试新函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spel-print (describe-paths 'living-room game-map))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (spel-print (describe-paths 'living-room game-map))
(there is a door going west from here -
there is a stairway going upstairs from here -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;漂亮!&lt;/p&gt;

&lt;p&gt;最后,我们还剩下一件事要做:描述某个地点的某个对象!我们先写个帮助函数来告诉我们在某个地方是否有某个对象!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn is-at? [obj loc obj-loc] (= (obj obj-loc) loc))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=也是个函数,它判断对象的地点是否和当前地点相同!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来尝试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(is-at? 'whiskey-bottle 'living-room object-locations)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (is-at? 'whiskey-bottle 'living-room object-locations)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果是true,意味着whiskey-bottle在起居室.&lt;/p&gt;

&lt;p&gt;现在让我们来使用这个函数描述地板:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-floor [loc objs obj-loc]
  (apply concat (map (fn [x]
                       `(you see a ~x on the floor -))
                     (filter (fn [x]
                               (is-at? x loc obj-loc)) objs))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数包含了很多新事物:首先,它有匿名函数(fn定义的函数).第一个fn干的事,和下面的函数做的事情是一样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn blabla [x] `(you see a ~x on the floor.))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将这个blabla函数传递给map函数.filter函数是过滤掉那些在当前位置没有出现的物体.我们来试一下新函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spel-print (describe-floor 'living-room objects object-locations))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (spel-print (describe-floor 'living-room objects object-locations))
(you see a whiskey-bottle on the floor - you see a bucket on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,让我们来将这些函数串联起来,定义一个叫look的函数,使用全局变量(这个函数就不是函数式的了!)来描述所有的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn look []
  (spel-print (concat (describe-location location game-map)
          (describe-paths location game-map)
          (describe-floor location objects object-locations))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (look)
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很酷吧!&lt;/p&gt;

&lt;h1&gt;环游我们的游戏世界&lt;/h1&gt;

&lt;p&gt;好了,现在我们能看我们的世界了,让我们来写一些代码来环游我们的世界.walk-direction包含了一些方向可以使我们走到那里:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn walk-direction [direction]
  (let [next (first (filter (fn [x] (= direction (first x)))
                            (rest (location game-map))))]
    (cond next (do (def location (nth next 2)) (look))
          :else '(you cannot go that way -))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的let用来创建局部变量next,用来描述玩家的方向.rest返回一个list,包含原list中除了第一个元素外的全部元素.如果用户输入了错误的方向,next会返回
().&lt;/p&gt;

&lt;p&gt;cond类似于if-then条件:每个cond都包含一个值,lisp检查该值是否为真,如果为真则执行其后的动作.在这里,如果下一个位置不是nil,则会定义玩家的location到新位置,然后告诉玩家该位置的描述!如果next是nil,则告诉玩家,无法到达,请重试:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(walk-direction 'west)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (walk-direction 'west)
(you are in a beautiful garden -
there is a well in front of you -
there is a door going east from here -
you see a frog on the floor -
you see a chain on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,我们通过创建look函数来简化描述.walk-direction也是类似的功能.但是它需要输入方向,而且还有个quote.我们能否告诉编译器west仅仅是个数据,而不是代码呢?&lt;/p&gt;

&lt;h1&gt;构建SPELs&lt;/h1&gt;

&lt;p&gt;现在我们开始学习Lisp中一个很强大的功能:创建SPELs!SPEL是&quot;语义增强逻辑&quot;的简称,它能够从语言级别,按照我们的需求定制,对我们的代码添加新的行为-这是Lisp最为强大的一部分.为了开启SPELs,我们需要先激活Lisp编译器的SPEL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro defspel [&amp;amp; rest] `(defmacro ~@rest))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,我们来编写我们的SPEL,叫做walk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defspel walk [direction] `(walk-direction '~direction))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码干了什么?它告诉编译器walk不是实际的名称,实际的名字叫walk-direction,并且direction前面有个quote.SPEL的主要功能就是能在我们的代码被编译器编译之前插入一些内容!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意到了吗?这段代码和我们之前写的describe-path很类似:在Lisp中,不只是代码和数据看起来很像,代码和特殊形式对于编译器来说也是一样的-高度的统一带来简明的设计!我们来试试新代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(walk east)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (walk east)
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉好多了! 现在我们来创建一个命令来收集游戏里的物品&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn pickup-object [object]
  (cond (is-at? object location object-locations)
        (do
          (def object-locations (assoc object-locations object 'body))
          `(you are now carrying the ~object))
        :else '(you cannot get that.)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数检查物品是否在当前地点的地上-如果在,则将它放到list里面,并返回成功提示!否则提示失败! 现在我们来创建另一个SPEL来简化这条命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defspel pickup [object] `(spel-print (pickup-object '~object)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(pickup whiskey-bottle)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (pickup whiskey-bottle)
(you are now carrying the whiskey-bottle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来添加更多有用的命令-首先,一个能让我们查看我们捡到的物品的函 数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn inventory []
  (filter (fn [x] (is-at? x 'body object-locations)) objects))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及一个检查我们是否有某个物品的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn have? [object]
   (some #{object} (inventory)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建特殊操作&lt;/h1&gt;

&lt;p&gt;现在我们只剩下一件事情需要做了:添加一些特殊动作,使得玩家能够赢得游戏.第一条命令是让玩家在阁楼里给水桶焊接链条.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def chain-welded false)

(defn weld [subject object]
  (cond (and (= location 'attic)
             (= subject 'chain)
             (= object 'bucket)
             (have? 'chain)
             (have? 'bucket)
             (not chain-welded))
        (do (def chain-welded true)
            '(the chain is now securely welded to the bucket -))
        :else '(you cannot weld like that -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们创建了一个新的全局变量来进行判断,我们是否进行了此操作.然后我们创建了一个weld函数,来确认此操作的条件是否完成,如果已完成则进行此操作.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_12.jpg&quot; alt=&quot;&quot; /&gt; 来试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(weld 'chain 'bucket)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (weld 'chain 'bucket)
(you cannot weld like that -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops...我们没有水桶,也没有链条,是吧?周围也没有焊接的机器!&lt;/p&gt;

&lt;p&gt;现在,让我们创建一条命令来将链条和水桶放到井里:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def bucket-filled false)

(defn dunk [subject object]
  (cond (and (= location 'garden)
             (= subject 'bucket)
             (= object 'well)
             (have? 'bucket)
             chain-welded)
        (do (def bucket-filled true)
            '(the bucket is now full of water))
        :else '(you cannot dunk like that -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到了吗?这个命令和weld命令看起来好像!两条命令都需要检查位置,物体和对象!但是它们还是有不同,以至于我们不能将它们抽到一个函数里.太可惜了!&lt;/p&gt;

&lt;p&gt;但是...这可是Lisp.我们不止能写函数,还能写SPEL!我们来创建了SPEL来处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defspel game-action [command subj obj place &amp;amp; args]
  `(defspel ~command [subject# object#]
     `(spel-print (cond (and (= location '~'~place)
                             (= '~subject# '~'~subj)
                             (= '~object# '~'~obj)
                             (have? '~'~subj))
                        ~@'~args
                        :else '(i cannot ~'~command like that -)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常复杂的SPEL!它有很多怪异的quote,语法quote,逗号以及很多怪异的符号!更重要的是他是一个构建SPEL的SPEL!!即使是很有经验的Lisp程序员,也需要费下脑细胞才能写出这么个玩样!!(这里我们不管)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个SPEL的只是向你展示,你是否够聪明来理解这么复杂的SPEL.而且,即使这段代码很丑陋,如果它只需要写一次,并且能生成几百个命令,那么也是可以接受的!&lt;/p&gt;

&lt;p&gt;让我们使用这个新的SPEL来替换我们的weld命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(game-action weld chain bucket attic
   (cond (and (have? 'bucket) (def chain-welded true))
              '(the chain is now securely welded to the bucket -)
         :else '(you do not have a bucket -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来看看这条命令变得多容易理解:game-action这个SPEL使得我们能编写我们想要的核心代码,而不需要额外的信息.这就像我们创建了我们自己的专门创建游戏命令的编程语言.使用SPEL创建伪语言称为领域特定语言编程(DSL),它使得你的编码更加的快捷优美!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(weld chain bucket)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (weld chain bucket)
(you do not have a chain -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;...我们还没有做好焊接前的准备工作,但是这条命令生效了!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们重写dunk命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(game-action dunk bucket well garden
             (cond chain-welded
                   (do (def bucket-filled true)
                       '(the bucket is now full of water))
                   :else '(the water level is too low to reach -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意weld命令需要检验我们是否有物体,但是dunk不需要.我们的game-action这个SPEL使得这段代码易写易读.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_15.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后,就是将水泼到巫师身上:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(game-action splash bucket wizard living-room
             (cond (not bucket-filled) '(the bucket has nothing in it -)
                   (have? 'frog) '(the wizard awakens and sees that you stole
                                       his frog -
                                       he is so upset he banishes you to the
                                       netherworlds - you lose! the end -)
                   :else '(the wizard awakens from his slumber and greets you
                               warmly -
                               he hands you the magic low-carb donut - you win!
                               the end -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_16.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在你已经编写完成了一个文字冒险游戏了!&lt;/p&gt;

&lt;p&gt;点击&lt;a href=&quot;http://www.lisperati.com/clojure-spels/cheat.html&quot;&gt;这里&lt;/a&gt;是完整的游戏.&lt;/p&gt;

&lt;p&gt;点击&lt;a href=&quot;http://www.lisperati.com/clojure-spels/code.html&quot;&gt;这里&lt;/a&gt;是代码.&lt;/p&gt;

&lt;p&gt;为了使教程尽可能的简单,很多Lisp的执行细节被忽略了,所以最后,让我们来看看这些细节!&lt;/p&gt;

&lt;h1&gt;附录&lt;/h1&gt;

&lt;p&gt;现在,我们来聊一聊被忽略的细节!&lt;/p&gt;

&lt;p&gt;首先,Clojure有一套很成熟的定义变量以及改变变量值的系统.在此教程中,我们只使用了def来设置和改变全局变量的值.而在真正的Clojure代码里,你不会这么做.取而代之,你会使用&lt;a href=&quot;http://clojure.org/refs&quot;&gt;Refs&lt;/a&gt;,&lt;a href=&quot;http://clojure.org/atoms&quot;&gt;Atoms和&lt;/a&gt;&lt;a href=&quot;http://clojure.org/agents&quot;&gt;Agents&lt;/a&gt;,它们提供了更清晰,以及线程安全的方式来管理数据.&lt;/p&gt;

&lt;p&gt;另一个问题就是我们在代码中大量使用了符号(symbol)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;'(this is not how Lispers usually write text)
&quot;Lispers write text using double quotes&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;符号在Clojure有特殊含义,主要是用来持有函数,变量或其它内容的.所以,在Lisp中将符号作为文本信息描述是很奇怪的事情!使用字符串来显示文本信息可以避免这样的尴尬!不过,使用字符串的话,在教程里就没法讲很多关于符号的内容了!&lt;/p&gt;

&lt;p&gt;还有就是SPEL在Lisp里面更普遍的叫法是&quot;宏&quot;,使用defmacro来定义,但是这个名字不易于教学,所以没有提及.你可以阅读&lt;a href=&quot;http://www.lisperati.com/clojure-spels/no_macros.html&quot;&gt;此文&lt;/a&gt;,这是我为什么没有使用&quot;宏&quot;这个名字的原因.&lt;/p&gt;

&lt;p&gt;最后,在编写类似game-action这样的SPEL的时候,很可能会发生命名重复的问题.当你编写了足够多的lisp的时候,你会越来越能体会到这个问题了.&lt;/p&gt;

&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;后面我该阅读哪些内容来扩充我的Lisp知识? A.
在&lt;a href=&quot;http://www.cliki.net/Lisp%2520books&quot;&gt;cliki网站&lt;/a&gt;有很多Lisp书籍可以下载.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果你对于理论上的内容很感兴趣,那么我推荐Paul Graham的 &lt;a href=&quot;http://www.paulgraham.com/onlisp.html&quot;&gt;On Lisp&lt;/a&gt;电子书,它是免费的.他网站上的一些短文也很精彩.&lt;/p&gt;

&lt;p&gt;如果你对实际应用比较感兴趣,那么大多数Lisp程序员对Perter Seibel编写的&quot;Practical Common Lisp&quot;这本书推崇有加,你可以从&lt;a href=&quot;http://www.gigamonkeys.com/book/&quot;&gt;这里&lt;/a&gt;获得&lt;/p&gt;

&lt;h1&gt;为什么没有使用&quot;宏&quot;这个词&lt;/h1&gt;

&lt;p&gt;编写这个教程的一个意图是使用宏来解决真实的难题.而经常的,当我向没有Lisp经验的人解释宏这个概念的时候,我得到的答复往往是,&quot;哦!C++里也有宏&quot;.当发生这种事情的时候,我就很难去解释宏的概念了.的确,Lisp中的宏和C++中的宏的确有几分相似,它们都是为了能通过编译器来改进代码的编写...&lt;/p&gt;

&lt;p&gt;...所以,假设一下,如果John McCarthy使用了&quot;add&quot;而不是&quot;cons&quot;这个词来将元素添加到list中:我就真的很难解释cons是如何工作的了!&lt;/p&gt;

&lt;p&gt;所以,我决定在此文中使用一个新的词汇:SPEL,语义增强逻辑的简称,它更易理解
一些:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它解释了Lisp宏的核心功能,能改变Lisp运行环境的行为&lt;/li&gt;
&lt;li&gt;SPEL这个术语可以被用来很高雅的解释很多语言上观念.&lt;/li&gt;
&lt;li&gt;这个术语不会导致Lisp中的宏与其它的宏被混为一谈&lt;/li&gt;
&lt;li&gt;SPEL这个词重复的可能性非常低.Google搜索&quot;macro 或者 macros 程序 -lisp -scheme&quot;返回大概1150000条结果.而搜索&quot;spel 或者 spels 程序 -lisp -scheme&quot;值返回28400条结果.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以,我希望,作为一个Lisp程序员,你能接受这个术语.当然了,像这样的新词汇会被接受的可能性非常低.&lt;/p&gt;

&lt;p&gt;如果你有一个库或者是一个Lisp实现者,请先放下你手头上的工作,先在你的库里,添加下面这行代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro defspel [&amp;amp; rest] `(defmacro ~@rest))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;译者感想&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;本人对Lisp的宏还是有些了解的,所以个人无法接受SPEL这个新词汇&lt;/li&gt;
&lt;li&gt;且SPEL使得代码不易阅读,就game-action这个SPEL来说,使用了两层,而使用宏只需要一层&lt;/li&gt;
&lt;li&gt;附录中是我使用Clojure的惯用法重新改写的代码,且文字翻译成了中文.以及使用了宏而不是SPEL.各位可比较,自行选择&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;/assets/clojure/game.zip&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;本文翻译自:&lt;a href=&quot;http://www.lisperati.com/clojure-spels/casting.html&quot;&gt;Casting SPELs in Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;p&gt;任何学过Lisp的人都会说List和其它语言有很大的不同.它有很多不可思议的地方.本文将告诉你它有哪些独特之处!&lt;/p&gt;

&lt;p&gt;本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和
Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程.&lt;/p&gt;

&lt;p&gt;在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通用的.我们会指出Clojure特有的内容.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已经被安装过了.如果是Linux或者Windows系统,你需要到&lt;a href=&quot;http://java.sun.com/javase/downloads/index.jsp&quot;&gt;Oracle Java官网&lt;/a&gt;下载对应版本的Java.&lt;/p&gt;

&lt;p&gt;而Clojure,你可以从它的&lt;a href=&quot;http://clojure.org/&quot;&gt;官网&lt;/a&gt;获得最新版本.下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;java -jar clojure.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有问题,那么你将会看到Clojure输出提示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;Clojure 1.6.0
user=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;教程中有很多Clojure代码片段,类似下面的样子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;'(these kinds of boxes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教程,你将会有一个你自己的文字冒险游戏了!&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;语法和语义&lt;/h1&gt;

&lt;p&gt;每一个编程语言是由语法和语义组成的.语法是组成你的程序的骨架,你必须要遵循它们,这样编译器才能知道你的程序里什么是什么,比如说什么是函数,什么是变量,等等!&lt;/p&gt;

&lt;p&gt;而语义是个比较&quot;随便&quot;的东西,例如你的程序里有哪些不同的命令,或者在程序的哪个部分能访问到哪些变量!这里Lisp比较特别的地方就是,Lisp的语法比其它任何语言都要简单.&lt;/p&gt;

&lt;p&gt;首先,Lisp语法规定,所有传递给Lisp编译器的文本需要是个list,当然这个list可以无限嵌套.每个list都必须使用括号包裹.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外,Lisp编译器使用两种模式来读取你的代码:代码模式和数据模式.当你在数据模式下,你可以将任何东西塞到你的list中.但是在代码模式下,你的list需要是叫做form的特殊类型.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;form也是个list,不过它的第一个符号被lisp编译器特殊对待了---一般被当做函数的名字.在这种情况下,编译器会将list中的其它元素作为函数参数传递给这个函数.默认情况下,编译器运行在代码模式下,除非你特意告诉它进入数据模式.&lt;/p&gt;

&lt;h1&gt;为我们的游戏世界定义数据&lt;/h1&gt;

&lt;p&gt;为了进一步的学习form,让我们来创建一些form,来定义我们游戏世界里的数据.首先,我们的游戏有一些对象,玩家可以使用他们--让我们来定义吧:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def objects '(whiskey-bottle bucket frog chain))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们来看看这行代码是什么意思:Lisp编译器总是使用代码模式来读取内容,所以第一个符号(这里是def),肯定是个命令.&lt;/p&gt;

&lt;p&gt;在这里,它的作用就是给某个变量设值:这里变量就是objects,而值是一个包含四个对象的list.这个list是数据(我们可不想编译器去调用一个叫做whiskey-bottle的函数),所以在读取这个list时
我们需要将其设值为数据模式.在list前面的哪个单引号就是干这个的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;def命令就是用来设值的(如果你学过Common Lisp,你应该会知道它和CommonLisp中的setf命令等价,但是Clojure中没有setf命令)&lt;/p&gt;

&lt;p&gt;现在我们在游戏里定义了一些对象,现在让我们来定义一下游戏地图.下面是我们的游戏世界:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个简单的游戏里,只有三个地点:一个房子,它包含起居室,阁楼和花园.让我们来定义一个新变量,叫做game-map来描述这个游戏地图:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def game-map (hash-map
   'living-room '((you are in the living room
                   of a wizards house - there is a wizard
                   snoring loudly on the couch -)
                  (west door garden)
                  (upstairs stairway attic))
   'garden '((you are in a beautiful garden -
              there is a well in front of you -)
             (east door living-room))
   'attic '((you are in the attic of the
             wizards house - there is a giant
             welding torch in the corner -)
            (downstairs stairway living-room))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个map包含了三个地点的所有重要信息:每个地点都有个独立的名字,一个简短的描述,描述了我们能在这些地点看到什么,以及如何进入此处或从此处出去.&lt;/p&gt;

&lt;p&gt;请注意这个包含了丰富信息的变量是如何定义的---Lisp程序员更喜欢用小巧的代码片段而不是一大片代码,因为小代码更容易理解.&lt;/p&gt;

&lt;p&gt;现在我们有了一个地图和一组对象,让我们来创建另一个变量,来描述这些对象在地图的哪些地方.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def object-locations (hash-map
                       'whiskey-bottle 'living-room
                       'bucket 'living-room
                       'chain 'garden
                       'frog 'garden))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们将每个对象和地点进行了关联.Clojure提供了Map这个数据结构.Map使用hash-map函数来创建,它需要一组参数类似(key1 value1 keys value2...).我们的game-map变量也是个Map---三个key分别是living-room,garden和attic.&lt;/p&gt;

&lt;p&gt;我们定义了游戏世界,以及游戏世界中的对象,现在就剩下一件事了,就是描述玩家的地点!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def location 'living-room)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定,现在让我们来定义游戏操作吧!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;环顾我们的游戏世界&lt;/h1&gt;

&lt;p&gt;我们想要的第一个命令能够告诉我们当前地点的描述.那么我们该怎么定义这个函数呢?它要知道我们想要描述的地点以及能够从map中查找地点的描述.如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-location [location game-map]
  (first (location game-map)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defn定义了一个函数.函数的名字叫做describe-location,它需要两个参数:地点和游戏地图.这两个变量在函数定义的括号内,所以它们是局部变量,因此对于全局的location和game-map没有关系.&lt;/p&gt;

&lt;p&gt;注意到了吗?Lisp中的函数与其它语言中的函数定义相比,更像是数学中的函数:它不打印信息或者弹出消息框:它所作的就是返回结果.&lt;/p&gt;

&lt;p&gt;我们假设现在我们在起居室里!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了能找到起居室的描述,describe-locatin函数首先需要从地图中找到起居室.(location game-map)就是进行从game-map中查找内容的,并返回起居室的描述.然后first命令来处理返回值,取得返回的list的第一个元素,这个就是起居室的描述了. 现在我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(describe-location 'living-room game-map)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt; user=&amp;gt; (describe-location 'living-room game-map)
 (you are in the living-room of a wizard's house -
 there is a wizard snoring loudly on the couch -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很完美!这就是我们要的结果!请注意我们在living-room前添加了一个单引号,因为这个符号是地点map的一个名称!但是,为什么我们没有在game-map前面添加单引号呢?这是因为我们需要编译器去查询这个符号所指向的数据(就是那个map)&lt;/p&gt;

&lt;h1&gt;函数式编码风格&lt;/h1&gt;

&lt;p&gt;你可能已经发现了describe-location函数有几个让人不太舒服的地方.&lt;/p&gt;

&lt;p&gt;第一,为什么要传递位置和map参数,而不是直接使用已经定义的全局变量?原因是Lisp程
序员喜欢写函数式风格的代码.函数式风格的代码,主要遵循下面三条规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只读取函数传递的参数或在函数内创建的变量&lt;/li&gt;
&lt;li&gt;不改变已经被设值的变量的值&lt;/li&gt;
&lt;li&gt;除了返回值,不去影响函数外的任何内容&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;你也许会怀疑在这种限制下你还能写代码吗?答案是:可以!为什么很多人对这些规则感到疑惑呢?一个很重要的原因是:遵循此种风格的代码更加的引用透明(referential transparency):这意味着,对于给定的代码,你传入相同的参数,永远返回相同的结果---这能减少程序的错误,也能提高程序的生产力!&lt;/p&gt;

&lt;p&gt;当然了,你也会有一些非函数式风格的代码,因为不这么做,你无法和其它用户或外部内容进行交互.教程后面会有这些函数,他们不遵循上面的规则.&lt;/p&gt;

&lt;p&gt;describe-location函数的另一个问题是,它没告诉我们怎么进入一个位置或者怎么从某个位置出来.让我们来编写这样的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-path [path]
  `(there is a ~(second path) going ~(first path) from here -))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数看起来很明了:它看起来更像是数据而不是函数.我们先来尝试调用它,看它做了些什么:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(describe-path '(west door garden))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (describe-path '(west door garden))
(user/there user/is user/a door user/going west user/from user/here clojure.core/-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是什么?!结果看起来很乱,包含了很多的/和一些其它的文字!这是因为Clojure会将命名空间的名字添加到表达式的前面.我们这里不深究细节,只给你提供消除这些内容的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn spel-print [list] (map (fn [x] (symbol (name x))) list))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改调用方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spel-print (describe-path '(west door garden)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (spel-print (describe-path '(west door garden)))
(there is a door going west from here -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在结果很清晰了:这个函数接收一个描述路径的list然后将其解析到一个句子里面.我们回过头来看这个函数,这个函数和它产生的数据非常的像:它就是拼接第一个和第二个list的元素到语句中!它是怎么做到的?使用语法quote!&lt;/p&gt;

&lt;p&gt;还记得我们使用quote来从代码模式切换到数据模式吗?语法quote的功能类似,但是还不只这样.在语法quote里,我们还能使用'\~'再次从数据模式切换回代码模式.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;语法quote是List的一个很强大的功能!它能使我们的代码看起来像它创建的数据.这在函数式编码中很常见:创建这种样子的函数,使得我们的代码更易读也更稳健:&lt;/p&gt;

&lt;p&gt;只要数据不变,函数就不需要修改.想象一下,你能否在VB或C中编写类似的代码?你可能需要将文字切成小块,然后在一点点的组装-这和数据本身看起来差距很大,更别说代码的稳健性了!&lt;/p&gt;

&lt;p&gt;现在我们能描述一个路径,但是一个地点可能会有多个路径,所以让我们来创建一个函数叫做describe-paths:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-paths [location game-map]
  (apply concat (map describe-path (rest (get game-map location)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数使用了另一个在函数式编程中很常用的技术:高阶函数.apply和map这两个函数能将其它的函数作为参数.map函数将另一个函数分别作用到list中的每个对象上,这里是调用describe-path函数.apply concat是为了减少多余的括号,没有多少功能性操作!我们来试试新函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spel-print (describe-paths 'living-room game-map))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (spel-print (describe-paths 'living-room game-map))
(there is a door going west from here -
there is a stairway going upstairs from here -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;漂亮!&lt;/p&gt;

&lt;p&gt;最后,我们还剩下一件事要做:描述某个地点的某个对象!我们先写个帮助函数来告诉我们在某个地方是否有某个对象!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn is-at? [obj loc obj-loc] (= (obj obj-loc) loc))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=也是个函数,它判断对象的地点是否和当前地点相同!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来尝试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(is-at? 'whiskey-bottle 'living-room object-locations)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (is-at? 'whiskey-bottle 'living-room object-locations)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果是true,意味着whiskey-bottle在起居室.&lt;/p&gt;

&lt;p&gt;现在让我们来使用这个函数描述地板:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn describe-floor [loc objs obj-loc]
  (apply concat (map (fn [x]
                       `(you see a ~x on the floor -))
                     (filter (fn [x]
                               (is-at? x loc obj-loc)) objs))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数包含了很多新事物:首先,它有匿名函数(fn定义的函数).第一个fn干的事,和下面的函数做的事情是一样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn blabla [x] `(you see a ~x on the floor.))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将这个blabla函数传递给map函数.filter函数是过滤掉那些在当前位置没有出现的物体.我们来试一下新函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spel-print (describe-floor 'living-room objects object-locations))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (spel-print (describe-floor 'living-room objects object-locations))
(you see a whiskey-bottle on the floor - you see a bucket on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,让我们来将这些函数串联起来,定义一个叫look的函数,使用全局变量(这个函数就不是函数式的了!)来描述所有的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn look []
  (spel-print (concat (describe-location location game-map)
          (describe-paths location game-map)
          (describe-floor location objects object-locations))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们来试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (look)
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很酷吧!&lt;/p&gt;

&lt;h1&gt;环游我们的游戏世界&lt;/h1&gt;

&lt;p&gt;好了,现在我们能看我们的世界了,让我们来写一些代码来环游我们的世界.walk-direction包含了一些方向可以使我们走到那里:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn walk-direction [direction]
  (let [next (first (filter (fn [x] (= direction (first x)))
                            (rest (location game-map))))]
    (cond next (do (def location (nth next 2)) (look))
          :else '(you cannot go that way -))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的let用来创建局部变量next,用来描述玩家的方向.rest返回一个list,包含原list中除了第一个元素外的全部元素.如果用户输入了错误的方向,next会返回
().&lt;/p&gt;

&lt;p&gt;cond类似于if-then条件:每个cond都包含一个值,lisp检查该值是否为真,如果为真则执行其后的动作.在这里,如果下一个位置不是nil,则会定义玩家的location到新位置,然后告诉玩家该位置的描述!如果next是nil,则告诉玩家,无法到达,请重试:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(walk-direction 'west)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (walk-direction 'west)
(you are in a beautiful garden -
there is a well in front of you -
there is a door going east from here -
you see a frog on the floor -
you see a chain on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,我们通过创建look函数来简化描述.walk-direction也是类似的功能.但是它需要输入方向,而且还有个quote.我们能否告诉编译器west仅仅是个数据,而不是代码呢?&lt;/p&gt;

&lt;h1&gt;构建SPELs&lt;/h1&gt;

&lt;p&gt;现在我们开始学习Lisp中一个很强大的功能:创建SPELs!SPEL是&quot;语义增强逻辑&quot;的简称,它能够从语言级别,按照我们的需求定制,对我们的代码添加新的行为-这是Lisp最为强大的一部分.为了开启SPELs,我们需要先激活Lisp编译器的SPEL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro defspel [&amp;amp; rest] `(defmacro ~@rest))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,我们来编写我们的SPEL,叫做walk:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defspel walk [direction] `(walk-direction '~direction))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码干了什么?它告诉编译器walk不是实际的名称,实际的名字叫walk-direction,并且direction前面有个quote.SPEL的主要功能就是能在我们的代码被编译器编译之前插入一些内容!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意到了吗?这段代码和我们之前写的describe-path很类似:在Lisp中,不只是代码和数据看起来很像,代码和特殊形式对于编译器来说也是一样的-高度的统一带来简明的设计!我们来试试新代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(walk east)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (walk east)
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉好多了! 现在我们来创建一个命令来收集游戏里的物品&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn pickup-object [object]
  (cond (is-at? object location object-locations)
        (do
          (def object-locations (assoc object-locations object 'body))
          `(you are now carrying the ~object))
        :else '(you cannot get that.)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数检查物品是否在当前地点的地上-如果在,则将它放到list里面,并返回成功提示!否则提示失败! 现在我们来创建另一个SPEL来简化这条命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defspel pickup [object] `(spel-print (pickup-object '~object)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(pickup whiskey-bottle)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (pickup whiskey-bottle)
(you are now carrying the whiskey-bottle)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来添加更多有用的命令-首先,一个能让我们查看我们捡到的物品的函 数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn inventory []
  (filter (fn [x] (is-at? x 'body object-locations)) objects))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及一个检查我们是否有某个物品的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn have? [object]
   (some #{object} (inventory)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建特殊操作&lt;/h1&gt;

&lt;p&gt;现在我们只剩下一件事情需要做了:添加一些特殊动作,使得玩家能够赢得游戏.第一条命令是让玩家在阁楼里给水桶焊接链条.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def chain-welded false)

(defn weld [subject object]
  (cond (and (= location 'attic)
             (= subject 'chain)
             (= object 'bucket)
             (have? 'chain)
             (have? 'bucket)
             (not chain-welded))
        (do (def chain-welded true)
            '(the chain is now securely welded to the bucket -))
        :else '(you cannot weld like that -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我们创建了一个新的全局变量来进行判断,我们是否进行了此操作.然后我们创建了一个weld函数,来确认此操作的条件是否完成,如果已完成则进行此操作.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_12.jpg&quot; alt=&quot;&quot; /&gt; 来试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(weld 'chain 'bucket)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (weld 'chain 'bucket)
(you cannot weld like that -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops...我们没有水桶,也没有链条,是吧?周围也没有焊接的机器!&lt;/p&gt;

&lt;p&gt;现在,让我们创建一条命令来将链条和水桶放到井里:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def bucket-filled false)

(defn dunk [subject object]
  (cond (and (= location 'garden)
             (= subject 'bucket)
             (= object 'well)
             (have? 'bucket)
             chain-welded)
        (do (def bucket-filled true)
            '(the bucket is now full of water))
        :else '(you cannot dunk like that -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到了吗?这个命令和weld命令看起来好像!两条命令都需要检查位置,物体和对象!但是它们还是有不同,以至于我们不能将它们抽到一个函数里.太可惜了!&lt;/p&gt;

&lt;p&gt;但是...这可是Lisp.我们不止能写函数,还能写SPEL!我们来创建了SPEL来处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defspel game-action [command subj obj place &amp;amp; args]
  `(defspel ~command [subject# object#]
     `(spel-print (cond (and (= location '~'~place)
                             (= '~subject# '~'~subj)
                             (= '~object# '~'~obj)
                             (have? '~'~subj))
                        ~@'~args
                        :else '(i cannot ~'~command like that -)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非常复杂的SPEL!它有很多怪异的quote,语法quote,逗号以及很多怪异的符号!更重要的是他是一个构建SPEL的SPEL!!即使是很有经验的Lisp程序员,也需要费下脑细胞才能写出这么个玩样!!(这里我们不管)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个SPEL的只是向你展示,你是否够聪明来理解这么复杂的SPEL.而且,即使这段代码很丑陋,如果它只需要写一次,并且能生成几百个命令,那么也是可以接受的!&lt;/p&gt;

&lt;p&gt;让我们使用这个新的SPEL来替换我们的weld命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(game-action weld chain bucket attic
   (cond (and (have? 'bucket) (def chain-welded true))
              '(the chain is now securely welded to the bucket -)
         :else '(you do not have a bucket -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们来看看这条命令变得多容易理解:game-action这个SPEL使得我们能编写我们想要的核心代码,而不需要额外的信息.这就像我们创建了我们自己的专门创建游戏命令的编程语言.使用SPEL创建伪语言称为领域特定语言编程(DSL),它使得你的编码更加的快捷优美!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(weld chain bucket)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;user=&amp;gt; (weld chain bucket)
(you do not have a chain -)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;...我们还没有做好焊接前的准备工作,但是这条命令生效了!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们重写dunk命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(game-action dunk bucket well garden
             (cond chain-welded
                   (do (def bucket-filled true)
                       '(the bucket is now full of water))
                   :else '(the water level is too low to reach -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意weld命令需要检验我们是否有物体,但是dunk不需要.我们的game-action这个SPEL使得这段代码易写易读.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_15.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后,就是将水泼到巫师身上:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(game-action splash bucket wizard living-room
             (cond (not bucket-filled) '(the bucket has nothing in it -)
                   (have? 'frog) '(the wizard awakens and sees that you stole
                                       his frog -
                                       he is so upset he banishes you to the
                                       netherworlds - you lose! the end -)
                   :else '(the wizard awakens from his slumber and greets you
                               warmly -
                               he hands you the magic low-carb donut - you win!
                               the end -)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/cs_16.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在你已经编写完成了一个文字冒险游戏了!&lt;/p&gt;

&lt;p&gt;点击&lt;a href=&quot;http://www.lisperati.com/clojure-spels/cheat.html&quot;&gt;这里&lt;/a&gt;是完整的游戏.&lt;/p&gt;

&lt;p&gt;点击&lt;a href=&quot;http://www.lisperati.com/clojure-spels/code.html&quot;&gt;这里&lt;/a&gt;是代码.&lt;/p&gt;

&lt;p&gt;为了使教程尽可能的简单,很多Lisp的执行细节被忽略了,所以最后,让我们来看看这些细节!&lt;/p&gt;

&lt;h1&gt;附录&lt;/h1&gt;

&lt;p&gt;现在,我们来聊一聊被忽略的细节!&lt;/p&gt;

&lt;p&gt;首先,Clojure有一套很成熟的定义变量以及改变变量值的系统.在此教程中,我们只使用了def来设置和改变全局变量的值.而在真正的Clojure代码里,你不会这么做.取而代之,你会使用&lt;a href=&quot;http://clojure.org/refs&quot;&gt;Refs&lt;/a&gt;,&lt;a href=&quot;http://clojure.org/atoms&quot;&gt;Atoms和&lt;/a&gt;&lt;a href=&quot;http://clojure.org/agents&quot;&gt;Agents&lt;/a&gt;,它们提供了更清晰,以及线程安全的方式来管理数据.&lt;/p&gt;

&lt;p&gt;另一个问题就是我们在代码中大量使用了符号(symbol)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;'(this is not how Lispers usually write text)
&quot;Lispers write text using double quotes&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;符号在Clojure有特殊含义,主要是用来持有函数,变量或其它内容的.所以,在Lisp中将符号作为文本信息描述是很奇怪的事情!使用字符串来显示文本信息可以避免这样的尴尬!不过,使用字符串的话,在教程里就没法讲很多关于符号的内容了!&lt;/p&gt;

&lt;p&gt;还有就是SPEL在Lisp里面更普遍的叫法是&quot;宏&quot;,使用defmacro来定义,但是这个名字不易于教学,所以没有提及.你可以阅读&lt;a href=&quot;http://www.lisperati.com/clojure-spels/no_macros.html&quot;&gt;此文&lt;/a&gt;,这是我为什么没有使用&quot;宏&quot;这个名字的原因.&lt;/p&gt;

&lt;p&gt;最后,在编写类似game-action这样的SPEL的时候,很可能会发生命名重复的问题.当你编写了足够多的lisp的时候,你会越来越能体会到这个问题了.&lt;/p&gt;

&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;后面我该阅读哪些内容来扩充我的Lisp知识? A.
在&lt;a href=&quot;http://www.cliki.net/Lisp%2520books&quot;&gt;cliki网站&lt;/a&gt;有很多Lisp书籍可以下载.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果你对于理论上的内容很感兴趣,那么我推荐Paul Graham的 &lt;a href=&quot;http://www.paulgraham.com/onlisp.html&quot;&gt;On Lisp&lt;/a&gt;电子书,它是免费的.他网站上的一些短文也很精彩.&lt;/p&gt;

&lt;p&gt;如果你对实际应用比较感兴趣,那么大多数Lisp程序员对Perter Seibel编写的&quot;Practical Common Lisp&quot;这本书推崇有加,你可以从&lt;a href=&quot;http://www.gigamonkeys.com/book/&quot;&gt;这里&lt;/a&gt;获得&lt;/p&gt;

&lt;h1&gt;为什么没有使用&quot;宏&quot;这个词&lt;/h1&gt;

&lt;p&gt;编写这个教程的一个意图是使用宏来解决真实的难题.而经常的,当我向没有Lisp经验的人解释宏这个概念的时候,我得到的答复往往是,&quot;哦!C++里也有宏&quot;.当发生这种事情的时候,我就很难去解释宏的概念了.的确,Lisp中的宏和C++中的宏的确有几分相似,它们都是为了能通过编译器来改进代码的编写...&lt;/p&gt;

&lt;p&gt;...所以,假设一下,如果John McCarthy使用了&quot;add&quot;而不是&quot;cons&quot;这个词来将元素添加到list中:我就真的很难解释cons是如何工作的了!&lt;/p&gt;

&lt;p&gt;所以,我决定在此文中使用一个新的词汇:SPEL,语义增强逻辑的简称,它更易理解
一些:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它解释了Lisp宏的核心功能,能改变Lisp运行环境的行为&lt;/li&gt;
&lt;li&gt;SPEL这个术语可以被用来很高雅的解释很多语言上观念.&lt;/li&gt;
&lt;li&gt;这个术语不会导致Lisp中的宏与其它的宏被混为一谈&lt;/li&gt;
&lt;li&gt;SPEL这个词重复的可能性非常低.Google搜索&quot;macro 或者 macros 程序 -lisp -scheme&quot;返回大概1150000条结果.而搜索&quot;spel 或者 spels 程序 -lisp -scheme&quot;值返回28400条结果.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以,我希望,作为一个Lisp程序员,你能接受这个术语.当然了,像这样的新词汇会被接受的可能性非常低.&lt;/p&gt;

&lt;p&gt;如果你有一个库或者是一个Lisp实现者,请先放下你手头上的工作,先在你的库里,添加下面这行代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro defspel [&amp;amp; rest] `(defmacro ~@rest))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;译者感想&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;本人对Lisp的宏还是有些了解的,所以个人无法接受SPEL这个新词汇&lt;/li&gt;
&lt;li&gt;且SPEL使得代码不易阅读,就game-action这个SPEL来说,使用了两层,而使用宏只需要一层&lt;/li&gt;
&lt;li&gt;附录中是我使用Clojure的惯用法重新改写的代码,且文字翻译成了中文.以及使用了宏而不是SPEL.各位可比较,自行选择&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;/assets/clojure/game.zip&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure进阶:使用Clojure构建DSL</title>
        <link href="http://ivanpig.github.io/2014/10/01/dsl.html"/>
        <updated>2014-10-01T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/10/01/dsl</id>
        <content type="html">&lt;p&gt;翻译自&lt;a href=&quot;http://clojure-doc.org/articles/tutorials/growing_a_dsl_with_clojure.html&quot;&gt;Growing a DSL with Clojure&lt;/a&gt;.主要讲解如何使用&lt;/p&gt;

&lt;p&gt;Clojure来创建一个简单的DSL.包括如下知识点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多重方法(Multimethods)&lt;/li&gt;
&lt;li&gt;继承(Hierarchies)&lt;/li&gt;
&lt;li&gt;元编程及&quot;代码即数据&quot;哲学(Metaprogramming and the &quot;Code as data&quot; philosophy)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Lisp及其方言(比如Clojure)可以很方便的创建DSL并能和源语言无缝的集成.&lt;/p&gt;

&lt;p&gt;Lisp界鼓吹的优点中，提到最多的可能就是:数据即代码，代码即数据了。在此文中我们将依此特性来定义一个DSL。&lt;/p&gt;

&lt;p&gt;我们将渐进式的开发这个DSL，不断的加入Clojure的特性和抽象。&lt;/p&gt;

&lt;h1&gt;任务&lt;/h1&gt;

&lt;p&gt;我们的目标是定义一个可以生成各种脚本语言的DSL.而且DSL代码看起来和普通的Clojure代码没有区别。&lt;/p&gt;

&lt;p&gt;例如,我们使用Clojure形式(form)来生成Bash脚本或者Windows批处理脚本:&lt;/p&gt;

&lt;p&gt;输入(Clojure形式):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(if (= 1 2)
  (println &quot;a&quot;)
  (println &quot;b&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出(Bash脚本):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;if [ 1 -eq 2 ]; then
  echo &quot;a&quot;
else
  echo &quot;b&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出(Windows批处理):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;IF 1==2 (
  ECHO a
) ELSE (
  ECHO b
)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;第一步:构建我们的领域语言&lt;/h1&gt;

&lt;p&gt;我们先从Bash脚本开始。&lt;/p&gt;

&lt;p&gt;在开始之前，我们先看看Clojure核心类型是否有什么类型我们可以直接拿到领域语言中使用。在Clojure类型中是否有和Bash脚本类似的类型呢？那就是字符串和基本类型，我们先从这里开始。&lt;/p&gt;

&lt;p&gt;我们来定义一个emit-bash-form函数，它接受一个Clojure形式并返回一个符合Bash脚本定义的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn emit-bash-form
  &quot;Returns a String containing the equivalent Bash script
  to its argument.&quot;
  [a]
  (cond
    (= (class a) java.lang.String) a
    (= (class a) java.lang.Long) (str a)
    (= (class a) java.lang.Double) (str a)
    :else (throw (Exception. &quot;Fell through&quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cond表达式根据传入参数的类型来进行相应的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash-form 1)
&quot;1&quot;
user=&amp;gt; (emit-bash-form &quot;a&quot;)
&quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们为什么要选择Long而不是Integer呢？因为在Clojure中，默认数据类型是Long.&lt;/p&gt;

&lt;p&gt;虽然Clojure支持Java所有的基本类型,但是默认情况下Clojure使用的是long和double.Clojure会自动将int转成long，float转成double.可以简单的测试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (class 7)
java.lang.Long
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，如果我们想添加条件判断，我们只需要在cond表达式中添加相应的分支即可。&lt;/p&gt;

&lt;h1&gt;Echo和Print&lt;/h1&gt;

&lt;p&gt;让我们继续添加功能。 Bash使用echo在屏幕上打印信息。如果你玩过Linux shell那么你应该对此不陌生。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;ambrose@ambrose-desktop&amp;gt; echo asdf
asdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clojure.core命名空间也包含了一个和Bash的echo类似功能的函数，叫println.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (println &quot;asdf&quot;)
asdf
;=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们能直接将(println &quot;a&quot;)传递给emit-bash-form是不是很酷?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash-form (println &quot;asdf&quot;))
asdf
;=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么首先，需要看看这是否可行.&lt;/p&gt;

&lt;p&gt;我们使用Java来进行一下类比，假设我们要调用的是这样一段Java代码，它的第一个参数类似于System.out.println(&quot;asdf&quot;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;foo(System.out.println(&quot;asdf&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(我们先忽略System.out.println(...)返回的是void)在Java中，参数会被先求值，然后再传递，也就是说，这里会先打印出asdf，然后将println的返回值给foo方法。 我们如何能阻止参数被先求值呢?&lt;/p&gt;

&lt;p&gt;很遗憾，在Java中这是不可能完成的任务。即使这在Java中可以实现，那后续我们能对这段源代码做什么处理呢?&lt;/p&gt;

&lt;p&gt;System.out.println(&quot;asdf&quot;)不是集合,所以我们不能遍历它；它也不是字符串，我们也不能用正则表达式来切割它。不管System.out.println(&quot;asdf&quot;)是什么类型，除了编译器，没人认识它。&lt;/p&gt;

&lt;p&gt;Lisp则不会有这样的尴尬!&lt;/p&gt;

&lt;h1&gt;Lisp代码即数据&lt;/h1&gt;

&lt;p&gt;上节说到的Java的主要问题是没有能处理源代码的工具。Clojure是怎么解决这个问题的呢?&lt;/p&gt;

&lt;p&gt;首先，为了能获得源码，Clojure提供了quote来阻止求值过程。只需要在不需要求值的形式前面添加quote即可阻止该形式被求值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; '(println &quot;a&quot;)
;=&amp;gt; (println &quot;a&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们的返回值是什么类型呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (class '(println &quot;a&quot;))
;=&amp;gt; clojure.lang.PersistentList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以将返回值当成原始的Clojure列表(实际上它就是)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (first '(println &quot;a&quot;))
;=&amp;gt; println

user=&amp;gt; (second '(println &quot;a&quot;))
;=&amp;gt; &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是Lisp代码即数据所带来的一个好处.&lt;/p&gt;

&lt;h1&gt;细窥Clojure&lt;/h1&gt;

&lt;p&gt;使用了quote，我们就离DSL近了一步。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(emit-bash-form
  '(println &quot;a&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们将这个分支添加到emit-bash-form函数中。我们需要添加一个新的判断条件。 但是这个分支该用什么类型来判断呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (class '(println &quot;a&quot;))
clojure.lang.PersistentList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以让我们来添加一个clojure.lang.PersistentList判断分支.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn emit-bash-form [a]
  (cond
    (= (class a) clojure.lang.PersistentList)
    (case (name (first a))
      &quot;println&quot; (str &quot;echo &quot; (second a)))

    (= (class a) java.lang.String) a
    (= (class a) java.lang.Long) (str a)
    (= (class a) java.lang.Double) (str a)
    :else (throw (Exception. &quot;Fell through&quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash-form '(println &quot;a&quot;))
&quot;echo a&quot;
user=&amp;gt; (emit-bash-form '(println &quot;hello&quot;))
&quot;echo hello&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;使用多重方法对分支进行抽象&lt;/h1&gt;

&lt;p&gt;我们有一个好的开始，现在在我们进行下一步前，先进行一下重构。&lt;/p&gt;

&lt;p&gt;现在，我们要添加新的分支，那么就要在emit-bash-form函数中添加新的判断逻辑。随着添加的分支越来越多，这个函数将越来越难维护了。我们需要将这个函数切分成易于维护的片段.&lt;/p&gt;

&lt;p&gt;emit-bash-form的调度是依据其参数的类型来进行的。而这可以通过Clojure的多重方法来进行抽象。我们来定义一个叫emit-bash的多重方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit-bash
  (fn [form]
    (class form)))

(defmethod emit-bash
  clojure.lang.PersistentList
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;echo &quot; (second form))))

(defmethod emit-bash
  java.lang.String
  [form]
  form)

(defmethod emit-bash
  java.lang.Long
  [form]
  (str form))

(defmethod emit-bash
  java.lang.Double
  [form]
  (str form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多重方法的分派和cond很类似，但是不需要去写实际的分派代码。让我们来对比一下多重方法和之前的代码。defmulti用来创建一个新的多重方法，并和分派函数来关联。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit-bash
  (fn [form]
    (class form)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defmethod用来添加具体的方法到多重方法中。在这里java.lang.String是指派所依赖的值,而方法直接返回form自身.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmethod emit-bash
  java.lang.String
  [form]
  form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加新方法和扩展cond表达式的效果相同，差别就是:多重方法来控制指派，不需要你去写控制代码。&lt;/p&gt;

&lt;p&gt;那么我们该如何使用emit-bash呢？调用多重方法和调用普通的Clojure函数一模一样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash '(println &quot;a&quot;))
&quot;echo a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分支判断由多重方法自己去判断了。&lt;/p&gt;

&lt;h1&gt;扩展我们的DSL实现Windows批处理&lt;/h1&gt;

&lt;p&gt;现在我们来实现Windows批处理.我们来定义一个新的多重方法,emit-batch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit-batch
  (fn [form] (class form)))

(defmethod emit-batch clojure.lang.PersistentList
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;ECHO &quot; (second form))
    nil))

(defmethod emit-batch java.lang.String
  [form]
  form)

(defmethod emit-batch java.lang.Long
  [form]
  (str form))

(defmethod emit-batch java.lang.Double
  [form]
  (str form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们能使用emit-batch和emit-bash了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-batch '(println &quot;a&quot;))
&quot;ECHO a&quot;
user=&amp;gt; (emit-bash '(println &quot;a&quot;))
&quot;echo a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Ad-hoc继承&lt;/h1&gt;

&lt;p&gt;比较一下两个实现，有很多相似的地方。实际上，只有clojure.lang.PersistentList分支有区别。&lt;/p&gt;

&lt;p&gt;我们想到了继承，Clojure可以很方便的实现继承。&lt;/p&gt;

&lt;p&gt;当我说继承的时候，我可不是指依赖于类或者命名空间的那种继承，实际上继承是一个与类或命名空间无关的独立功能。&lt;/p&gt;

&lt;p&gt;但是像Java这样的语言，继承是绑定到了类层级上的.&lt;/p&gt;

&lt;p&gt;我们能从一个名字派生到另一个名字，或者从类派生到名字。而这个名字可以是symbol或者keyword.这样的话继承就更加的灵活和强大! 我们将使用(derive childparent)来定义父子关系。isa?来判断第一个参数是不是派生自第二个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (derive ::child ::parent)
nil

user=&amp;gt; (isa? ::child ::parent)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来定义Bash和Batch的继承关系&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(derive ::bash ::common)
(derive ::batch ::common)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (parents ::bash)
;=&amp;gt; #{:user/common}

user=&amp;gt; (parents ::batch)
;=&amp;gt; #{:user/common}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;多重方法中使用继承&lt;/h1&gt;

&lt;p&gt;现在我们可以利用继承关系来定义一个新的多重方法emit了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit
  (fn [form]
    [*current-implementation* (class form)]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数返回了一个包含两个元素的vector。一个是当前的实现(::bash或者::batch)和指派类型。*current-implementation*是个动态var,你可以把他看做一个线程安全的全局变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def ^{:dynamic true}
  &quot;The current script language implementation to generate&quot;
  *current-implementation*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的继承关系中，::common是父，这就意味着它需要提供公共方法。需要记住的是，现在的指派值是个vector。所以在每个defmethod中，都需要包含一个vector，其中第一个元素是指派值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmethod emit [::common java.lang.String]
  [form]
  form)

(defmethod emit [::common java.lang.Long]
  [form]
  (str form))

(defmethod emit [::common java.lang.Double]
  [form]
  (str form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很类似。只有clojure.lang.PersistentList分支需要特别处理，其vector的第一个元素需要为::bash或者::batch，而不能是::common了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmethod emit [::bash clojure.lang.PersistentList]
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;echo &quot; (second form))
    nil))

(defmethod emit [::batch clojure.lang.PersistentList]
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;ECHO &quot; (second form))
    nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;user=&amp;gt; (binding [*current-implementation* ::common]
         (emit &quot;a&quot;))
&quot;a&quot;

user=&amp;gt; (binding [*current-implementation* ::batch]
         (emit '(println &quot;a&quot;)))
&quot;ECHO a&quot;

user=&amp;gt; (binding [*current-implementation* ::bash]
         (emit '(println &quot;a&quot;)))
&quot;echo a&quot;

user=&amp;gt; (binding [*current-implementation* ::common]
         (emit '(println &quot;a&quot;)))
#&amp;lt;CompilerException java.lang.IllegalArgumentException:
No method in multimethod 'emit' for dispatch value:
[:user/common clojure.lang.PersistentList] (REPL:31)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们没有定义[::common clojure.lang.PersistentList]的实现，多重方法报错了。&lt;/p&gt;

&lt;p&gt;多重方法非常强大且非常灵活，但是能力越强责任越大。我们可以将我们的多重方法放在同一个命名空间下，但是不代表我们就需要这么做。当我们的DSL越来越大的时候，我们需要将其分开到独立的命名空间下去。&lt;/p&gt;

&lt;p&gt;这是个小例子，但是很好的展示了命名空间和继承的功能。&lt;/p&gt;

&lt;h1&gt;饭后甜点&lt;/h1&gt;

&lt;p&gt;我们使用多重方法，动态var和ad-hoc继承创建了一个漂亮的，细粒度的DSL，但是在使用的时候还是有些许的不便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(binding [*current-implementation* ::bash]
  (emit '(println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来消除样板代码.但是它在哪呢？&lt;/p&gt;

&lt;p&gt;binding表达式就是个样板代码，我们可以将binding的工作封装到with-implementation中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-implementation ::bash
  (emit '(println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个改进。但是还有个改进没有这么的明显:用来延迟求值的quote。我们使用script来消除这个quote.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-implementation ::bash
  (script
    (println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样看起来好多了，但我们如何来实现script呢？Clojure函数会在求函数值前对所有的参数进行求值，而quote就是用来解决这个问题。而现在我们要消除这个quote。只能使用Lisp中的宏来处理。&lt;/p&gt;

&lt;p&gt;宏不会去立即对参数求值，这正是我们需要的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro script [form]
  `(emit '~form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看调用结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;(script (println &quot;a&quot;))
=&amp;gt;
(emit '(println &quot;a&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比起欣赏宏美化语法的功能，记住宏的特性对你更有帮助。&lt;/p&gt;

&lt;p&gt;对于with-implementation来说，也需要宏来解决，与script不同，它不是为了延迟求值这个功能，而是对于其中的script来说，需要先将script的内容添加到binding形式中，才能进行求值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro with-implementation
  [impl &amp;amp; body]
  `(binding [*current-implementation* impl]
    ~@body))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了,这就是DSL的所有内容了,实际上就添加了语法糖.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;(with-implementation ::bash
  (script
    (println &quot;a&quot;)))
=&amp;gt;
(with-implementation ::bash
  (emit
    '(println &quot;a&quot;))
=&amp;gt;
(binding [*current-implementation* ::bash]
  (emit
    '(println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出一个定义良好的宏如何来给代码添加语法糖.我们的DSL和普通的Clojure代码看起来没啥区别.&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;在这个DSL中,我们看到了Clojure的很多高级特性.&lt;/p&gt;

&lt;p&gt;我们来回顾一下我们构建DSL的过程.&lt;/p&gt;

&lt;p&gt;一开始,我们使用了简单的cond表达式,然后变成了两个多重方法.接着我们使用了继承和动态var来消除重复代码.最后我们使用宏来简化调用.&lt;/p&gt;

&lt;p&gt;这个DSL是&lt;a href=&quot;https://github.com/pallet/stevedore&quot;&gt;Stevedore&lt;/a&gt;的一个简化版本,Stevedore是Hugo Duncan开发的开源项目.如果你对这个DSL的实现感兴趣,那么最好的方法就是去看Stevedore的源码了.&lt;/p&gt;

&lt;h1&gt;Copyright&lt;/h1&gt;

&lt;p&gt;Copyright Ambrose Bonnaire-Sergeant, 2013 Translated By Ivan 2014.02&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;翻译自&lt;a href=&quot;http://clojure-doc.org/articles/tutorials/growing_a_dsl_with_clojure.html&quot;&gt;Growing a DSL with Clojure&lt;/a&gt;.主要讲解如何使用&lt;/p&gt;

&lt;p&gt;Clojure来创建一个简单的DSL.包括如下知识点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多重方法(Multimethods)&lt;/li&gt;
&lt;li&gt;继承(Hierarchies)&lt;/li&gt;
&lt;li&gt;元编程及&quot;代码即数据&quot;哲学(Metaprogramming and the &quot;Code as data&quot; philosophy)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Lisp及其方言(比如Clojure)可以很方便的创建DSL并能和源语言无缝的集成.&lt;/p&gt;

&lt;p&gt;Lisp界鼓吹的优点中，提到最多的可能就是:数据即代码，代码即数据了。在此文中我们将依此特性来定义一个DSL。&lt;/p&gt;

&lt;p&gt;我们将渐进式的开发这个DSL，不断的加入Clojure的特性和抽象。&lt;/p&gt;

&lt;h1&gt;任务&lt;/h1&gt;

&lt;p&gt;我们的目标是定义一个可以生成各种脚本语言的DSL.而且DSL代码看起来和普通的Clojure代码没有区别。&lt;/p&gt;

&lt;p&gt;例如,我们使用Clojure形式(form)来生成Bash脚本或者Windows批处理脚本:&lt;/p&gt;

&lt;p&gt;输入(Clojure形式):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(if (= 1 2)
  (println &quot;a&quot;)
  (println &quot;b&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出(Bash脚本):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;if [ 1 -eq 2 ]; then
  echo &quot;a&quot;
else
  echo &quot;b&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出(Windows批处理):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;IF 1==2 (
  ECHO a
) ELSE (
  ECHO b
)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;第一步:构建我们的领域语言&lt;/h1&gt;

&lt;p&gt;我们先从Bash脚本开始。&lt;/p&gt;

&lt;p&gt;在开始之前，我们先看看Clojure核心类型是否有什么类型我们可以直接拿到领域语言中使用。在Clojure类型中是否有和Bash脚本类似的类型呢？那就是字符串和基本类型，我们先从这里开始。&lt;/p&gt;

&lt;p&gt;我们来定义一个emit-bash-form函数，它接受一个Clojure形式并返回一个符合Bash脚本定义的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn emit-bash-form
  &quot;Returns a String containing the equivalent Bash script
  to its argument.&quot;
  [a]
  (cond
    (= (class a) java.lang.String) a
    (= (class a) java.lang.Long) (str a)
    (= (class a) java.lang.Double) (str a)
    :else (throw (Exception. &quot;Fell through&quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cond表达式根据传入参数的类型来进行相应的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash-form 1)
&quot;1&quot;
user=&amp;gt; (emit-bash-form &quot;a&quot;)
&quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们为什么要选择Long而不是Integer呢？因为在Clojure中，默认数据类型是Long.&lt;/p&gt;

&lt;p&gt;虽然Clojure支持Java所有的基本类型,但是默认情况下Clojure使用的是long和double.Clojure会自动将int转成long，float转成double.可以简单的测试一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (class 7)
java.lang.Long
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，如果我们想添加条件判断，我们只需要在cond表达式中添加相应的分支即可。&lt;/p&gt;

&lt;h1&gt;Echo和Print&lt;/h1&gt;

&lt;p&gt;让我们继续添加功能。 Bash使用echo在屏幕上打印信息。如果你玩过Linux shell那么你应该对此不陌生。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;ambrose@ambrose-desktop&amp;gt; echo asdf
asdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clojure.core命名空间也包含了一个和Bash的echo类似功能的函数，叫println.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (println &quot;asdf&quot;)
asdf
;=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们能直接将(println &quot;a&quot;)传递给emit-bash-form是不是很酷?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash-form (println &quot;asdf&quot;))
asdf
;=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么首先，需要看看这是否可行.&lt;/p&gt;

&lt;p&gt;我们使用Java来进行一下类比，假设我们要调用的是这样一段Java代码，它的第一个参数类似于System.out.println(&quot;asdf&quot;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;foo(System.out.println(&quot;asdf&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(我们先忽略System.out.println(...)返回的是void)在Java中，参数会被先求值，然后再传递，也就是说，这里会先打印出asdf，然后将println的返回值给foo方法。 我们如何能阻止参数被先求值呢?&lt;/p&gt;

&lt;p&gt;很遗憾，在Java中这是不可能完成的任务。即使这在Java中可以实现，那后续我们能对这段源代码做什么处理呢?&lt;/p&gt;

&lt;p&gt;System.out.println(&quot;asdf&quot;)不是集合,所以我们不能遍历它；它也不是字符串，我们也不能用正则表达式来切割它。不管System.out.println(&quot;asdf&quot;)是什么类型，除了编译器，没人认识它。&lt;/p&gt;

&lt;p&gt;Lisp则不会有这样的尴尬!&lt;/p&gt;

&lt;h1&gt;Lisp代码即数据&lt;/h1&gt;

&lt;p&gt;上节说到的Java的主要问题是没有能处理源代码的工具。Clojure是怎么解决这个问题的呢?&lt;/p&gt;

&lt;p&gt;首先，为了能获得源码，Clojure提供了quote来阻止求值过程。只需要在不需要求值的形式前面添加quote即可阻止该形式被求值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; '(println &quot;a&quot;)
;=&amp;gt; (println &quot;a&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们的返回值是什么类型呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (class '(println &quot;a&quot;))
;=&amp;gt; clojure.lang.PersistentList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以将返回值当成原始的Clojure列表(实际上它就是)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (first '(println &quot;a&quot;))
;=&amp;gt; println

user=&amp;gt; (second '(println &quot;a&quot;))
;=&amp;gt; &quot;a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是Lisp代码即数据所带来的一个好处.&lt;/p&gt;

&lt;h1&gt;细窥Clojure&lt;/h1&gt;

&lt;p&gt;使用了quote，我们就离DSL近了一步。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(emit-bash-form
  '(println &quot;a&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们将这个分支添加到emit-bash-form函数中。我们需要添加一个新的判断条件。 但是这个分支该用什么类型来判断呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (class '(println &quot;a&quot;))
clojure.lang.PersistentList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以让我们来添加一个clojure.lang.PersistentList判断分支.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn emit-bash-form [a]
  (cond
    (= (class a) clojure.lang.PersistentList)
    (case (name (first a))
      &quot;println&quot; (str &quot;echo &quot; (second a)))

    (= (class a) java.lang.String) a
    (= (class a) java.lang.Long) (str a)
    (= (class a) java.lang.Double) (str a)
    :else (throw (Exception. &quot;Fell through&quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash-form '(println &quot;a&quot;))
&quot;echo a&quot;
user=&amp;gt; (emit-bash-form '(println &quot;hello&quot;))
&quot;echo hello&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;使用多重方法对分支进行抽象&lt;/h1&gt;

&lt;p&gt;我们有一个好的开始，现在在我们进行下一步前，先进行一下重构。&lt;/p&gt;

&lt;p&gt;现在，我们要添加新的分支，那么就要在emit-bash-form函数中添加新的判断逻辑。随着添加的分支越来越多，这个函数将越来越难维护了。我们需要将这个函数切分成易于维护的片段.&lt;/p&gt;

&lt;p&gt;emit-bash-form的调度是依据其参数的类型来进行的。而这可以通过Clojure的多重方法来进行抽象。我们来定义一个叫emit-bash的多重方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit-bash
  (fn [form]
    (class form)))

(defmethod emit-bash
  clojure.lang.PersistentList
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;echo &quot; (second form))))

(defmethod emit-bash
  java.lang.String
  [form]
  form)

(defmethod emit-bash
  java.lang.Long
  [form]
  (str form))

(defmethod emit-bash
  java.lang.Double
  [form]
  (str form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多重方法的分派和cond很类似，但是不需要去写实际的分派代码。让我们来对比一下多重方法和之前的代码。defmulti用来创建一个新的多重方法，并和分派函数来关联。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit-bash
  (fn [form]
    (class form)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defmethod用来添加具体的方法到多重方法中。在这里java.lang.String是指派所依赖的值,而方法直接返回form自身.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmethod emit-bash
  java.lang.String
  [form]
  form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加新方法和扩展cond表达式的效果相同，差别就是:多重方法来控制指派，不需要你去写控制代码。&lt;/p&gt;

&lt;p&gt;那么我们该如何使用emit-bash呢？调用多重方法和调用普通的Clojure函数一模一样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-bash '(println &quot;a&quot;))
&quot;echo a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分支判断由多重方法自己去判断了。&lt;/p&gt;

&lt;h1&gt;扩展我们的DSL实现Windows批处理&lt;/h1&gt;

&lt;p&gt;现在我们来实现Windows批处理.我们来定义一个新的多重方法,emit-batch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit-batch
  (fn [form] (class form)))

(defmethod emit-batch clojure.lang.PersistentList
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;ECHO &quot; (second form))
    nil))

(defmethod emit-batch java.lang.String
  [form]
  form)

(defmethod emit-batch java.lang.Long
  [form]
  (str form))

(defmethod emit-batch java.lang.Double
  [form]
  (str form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们能使用emit-batch和emit-bash了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (emit-batch '(println &quot;a&quot;))
&quot;ECHO a&quot;
user=&amp;gt; (emit-bash '(println &quot;a&quot;))
&quot;echo a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Ad-hoc继承&lt;/h1&gt;

&lt;p&gt;比较一下两个实现，有很多相似的地方。实际上，只有clojure.lang.PersistentList分支有区别。&lt;/p&gt;

&lt;p&gt;我们想到了继承，Clojure可以很方便的实现继承。&lt;/p&gt;

&lt;p&gt;当我说继承的时候，我可不是指依赖于类或者命名空间的那种继承，实际上继承是一个与类或命名空间无关的独立功能。&lt;/p&gt;

&lt;p&gt;但是像Java这样的语言，继承是绑定到了类层级上的.&lt;/p&gt;

&lt;p&gt;我们能从一个名字派生到另一个名字，或者从类派生到名字。而这个名字可以是symbol或者keyword.这样的话继承就更加的灵活和强大! 我们将使用(derive childparent)来定义父子关系。isa?来判断第一个参数是不是派生自第二个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (derive ::child ::parent)
nil

user=&amp;gt; (isa? ::child ::parent)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来定义Bash和Batch的继承关系&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(derive ::bash ::common)
(derive ::batch ::common)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (parents ::bash)
;=&amp;gt; #{:user/common}

user=&amp;gt; (parents ::batch)
;=&amp;gt; #{:user/common}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;多重方法中使用继承&lt;/h1&gt;

&lt;p&gt;现在我们可以利用继承关系来定义一个新的多重方法emit了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmulti emit
  (fn [form]
    [*current-implementation* (class form)]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数返回了一个包含两个元素的vector。一个是当前的实现(::bash或者::batch)和指派类型。*current-implementation*是个动态var,你可以把他看做一个线程安全的全局变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def ^{:dynamic true}
  &quot;The current script language implementation to generate&quot;
  *current-implementation*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的继承关系中，::common是父，这就意味着它需要提供公共方法。需要记住的是，现在的指派值是个vector。所以在每个defmethod中，都需要包含一个vector，其中第一个元素是指派值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmethod emit [::common java.lang.String]
  [form]
  form)

(defmethod emit [::common java.lang.Long]
  [form]
  (str form))

(defmethod emit [::common java.lang.Double]
  [form]
  (str form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很类似。只有clojure.lang.PersistentList分支需要特别处理，其vector的第一个元素需要为::bash或者::batch，而不能是::common了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmethod emit [::bash clojure.lang.PersistentList]
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;echo &quot; (second form))
    nil))

(defmethod emit [::batch clojure.lang.PersistentList]
  [form]
  (case (name (first form))
    &quot;println&quot; (str &quot;ECHO &quot; (second form))
    nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;user=&amp;gt; (binding [*current-implementation* ::common]
         (emit &quot;a&quot;))
&quot;a&quot;

user=&amp;gt; (binding [*current-implementation* ::batch]
         (emit '(println &quot;a&quot;)))
&quot;ECHO a&quot;

user=&amp;gt; (binding [*current-implementation* ::bash]
         (emit '(println &quot;a&quot;)))
&quot;echo a&quot;

user=&amp;gt; (binding [*current-implementation* ::common]
         (emit '(println &quot;a&quot;)))
#&amp;lt;CompilerException java.lang.IllegalArgumentException:
No method in multimethod 'emit' for dispatch value:
[:user/common clojure.lang.PersistentList] (REPL:31)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们没有定义[::common clojure.lang.PersistentList]的实现，多重方法报错了。&lt;/p&gt;

&lt;p&gt;多重方法非常强大且非常灵活，但是能力越强责任越大。我们可以将我们的多重方法放在同一个命名空间下，但是不代表我们就需要这么做。当我们的DSL越来越大的时候，我们需要将其分开到独立的命名空间下去。&lt;/p&gt;

&lt;p&gt;这是个小例子，但是很好的展示了命名空间和继承的功能。&lt;/p&gt;

&lt;h1&gt;饭后甜点&lt;/h1&gt;

&lt;p&gt;我们使用多重方法，动态var和ad-hoc继承创建了一个漂亮的，细粒度的DSL，但是在使用的时候还是有些许的不便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(binding [*current-implementation* ::bash]
  (emit '(println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来消除样板代码.但是它在哪呢？&lt;/p&gt;

&lt;p&gt;binding表达式就是个样板代码，我们可以将binding的工作封装到with-implementation中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-implementation ::bash
  (emit '(println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个改进。但是还有个改进没有这么的明显:用来延迟求值的quote。我们使用script来消除这个quote.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-implementation ::bash
  (script
    (println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样看起来好多了，但我们如何来实现script呢？Clojure函数会在求函数值前对所有的参数进行求值，而quote就是用来解决这个问题。而现在我们要消除这个quote。只能使用Lisp中的宏来处理。&lt;/p&gt;

&lt;p&gt;宏不会去立即对参数求值，这正是我们需要的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro script [form]
  `(emit '~form))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看调用结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;(script (println &quot;a&quot;))
=&amp;gt;
(emit '(println &quot;a&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比起欣赏宏美化语法的功能，记住宏的特性对你更有帮助。&lt;/p&gt;

&lt;p&gt;对于with-implementation来说，也需要宏来解决，与script不同，它不是为了延迟求值这个功能，而是对于其中的script来说，需要先将script的内容添加到binding形式中，才能进行求值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmacro with-implementation
  [impl &amp;amp; body]
  `(binding [*current-implementation* impl]
    ~@body))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了,这就是DSL的所有内容了,实际上就添加了语法糖.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;(with-implementation ::bash
  (script
    (println &quot;a&quot;)))
=&amp;gt;
(with-implementation ::bash
  (emit
    '(println &quot;a&quot;))
=&amp;gt;
(binding [*current-implementation* ::bash]
  (emit
    '(println &quot;a&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出一个定义良好的宏如何来给代码添加语法糖.我们的DSL和普通的Clojure代码看起来没啥区别.&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;在这个DSL中,我们看到了Clojure的很多高级特性.&lt;/p&gt;

&lt;p&gt;我们来回顾一下我们构建DSL的过程.&lt;/p&gt;

&lt;p&gt;一开始,我们使用了简单的cond表达式,然后变成了两个多重方法.接着我们使用了继承和动态var来消除重复代码.最后我们使用宏来简化调用.&lt;/p&gt;

&lt;p&gt;这个DSL是&lt;a href=&quot;https://github.com/pallet/stevedore&quot;&gt;Stevedore&lt;/a&gt;的一个简化版本,Stevedore是Hugo Duncan开发的开源项目.如果你对这个DSL的实现感兴趣,那么最好的方法就是去看Stevedore的源码了.&lt;/p&gt;

&lt;h1&gt;Copyright&lt;/h1&gt;

&lt;p&gt;Copyright Ambrose Bonnaire-Sergeant, 2013 Translated By Ivan 2014.02&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-命名空间</title>
        <link href="http://ivanpig.github.io/2014/08/29/namespace.html"/>
        <updated>2014-08-29T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/08/29/namespace</id>
        <content type="html">&lt;h1&gt;版本&lt;/h1&gt;

&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/language/namespaces.html&quot;&gt;Clojure Namespaces and Vars&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文涵盖如下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clojure命名空间和var概述&lt;/li&gt;
&lt;li&gt;如何定义命名空间&lt;/li&gt;
&lt;li&gt;如何使用其它命名空间里的函数&lt;/li&gt;
&lt;li&gt;require,refer和use&lt;/li&gt;
&lt;li&gt;常见错误和典型错误,以及导致这些错误的原因&lt;/li&gt;
&lt;li&gt;命名空间和代码管理&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets). The source is available on Github.&lt;/p&gt;

&lt;p&gt;涵盖Clojure版本:Clojure 1.5&lt;/p&gt;

&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;Clojure的函数通过命名空间来组织.Clojure命名空间和Java的包或者Python的模块很类似.命名空间实际上就是个map,将名字映射到了var上.在大部分情况下,这些var持有这些函数.&lt;/p&gt;

&lt;h1&gt;定义一个命名空间&lt;/h1&gt;

&lt;p&gt;一般情况下使用clojure.core/ns宏来定义命名空间.最基本的形式下,它将名字作为符号.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns superlib.core)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名空间可以由点号切割的好多段组成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.service.core)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是,请尽量避免使用单段的命名空间,以免与其它开发人员的命名空间相冲突.如果库或者应用属于某个组织,那么建议以如下形式作为命名空间.[组织名称].[包名|应用名].[函数组名]
例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns clojurewerkz.welle.kv)

(ns megacorp.search.indexer.core)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;另外,ns宏可以包含如下形式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(:require ...)&lt;/li&gt;
&lt;li&gt;(:import ...)&lt;/li&gt;
&lt;li&gt;(:use ...)&lt;/li&gt;
&lt;li&gt;(:refer-clojure ...)&lt;/li&gt;
&lt;li&gt;(:gen-class ...)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些其实就是clojure.core/import,clojure.core/require等等这些的简写形式而已&lt;/p&gt;

&lt;h2&gt;:require&lt;/h2&gt;

&lt;p&gt;:require形式可以使你的代码能访问其它命名空间的Clojure代码.例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require clojure.set))

;; Now it is possible to do:
;; (clojure.set/difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码将保证clojure.set命名空间被加载,编译并且可以通过clojure.set名来调用.当然可以给加载的命名空间取个别名:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set :as cs]))

;; Now it is possible to do:
;; (cs/difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一次导入两个命名空间的例子;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set  :as cs]
            [clojure.walk :as walk]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;:refer选项&lt;/h3&gt;

&lt;p&gt;如果想在当前命名空间里通过简写名称来引用clojure.set空间里的函数,可以通过refer来实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set :refer [difference intersection]]))

;; Now it is possible to do:
;; (difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:require形式中的:refer特性为Clojure1.4新增特性.&lt;/p&gt;

&lt;p&gt;可能有时需要引入某个命名空间下所有的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set :refer :all]))

;; Now it is possible to do:
;; (difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;:import&lt;/h2&gt;

&lt;p&gt;:import的作用是在当前命名空间引入Java类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:import java.util.concurrent.Executors))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行上面的代码后,java.util.concurrent.Executors类将会被引入,请可以直接通过名字Executors来使用.可以同时引入多个类.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:import java.util.concurrent.Executors
           java.util.concurrent.TimeUnit
           java.util.Date))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果引入的多个类在同一个包下面,就像上面那样,可以使用如下的简介方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:import [java.util.concurrent Executors TimeUnit]
           java.util.Date))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然导入的list被叫做list,实际上可以使用任意的Clojure的集合(一般使用vector)&lt;/p&gt;

&lt;h2&gt;当前命名空间&lt;/h2&gt;

&lt;p&gt;Clojure将通过*ns*来持有当前的命名空间.使用def形式定义的var被添加到了当前命名空间中.&lt;/p&gt;

&lt;h2&gt;:refer-clojure&lt;/h2&gt;

&lt;p&gt;我们在使用像clojure.core/get这样的函数和clojure.core/defn这样的宏的时候我们不需要使用它的全限定名.这是因为Clojure默认将clojure.core下的内容全部加载进了当前命名空间里了.所以如果你定义了一个函数名和clojure.core里的重复了(比如find),你将会得到一个警告.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;WARNING: find already refers to: #'clojure.core/find in namespace:    megacorp.profitd.scheduling, being replaced by: #'megacorp.profitd.scheduling/find
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个警告的意思是在megacorp.profitd.scheduling这个命名空间里,已经有一个clojure.core/find了,但是现在它被你定义的函数覆盖了.请记住,Clojure是很动态的语言,命名空间就是map而已.&lt;/p&gt;

&lt;p&gt;解决这个问题的办法有:你可以重命名你的函数或者不引入clojure.core里的这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:refer-clojure :exclude [find]))

(defn find
  &quot;Finds a needle in the haystack.&quot;
  [^String haystack]
  (comment ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里,如果你想使用clojure.core/find的话,你需要通过全限定名来使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:refer-clojure :exclude [find]))

(defn find
  &quot;Finds a needle in the haystack.&quot;
  [^String haystack]
  (clojure.core/find haystack :needle))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;:use&lt;/h2&gt;

&lt;p&gt;Clojure在1.4之前,:require是不支持:refer的,只能使用:use&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling-test
  (:use clojure.test))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,clojure.test里的所有内容都被引入到了当前命名空间中.但是一般不会这样使用,建议是只引入需要的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling-test
  (:use clojure.test :only [deftest testing is]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.4以前的做法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling-test
  (:require clojure.test :refer [deftest testing is]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而现在鼓励的做法是使用:require,通过:refer来进行限制.&lt;/p&gt;

&lt;h2&gt;文档与元数据&lt;/h2&gt;

&lt;p&gt;命名空间可以包含说明文档.你可以在ns宏里添加:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns superlib.core
  &quot;Core functionality of Superlib.

   Other parts of Superlib depend on functions and macros in this namespace.&quot;
  (:require [clojure.set :refer [union difference]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者元数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns ^{:doc &quot;Core functionality of Superlib.
            Other parts of Superlib depend on functions and macros in this namespace.&quot;
      :author &quot;Joe Smith&quot;}
   superlib.core
  (:require [clojure.set :refer [union difference]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元数据可以包含任意的键,例如:author,很多工具可以使用(像Codox,Cadastre或者lein-clojuredocs)&lt;/p&gt;

&lt;h1&gt;如何在REPL里使用其它命名空间的函数&lt;/h1&gt;

&lt;p&gt;ns宏是你经常需要使用的,它引入其它命名空间的函数.但是它在REPL里不太方便.这里可以直接使用require:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; Will be available as clojure.set, e.g. clojure.set/difference.
(require 'clojure.set)

;; Will be available as io, e.g. io/resource.
(require '[clojure.java.io :as io])
It takes a quoted libspec. The libspec is either a namespace name or a collection (typically a vector) of [name :as alias] or [name :refer [fns]]:

(require '[clojure.set :refer [difference]])

(difference #{1 2 3} #{3 4 5 6})  ; ⇒ #{1 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:as和:refer可以一起使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(require '[clojure.set :as cs :refer [difference]])

(difference #{1 2 3} #{3 4 5 6})  ; ⇒ #{1 2}
(cs/union #{1 2 3} #{3 4 5 6})    ; ⇒ #{1 2 3 4 5 6}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clojure.core/use可以做和clojure.core/require一样的事情,但是不推荐使用了.&lt;/p&gt;

&lt;h1&gt;命名空间和编译&lt;/h1&gt;

&lt;p&gt;Clojure是一个需要编译的语言:代码在被加载的时候进行编译.&lt;/p&gt;

&lt;p&gt;命名空间可以包含var或者去继承协议,添加多重方法实现或载入其它库.所以为了完成编译,你需要引入需要的命名空间.&lt;/p&gt;

&lt;h1&gt;私有Vars&lt;/h1&gt;

&lt;p&gt;Vars(包括defn宏定义的函数)可以设为私有的.有两种方法可以来做这件事情:使用元数据或者defn-宏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.superlib)

;;
;; Implementation
;;

(def ^{:private true}
  source-name &quot;supersource&quot;)

(defn- data-stream
  [source]
  (comment ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;常量Vars&lt;/h1&gt;

&lt;p&gt;Vars可以设为常量,通过:const元数据来设置.这将会促使Clojure编译器将其编译为常量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.epicgame)

;;
;; Implementation
;;

(def ^{:const true}
  default-score 100)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;如何通过名称来查找和执行函数&lt;/h1&gt;

&lt;p&gt;可以通过clojure.core/resolve在制定的命名空间里通过名字查找函数.名字需要使用引号修饰.返回值可以直接当做函数使用,比如,当做参数传递给高阶函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(resolve 'clojure.set 'difference)  ; ⇒ #'clojure.set/difference

(let [f (resolve 'clojure.set 'difference)]
   (f #{1 2 3} #{3 4 5 6}))  ; ⇒ #{1 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;编译异常&lt;/h1&gt;

&lt;p&gt;本节讨论一些常见的编译错误.&lt;/p&gt;

&lt;h2&gt;ClassNotFoundException&lt;/h2&gt;

&lt;p&gt;这个异常的意思是JVM无法加载类.可能是因为拼写错误,或者在classpath上没有这个类.可能是你的项目没有很好的处理依赖关系.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (import java.uyil.concurrent.TimeUnit)
ClassNotFoundException java.uyil.concurrent.TimeUnit  java.net.URLClassLoader$1.run (URLClassLoader.java:366)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,java.uyil.concurrent.TimeUnit拼写错误,应该是java.util.concurrent.TimeUnit&lt;/p&gt;

&lt;h2&gt;CompilerException java.lang.RuntimeException: No such var&lt;/h2&gt;

&lt;p&gt;这个错误的意思是,使用了一个不存在的var.这可能是拼写错误,或者不正确的宏展开等类似问题.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (clojure.java.io/resouce &quot;thought_leaders_quotes.csv&quot;)
CompilerException java.lang.RuntimeException: No such var: clojure.java.io/resouce, compiling:(NO_SOURCE_PATH:1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,clojure.java.io/resouce应该写成clojure.java.io/resource.NO_SOURCE_PATH的意思是编译是在repl里触发的,而不是一个Clojure源文件.&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;版本&lt;/h1&gt;

&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/language/namespaces.html&quot;&gt;Clojure Namespaces and Vars&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文涵盖如下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clojure命名空间和var概述&lt;/li&gt;
&lt;li&gt;如何定义命名空间&lt;/li&gt;
&lt;li&gt;如何使用其它命名空间里的函数&lt;/li&gt;
&lt;li&gt;require,refer和use&lt;/li&gt;
&lt;li&gt;常见错误和典型错误,以及导致这些错误的原因&lt;/li&gt;
&lt;li&gt;命名空间和代码管理&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets). The source is available on Github.&lt;/p&gt;

&lt;p&gt;涵盖Clojure版本:Clojure 1.5&lt;/p&gt;

&lt;h1&gt;概述&lt;/h1&gt;

&lt;p&gt;Clojure的函数通过命名空间来组织.Clojure命名空间和Java的包或者Python的模块很类似.命名空间实际上就是个map,将名字映射到了var上.在大部分情况下,这些var持有这些函数.&lt;/p&gt;

&lt;h1&gt;定义一个命名空间&lt;/h1&gt;

&lt;p&gt;一般情况下使用clojure.core/ns宏来定义命名空间.最基本的形式下,它将名字作为符号.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns superlib.core)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命名空间可以由点号切割的好多段组成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.service.core)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是,请尽量避免使用单段的命名空间,以免与其它开发人员的命名空间相冲突.如果库或者应用属于某个组织,那么建议以如下形式作为命名空间.[组织名称].[包名|应用名].[函数组名]
例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns clojurewerkz.welle.kv)

(ns megacorp.search.indexer.core)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;另外,ns宏可以包含如下形式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(:require ...)&lt;/li&gt;
&lt;li&gt;(:import ...)&lt;/li&gt;
&lt;li&gt;(:use ...)&lt;/li&gt;
&lt;li&gt;(:refer-clojure ...)&lt;/li&gt;
&lt;li&gt;(:gen-class ...)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些其实就是clojure.core/import,clojure.core/require等等这些的简写形式而已&lt;/p&gt;

&lt;h2&gt;:require&lt;/h2&gt;

&lt;p&gt;:require形式可以使你的代码能访问其它命名空间的Clojure代码.例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require clojure.set))

;; Now it is possible to do:
;; (clojure.set/difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码将保证clojure.set命名空间被加载,编译并且可以通过clojure.set名来调用.当然可以给加载的命名空间取个别名:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set :as cs]))

;; Now it is possible to do:
;; (cs/difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一次导入两个命名空间的例子;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set  :as cs]
            [clojure.walk :as walk]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;:refer选项&lt;/h3&gt;

&lt;p&gt;如果想在当前命名空间里通过简写名称来引用clojure.set空间里的函数,可以通过refer来实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set :refer [difference intersection]]))

;; Now it is possible to do:
;; (difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:require形式中的:refer特性为Clojure1.4新增特性.&lt;/p&gt;

&lt;p&gt;可能有时需要引入某个命名空间下所有的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:require [clojure.set :refer :all]))

;; Now it is possible to do:
;; (difference #{1 2 3} #{3 4 5})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;:import&lt;/h2&gt;

&lt;p&gt;:import的作用是在当前命名空间引入Java类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:import java.util.concurrent.Executors))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行上面的代码后,java.util.concurrent.Executors类将会被引入,请可以直接通过名字Executors来使用.可以同时引入多个类.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:import java.util.concurrent.Executors
           java.util.concurrent.TimeUnit
           java.util.Date))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果引入的多个类在同一个包下面,就像上面那样,可以使用如下的简介方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:import [java.util.concurrent Executors TimeUnit]
           java.util.Date))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然导入的list被叫做list,实际上可以使用任意的Clojure的集合(一般使用vector)&lt;/p&gt;

&lt;h2&gt;当前命名空间&lt;/h2&gt;

&lt;p&gt;Clojure将通过*ns*来持有当前的命名空间.使用def形式定义的var被添加到了当前命名空间中.&lt;/p&gt;

&lt;h2&gt;:refer-clojure&lt;/h2&gt;

&lt;p&gt;我们在使用像clojure.core/get这样的函数和clojure.core/defn这样的宏的时候我们不需要使用它的全限定名.这是因为Clojure默认将clojure.core下的内容全部加载进了当前命名空间里了.所以如果你定义了一个函数名和clojure.core里的重复了(比如find),你将会得到一个警告.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;WARNING: find already refers to: #'clojure.core/find in namespace:    megacorp.profitd.scheduling, being replaced by: #'megacorp.profitd.scheduling/find
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个警告的意思是在megacorp.profitd.scheduling这个命名空间里,已经有一个clojure.core/find了,但是现在它被你定义的函数覆盖了.请记住,Clojure是很动态的语言,命名空间就是map而已.&lt;/p&gt;

&lt;p&gt;解决这个问题的办法有:你可以重命名你的函数或者不引入clojure.core里的这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:refer-clojure :exclude [find]))

(defn find
  &quot;Finds a needle in the haystack.&quot;
  [^String haystack]
  (comment ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里,如果你想使用clojure.core/find的话,你需要通过全限定名来使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling
  (:refer-clojure :exclude [find]))

(defn find
  &quot;Finds a needle in the haystack.&quot;
  [^String haystack]
  (clojure.core/find haystack :needle))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;:use&lt;/h2&gt;

&lt;p&gt;Clojure在1.4之前,:require是不支持:refer的,只能使用:use&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling-test
  (:use clojure.test))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,clojure.test里的所有内容都被引入到了当前命名空间中.但是一般不会这样使用,建议是只引入需要的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling-test
  (:use clojure.test :only [deftest testing is]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.4以前的做法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.profitd.scheduling-test
  (:require clojure.test :refer [deftest testing is]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而现在鼓励的做法是使用:require,通过:refer来进行限制.&lt;/p&gt;

&lt;h2&gt;文档与元数据&lt;/h2&gt;

&lt;p&gt;命名空间可以包含说明文档.你可以在ns宏里添加:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns superlib.core
  &quot;Core functionality of Superlib.

   Other parts of Superlib depend on functions and macros in this namespace.&quot;
  (:require [clojure.set :refer [union difference]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者元数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns ^{:doc &quot;Core functionality of Superlib.
            Other parts of Superlib depend on functions and macros in this namespace.&quot;
      :author &quot;Joe Smith&quot;}
   superlib.core
  (:require [clojure.set :refer [union difference]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元数据可以包含任意的键,例如:author,很多工具可以使用(像Codox,Cadastre或者lein-clojuredocs)&lt;/p&gt;

&lt;h1&gt;如何在REPL里使用其它命名空间的函数&lt;/h1&gt;

&lt;p&gt;ns宏是你经常需要使用的,它引入其它命名空间的函数.但是它在REPL里不太方便.这里可以直接使用require:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; Will be available as clojure.set, e.g. clojure.set/difference.
(require 'clojure.set)

;; Will be available as io, e.g. io/resource.
(require '[clojure.java.io :as io])
It takes a quoted libspec. The libspec is either a namespace name or a collection (typically a vector) of [name :as alias] or [name :refer [fns]]:

(require '[clojure.set :refer [difference]])

(difference #{1 2 3} #{3 4 5 6})  ; ⇒ #{1 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:as和:refer可以一起使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(require '[clojure.set :as cs :refer [difference]])

(difference #{1 2 3} #{3 4 5 6})  ; ⇒ #{1 2}
(cs/union #{1 2 3} #{3 4 5 6})    ; ⇒ #{1 2 3 4 5 6}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clojure.core/use可以做和clojure.core/require一样的事情,但是不推荐使用了.&lt;/p&gt;

&lt;h1&gt;命名空间和编译&lt;/h1&gt;

&lt;p&gt;Clojure是一个需要编译的语言:代码在被加载的时候进行编译.&lt;/p&gt;

&lt;p&gt;命名空间可以包含var或者去继承协议,添加多重方法实现或载入其它库.所以为了完成编译,你需要引入需要的命名空间.&lt;/p&gt;

&lt;h1&gt;私有Vars&lt;/h1&gt;

&lt;p&gt;Vars(包括defn宏定义的函数)可以设为私有的.有两种方法可以来做这件事情:使用元数据或者defn-宏&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.superlib)

;;
;; Implementation
;;

(def ^{:private true}
  source-name &quot;supersource&quot;)

(defn- data-stream
  [source]
  (comment ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;常量Vars&lt;/h1&gt;

&lt;p&gt;Vars可以设为常量,通过:const元数据来设置.这将会促使Clojure编译器将其编译为常量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns megacorp.epicgame)

;;
;; Implementation
;;

(def ^{:const true}
  default-score 100)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;如何通过名称来查找和执行函数&lt;/h1&gt;

&lt;p&gt;可以通过clojure.core/resolve在制定的命名空间里通过名字查找函数.名字需要使用引号修饰.返回值可以直接当做函数使用,比如,当做参数传递给高阶函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(resolve 'clojure.set 'difference)  ; ⇒ #'clojure.set/difference

(let [f (resolve 'clojure.set 'difference)]
   (f #{1 2 3} #{3 4 5 6}))  ; ⇒ #{1 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;编译异常&lt;/h1&gt;

&lt;p&gt;本节讨论一些常见的编译错误.&lt;/p&gt;

&lt;h2&gt;ClassNotFoundException&lt;/h2&gt;

&lt;p&gt;这个异常的意思是JVM无法加载类.可能是因为拼写错误,或者在classpath上没有这个类.可能是你的项目没有很好的处理依赖关系.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (import java.uyil.concurrent.TimeUnit)
ClassNotFoundException java.uyil.concurrent.TimeUnit  java.net.URLClassLoader$1.run (URLClassLoader.java:366)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,java.uyil.concurrent.TimeUnit拼写错误,应该是java.util.concurrent.TimeUnit&lt;/p&gt;

&lt;h2&gt;CompilerException java.lang.RuntimeException: No such var&lt;/h2&gt;

&lt;p&gt;这个错误的意思是,使用了一个不存在的var.这可能是拼写错误,或者不正确的宏展开等类似问题.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;gt; (clojure.java.io/resouce &quot;thought_leaders_quotes.csv&quot;)
CompilerException java.lang.RuntimeException: No such var: clojure.java.io/resouce, compiling:(NO_SOURCE_PATH:1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,clojure.java.io/resouce应该写成clojure.java.io/resource.NO_SOURCE_PATH的意思是编译是在repl里触发的,而不是一个Clojure源文件.&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-Record和Protocol</title>
        <link href="http://ivanpig.github.io/2014/05/11/record_protocol.html"/>
        <updated>2014-05-11T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/05/11/record_protocol</id>
        <content type="html">&lt;p&gt;本文翻译自:&lt;a href=&quot;http://www.jayway.com/2013/02/05/learn-clojure-using-records-and-protocols/&quot;&gt;Learn Clojure using records and protocols&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当我对Clojure的括号不再疑惑后,另一个让我质疑为何要学习Clojure的问题是使用REPL很爽,但是我怎么来构建大型项目?&quot;.&lt;/p&gt;

&lt;p&gt;实际上,由于我的面向对象编程经验,我其实要问的是&quot;我怎么才能将函数封装到类似class的东西里面去?&quot;.&lt;/p&gt;

&lt;p&gt;在本文中,我将会介绍一种类似于Java的方式来构建大型的Clojure项目.&lt;/p&gt;

&lt;p&gt;通过这种方式,希望你在学习Clojure的时候不会有太大的差异感!&lt;/p&gt;

&lt;p&gt;在Java中,我们出于各种目的而使用类.例如典型的使用Spring的web应用,你会看到类似下面的结构:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data transfer objects(DTO)&lt;/li&gt;
&lt;li&gt;Services(REST API,controllers,DAO)&lt;/li&gt;
&lt;li&gt;Rich object&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;DTO实际上就是个结构体,他没有任何的行为(即方法).为了最小化样板代码,我趋向于使用pulibc final属性去实现DTO.我认为DTO就是个模板(schema),它就像一个REST服务输出的文件.但是我发现很多客户端开发人员可不关注这个,而只关注代码形式.有时你会看到DTO被作为数据库访问的一部分.这些DTO被称为贫血模型.(译者注:猜测作者的意思是,有些开发人员不管类是DTO还是DAO,只要结构相同就随便用!)&lt;/p&gt;

&lt;p&gt;Service实际上是包含了方法和注入了辅助Service的单例对象.不同的辅助Service提供了不同的服务.除了实现了接口外,Service只是包含了方法,和占位符很类似.单例模式导致的一个问题就是,新手无法预见到多线程里共享相同的实例出现意外的结果.他们将状态保存到私有属性里,而不需要从一个对象传递到另一个对象.很方便,但是是错误的做法.&lt;/p&gt;

&lt;p&gt;Rich object是面向对象语言中的思想.即将数据及和数据相关的操作封装到一个类里面.我可没说getter和setter是相关操作!但是,rich object类在项目中用得较少.取而代之的是使用DTO作为Service的输入和输出.使用DAO来访问数据库,然后返回DTO.我没说这种方法是错误的,我好奇的是,既然对于目前的Java架构是好是坏我们都无法确认,那为什么还要强求使用Clojure去实现类似的东西呢?&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;先不管这么多,我们先看怎么在Clojure中做类似的事情?我直接给出如何做!&lt;/p&gt;

&lt;p&gt;首先,DTO就是数据,而Clojure擅长数据处理,例如map,list和set.但是如果你想要类似结构体的东西,Clojure里提供了record.如果你了解Scala你会发现这玩样和case class很像.定义record的方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defrecord Person [firstName lastName])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这实际上创建了一个叫Person的Java类,它包含两个不可变的属性以及实现了hashCode和equals方法.record的行为模式和map很像,所以大部分适用于map的方法都适用与record!需要注意的是,虽然Clojure是动态类型,但是你可以使用类型提示来标示特定类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defrecord Person [^String firstName ^String lastName])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好,那现在我们来看看如何定义Service!让我们将问题分解为组织相关函数,定义接口及依赖注入!&lt;/p&gt;

&lt;p&gt;和Java不同,Clojure提供了多种组织相关函数的方法.使用哪种方式完全取决于你想做什么.&lt;/p&gt;

&lt;p&gt;首先,在Clojure中,函数不需要定义到一个类里面.取而代之的是,他们通过命名空间类管理,命名空间类似于Java中的包.如果你没有任何特别的要求,那么建议使用命名空间来管理函数.&lt;/p&gt;

&lt;p&gt;如果你想定义类似class的东西,你需要先定义接口!那你需要使用protocol!你可以把它当做和Java中的接口类似的东西.实际上,除了使用protocol你也可以直接使用Java的接口,因为Clojure可以直接访问Java代码!创建protocol的方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defprotocol Greet
    (sayHello [this])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这和下面的代码功能相同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public interface Greet{
    Object sayHello();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两点需要注意:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你需要将this包含在参数列表中!在面向对象语言中默认都包含了this,在类内部调用时默认包含了this.而在外部调用方法时,是使用对象名称.方法名,比如person.sayHello().而Clojure是函数式的,方法在前,调用方式如下(sayHello person)&lt;/li&gt;
&lt;li&gt;方法返回的是Object.这是因为Clojure是函数式的,我们努力使其没有副作用.返回值为void的方法,实际上大部分是为了其副作用的!&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;实现protocol可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defrecord Person [firstName lastName]
    Greet
    (sayHello [this] (print &quot;Hello,my name is &quot; firstName)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后就是依赖注入了!结论是:依赖注入对与Clojure来说不是必要的!可以看看下面两篇文章!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tech.puredanger.com/2010/03/01/dependency-injection-clojure/&quot;&gt;Dependency injection in
Clojure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/13085370/what-is-the-clojure-equivalent-to-google-guice&quot;&gt;What is the Clojure equivalent to Google
Guice?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;从Java过渡到Scala相对来说比较简单,因为你可以在Scala中编写类Java的代码,然后再慢慢过渡到函数式代码编写上.但是对于Clojure来说,没有这个过渡过程,所以比较难于适应!但是通过使用record和protocol可以使你能在Clojure中做类似Java的事情,从而简化你的过渡难度!&lt;/p&gt;

&lt;h1&gt;个人感受&lt;/h1&gt;

&lt;p&gt;不知道是英文不行,还是作者行文有问题!感觉作者的文字不够流畅!按照原文直译,总感觉不通顺!故做了删减调整!&lt;/p&gt;

&lt;p&gt;对于依赖注入提供的两篇文章,评论比文章好得多!特别是第二篇的第一个评论!其实本文就简单介绍了Clojure的record和protocol入门而已!&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;本文翻译自:&lt;a href=&quot;http://www.jayway.com/2013/02/05/learn-clojure-using-records-and-protocols/&quot;&gt;Learn Clojure using records and protocols&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当我对Clojure的括号不再疑惑后,另一个让我质疑为何要学习Clojure的问题是使用REPL很爽,但是我怎么来构建大型项目?&quot;.&lt;/p&gt;

&lt;p&gt;实际上,由于我的面向对象编程经验,我其实要问的是&quot;我怎么才能将函数封装到类似class的东西里面去?&quot;.&lt;/p&gt;

&lt;p&gt;在本文中,我将会介绍一种类似于Java的方式来构建大型的Clojure项目.&lt;/p&gt;

&lt;p&gt;通过这种方式,希望你在学习Clojure的时候不会有太大的差异感!&lt;/p&gt;

&lt;p&gt;在Java中,我们出于各种目的而使用类.例如典型的使用Spring的web应用,你会看到类似下面的结构:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data transfer objects(DTO)&lt;/li&gt;
&lt;li&gt;Services(REST API,controllers,DAO)&lt;/li&gt;
&lt;li&gt;Rich object&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;DTO实际上就是个结构体,他没有任何的行为(即方法).为了最小化样板代码,我趋向于使用pulibc final属性去实现DTO.我认为DTO就是个模板(schema),它就像一个REST服务输出的文件.但是我发现很多客户端开发人员可不关注这个,而只关注代码形式.有时你会看到DTO被作为数据库访问的一部分.这些DTO被称为贫血模型.(译者注:猜测作者的意思是,有些开发人员不管类是DTO还是DAO,只要结构相同就随便用!)&lt;/p&gt;

&lt;p&gt;Service实际上是包含了方法和注入了辅助Service的单例对象.不同的辅助Service提供了不同的服务.除了实现了接口外,Service只是包含了方法,和占位符很类似.单例模式导致的一个问题就是,新手无法预见到多线程里共享相同的实例出现意外的结果.他们将状态保存到私有属性里,而不需要从一个对象传递到另一个对象.很方便,但是是错误的做法.&lt;/p&gt;

&lt;p&gt;Rich object是面向对象语言中的思想.即将数据及和数据相关的操作封装到一个类里面.我可没说getter和setter是相关操作!但是,rich object类在项目中用得较少.取而代之的是使用DTO作为Service的输入和输出.使用DAO来访问数据库,然后返回DTO.我没说这种方法是错误的,我好奇的是,既然对于目前的Java架构是好是坏我们都无法确认,那为什么还要强求使用Clojure去实现类似的东西呢?&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;先不管这么多,我们先看怎么在Clojure中做类似的事情?我直接给出如何做!&lt;/p&gt;

&lt;p&gt;首先,DTO就是数据,而Clojure擅长数据处理,例如map,list和set.但是如果你想要类似结构体的东西,Clojure里提供了record.如果你了解Scala你会发现这玩样和case class很像.定义record的方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defrecord Person [firstName lastName])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这实际上创建了一个叫Person的Java类,它包含两个不可变的属性以及实现了hashCode和equals方法.record的行为模式和map很像,所以大部分适用于map的方法都适用与record!需要注意的是,虽然Clojure是动态类型,但是你可以使用类型提示来标示特定类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defrecord Person [^String firstName ^String lastName])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好,那现在我们来看看如何定义Service!让我们将问题分解为组织相关函数,定义接口及依赖注入!&lt;/p&gt;

&lt;p&gt;和Java不同,Clojure提供了多种组织相关函数的方法.使用哪种方式完全取决于你想做什么.&lt;/p&gt;

&lt;p&gt;首先,在Clojure中,函数不需要定义到一个类里面.取而代之的是,他们通过命名空间类管理,命名空间类似于Java中的包.如果你没有任何特别的要求,那么建议使用命名空间来管理函数.&lt;/p&gt;

&lt;p&gt;如果你想定义类似class的东西,你需要先定义接口!那你需要使用protocol!你可以把它当做和Java中的接口类似的东西.实际上,除了使用protocol你也可以直接使用Java的接口,因为Clojure可以直接访问Java代码!创建protocol的方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defprotocol Greet
    (sayHello [this])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这和下面的代码功能相同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public interface Greet{
    Object sayHello();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有两点需要注意:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你需要将this包含在参数列表中!在面向对象语言中默认都包含了this,在类内部调用时默认包含了this.而在外部调用方法时,是使用对象名称.方法名,比如person.sayHello().而Clojure是函数式的,方法在前,调用方式如下(sayHello person)&lt;/li&gt;
&lt;li&gt;方法返回的是Object.这是因为Clojure是函数式的,我们努力使其没有副作用.返回值为void的方法,实际上大部分是为了其副作用的!&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;实现protocol可以使用如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defrecord Person [firstName lastName]
    Greet
    (sayHello [this] (print &quot;Hello,my name is &quot; firstName)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后就是依赖注入了!结论是:依赖注入对与Clojure来说不是必要的!可以看看下面两篇文章!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tech.puredanger.com/2010/03/01/dependency-injection-clojure/&quot;&gt;Dependency injection in
Clojure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/13085370/what-is-the-clojure-equivalent-to-google-guice&quot;&gt;What is the Clojure equivalent to Google
Guice?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;从Java过渡到Scala相对来说比较简单,因为你可以在Scala中编写类Java的代码,然后再慢慢过渡到函数式代码编写上.但是对于Clojure来说,没有这个过渡过程,所以比较难于适应!但是通过使用record和protocol可以使你能在Clojure中做类似Java的事情,从而简化你的过渡难度!&lt;/p&gt;

&lt;h1&gt;个人感受&lt;/h1&gt;

&lt;p&gt;不知道是英文不行,还是作者行文有问题!感觉作者的文字不够流畅!按照原文直译,总感觉不通顺!故做了删减调整!&lt;/p&gt;

&lt;p&gt;对于依赖注入提供的两篇文章,评论比文章好得多!特别是第二篇的第一个评论!其实本文就简单介绍了Clojure的record和protocol入门而已!&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-函数</title>
        <link href="http://ivanpig.github.io/2014/03/15/function.html"/>
        <updated>2014-03-15T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/03/15/function</id>
        <content type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/language/functions.html&quot;&gt;Functions in Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文包括如下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何定义函数&lt;/li&gt;
&lt;li&gt;如何执行函数&lt;/li&gt;
&lt;li&gt;多元数函数(Multi-arity Functions)&lt;/li&gt;
&lt;li&gt;不定参函数(Variadic Functions)&lt;/li&gt;
&lt;li&gt;高阶函数&lt;/li&gt;
&lt;li&gt;其它函数相关内容&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets). The source is available on Github.&lt;/p&gt;

&lt;h1&gt;针对Clojure版本&lt;/h1&gt;

&lt;p&gt;Clojure 1.5&lt;/p&gt;

&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;Clojure是函数式编程语言.自然的,函数是Clojure非常重要的一部分.&lt;/p&gt;

&lt;h1&gt;如何定义函数&lt;/h1&gt;

&lt;p&gt;函数定义一般使用defn宏:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  [d precision]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型提示有时能避免编译器使用反射,从而能生成更高效的字节码.但是,基本上你没必要使用类型提示.后期优化时再考虑.&lt;/p&gt;

&lt;p&gt;函数可以添加注释文档,给API添加文档说明是个好习惯:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  &quot;Round down a double to the given precision (number of significant digits)&quot;
  [d precision]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Clojure中函数参数可以有类型提示,不过是可选的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  [^double d ^long precision]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数还可以定义前置和后置条件来限制函数的参数和返回值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  &quot;Round down a double to the given precision (number of significant digits)&quot;
  [^double d ^long precision]
  {:pre [(not-nil? d) (not-nil? precision)]}
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,我们使用了前置条件来检查两个参数是否为nil.&lt;/p&gt;

&lt;p&gt;not-nil?宏(或函数),没有在该例子中展示,我们假设它已经在其它地方实现了.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;匿名函数&lt;/h1&gt;

&lt;p&gt;匿名函数使用fn特殊形式来定义;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(fn [x]
  (* 2 x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名函数可以赋给局部变量,作为参数传递给函数或作为函数的返回值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [f (fn [x]
          (* 2 x))]
  (map f (range 0 10)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojure提供了语法糖来简化匿名函数的编写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [f #(* 2 %)]
  (map f (range 0 10)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;%表示第一个参数.如果要引用多个参数,可以使用%1,%2.以此类推:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 一个包含了三个参数的匿名函数,返回三个参数的和
(let [f #(+ %1 %2 %3)]
  (f 1 2 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;语法糖简化了代码,但是降低了代码的可读性.所以使用前请斟酌.&lt;/p&gt;

&lt;h1&gt;如何执行函数&lt;/h1&gt;

&lt;p&gt;要执行函数,只需要将函数名放在list的第一个位置就行了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(format &quot;Hello, %s&quot; &quot;world&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于赋给局部变量,变量或这从参数传递的函数,此法同样适用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [f format]
  (f &quot;Hello, %s&quot; &quot;world&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外你也可以使用clojure.core/apply来执行函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply format &quot;Hello, %s&quot; [&quot;world&quot;])

(apply format &quot;Hello, %s %s&quot; [&quot;Clojure&quot; &quot;world&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clojure.core/apply一般在调用不定参函数或者需要将参数作为集合传递时才会使用&lt;/p&gt;

&lt;h1&gt;多元数函数&lt;/h1&gt;

&lt;p&gt;在Clojure中有多元数函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn tax-amount
  ([amount]
     (tax-amount amount 35))
  ([amount rate]
     (Math/round (double (* amount (/ rate 100))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,只有一个参数的函数调用了有两个参数的函数.这在多参函数中很常见(相当于默认值的功能).Clojure没有提供默认值的功能,是因为JVM不支持.&lt;/p&gt;

&lt;p&gt;在Clojure中,元数只和参数个数有关,而和参数类型无关.这是因为Clojure是动态语言,类型信息可能在编译期是无效的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn range
  ([]
    (range 0 Double/POSITIVE_INFINITY 1))
  ([end]
    (range 0 end 1))
  ([start end]
    (range start end 1))
  ([start end step]
    (comment Omitted for clarity)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;解构函数参数&lt;/h1&gt;

&lt;p&gt;有时函数的参数是数据结构:向量,序列,map.当你想访问这些数据结构的其中一部分数据时,你可能需要编写类似下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [m]
  (let [currency (get m :currency)]
    currency))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对向量来说,需要编写类似这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [pair]
  (let [amount   (first  pair)
        currency (second pair)]
    currency))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是呢,这样的样板代码可重用性并不高.所以Clojure提供了解构.&lt;/p&gt;

&lt;h2&gt;基于位置的解构&lt;/h2&gt;

&lt;p&gt;解构向量的方式如下:使用一个向量替换原来作为函数参数的数据结构,这个向量包含了占位符,而占位符会将对应位置的数据结构的值绑定过来.&lt;/p&gt;

&lt;p&gt;举例来说,如果一个参数是一对值,你想要获得第二个参数值,那么代码可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [[amount currency]]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,参数的第一个值被绑定到了amount上,第二个参数是被绑定到了currency上.看起来很棒,但是,这里我们并没有使用amount.在这种情况下,我们可以使用下划线来忽略它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [[_ currency]]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解构是能够嵌套的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn first-first
  [[[i _] _]]
  i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然本文不会涉及到let这个form和本地变量.但是需要提一下,解构对let也生效,而且作用一模一样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [pair         [10 :gbp]
      [_ currency] pair]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;解构Map&lt;/h2&gt;

&lt;p&gt;对Map和Record的解构方式与解构向量略有不同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{currency :currency}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,我们想把:currency这个key对应的value绑定到currency上.Key并不一定需要是关键字:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{currency &quot;currency&quot;}]
  currency)

(defn currency-of
  [{currency 'currency}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以一次性解构多个key:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:keys [currency amount]}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中,keys需要为关键字,其名字与currency和amount相同(即:currency,:amount).如果keys是字符串,则将上面的:keys改为:strs即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:strs [currency amount]}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以是symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:syms [currency amount]}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了,使用关键字作为key在Clojure中是推荐做法.&lt;/p&gt;

&lt;p&gt;解构Map时,如果找不到我们需要的key的值,我们可以设置默认值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:keys [currency amount] :or {currency :gbp}}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此功能对于编写包含额外属性的函数大有裨益.和基于位置的解构相同,Map解构对let同样适用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [money               {:currency :gbp :amount 10}
     {currency :currency} money]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;变参函数&lt;/h1&gt;

&lt;p&gt;参数数量可变的函数叫做变参函数.clojure.core/str和clojure.core/format就是两个变参函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(str &quot;a&quot; &quot;b&quot;)      ; ⇒ &quot;ab&quot;
(str &quot;a&quot; &quot;b&quot; &quot;c&quot;)  ; ⇒ &quot;abc&quot;

(format &quot;Hello, %s&quot; &quot;world&quot;)               ; ⇒ &quot;Hello, world&quot;
(format &quot;Hello, %s %s&quot; &quot;Clojure&quot; &quot;world&quot;)  ; ⇒ &quot;Hello, Clojure world&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要定义变参函数,只需要在变参前面加个&amp;amp;就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn log
  [message &amp;amp; args]
  (comment ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,只有一个参数是必须的.变参函数的调用方式和普通函数相同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn log
  [message &amp;amp; args]
  (println &quot;args: &quot; args))

(log &quot;message from &quot; &quot;192.0.0.76&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在REPL中执行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (log &quot;message from &quot; &quot;192.0.0.76&quot;)
args:  (192.0.0.76)

user=&amp;gt; (log &quot;message from &quot; &quot;192.0.0.76&quot; &quot;service:xyz&quot;)
args:  (192.0.0.76 service:xyz)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以看到,可选的参数被包装到了一个list里面.&lt;/p&gt;

&lt;h2&gt;具名参数(Named Parameters)&lt;/h2&gt;

&lt;p&gt;具名参数是通过对变参函数的解构来实现的.&lt;/p&gt;

&lt;p&gt;从解构变参函数的立场上来看,具名参数具有较好的可读性.下面是一个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn job-info
  [&amp;amp; {:keys [name job income] :or {job &quot;unemployed&quot; income &quot;$0.00&quot;}}]
  (if name
    [name job income]
    (println &quot;No name specified&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用函数方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (job-info :name &quot;Robert&quot; :job &quot;Engineer&quot;)
[&quot;Robert&quot; &quot;Engineer&quot; &quot;$0.00&quot;]

user=&amp;gt; (job-info :job &quot;Engineer&quot;)
No name specified
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不使用变参列表,那么你需要使用形如{:name &quot;Robert&quot; :job &quot;Engineer&quot;}这样的map作为参数.&lt;/p&gt;

&lt;p&gt;关键字的默认值依据:or后跟的map来确定.如果关键字没有传递值,且无默认值,则为nil.&lt;/p&gt;

&lt;h1&gt;高阶函数&lt;/h1&gt;

&lt;p&gt;高阶函数是将其它函数作为参数的函数.高阶函数在函数式编程中是很重要的技术,在Clojure中经常使用到.一个高阶函数的例子是将一个函数和一个集合作为参数,返回符合这个函数条件的集合.在Clojure中,这叫做clojure.core/filter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(filter even? (range 0 10))  ;=&amp;gt;(0 2 4 6 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中,clojure.core/filter函数接收clojure.core/even?作为参数.
clojure.core中有很多高阶函数.经常使用的函数请参见&lt;a href=&quot;http://clojure-doc.org/articles/language/core_overview.html&quot;&gt;clojure.core&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;私有函数&lt;/h1&gt;

&lt;p&gt;在Clojure中,函数可以在其命名空间中设置为私有的.&lt;/p&gt;

&lt;p&gt;具体细节请参考&lt;a href=&quot;http://clojure-doc.org/articles/language/namespaces.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;关键字作为函数&lt;/h1&gt;

&lt;p&gt;在Clojure中,关键字可以作为函数使用.他们接收map或record并从中查找信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:age {:age 27 :name &quot;Michael&quot;})  ; ⇒ 27
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们经常和高阶函数结合使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(map :age [{:age 45 :name &quot;Joe&quot;} {:age 42 :name &quot;Jill&quot;} {:age 17 :name &quot;Matt&quot;}])  ; ⇒ (45 42 17)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也能和-&gt;宏一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(-&amp;gt; [{:age 45 :name &quot;Joe&quot;} {:age 42 :name &quot;Jill&quot;}] first :name)  ; ⇒ &quot;Joe&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Map作为函数&lt;/h1&gt;

&lt;p&gt;Clojure的Map也能作为函数使用,来查找key对应的value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;({:age 42 :name &quot;Joe&quot;} :name)     ; ⇒ &quot;Joe&quot;
({:age 42 :name &quot;Joe&quot;} :age)      ; ⇒ 42
({:age 42 :name &quot;Joe&quot;} :unknown)  ; ⇒ nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是,虽然大部分情况下map和record可以等同对待,但是这里不行!record不能作为函数使用!&lt;/p&gt;

&lt;h1&gt;Set作为函数&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(#{1 2 3} 1)   ; ⇒ 1
(#{1 2 3} 10)  ; ⇒ nil

(#{:us :au :ru :uk} :uk)  ; ⇒ :uk
(#{:us :au :ru :uk} :cn)  ; ⇒ nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此功能被用来验证某值是否在set中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(when (countries :in)
  (comment ...))

(if (countries :in)
  (comment Implement positive case)
  (comment Implement negative case))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为在Clojure中除了false和nil,其它值都是true.&lt;/p&gt;

&lt;h1&gt;函数作为比较器&lt;/h1&gt;

&lt;p&gt;Clojure函数实现了java.util.Comparator接口,所以能作为比较器使用.&lt;/p&gt;

&lt;h1&gt;结束语&lt;/h1&gt;

&lt;p&gt;函数是Clojure的核心.他们通过defn宏来定义,可以有多个元数,不定参数并支持参数解构.&lt;/p&gt;

&lt;p&gt;函数参数和返回值可以有类型提示,当然这不是必须的.&lt;/p&gt;

&lt;p&gt;函数是一等值,它能被传递给其它函数.这是函数式编程的基石.&lt;/p&gt;

&lt;p&gt;有一些数据类型有函数特性.适时的使用这些特性可以是代码更简洁易读.&lt;/p&gt;

&lt;h1&gt;贡献&lt;/h1&gt;

&lt;p&gt;Michael Klishin michael@defprotocol.org, 2012 (original author)
Translated by Ivan 2014&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/language/functions.html&quot;&gt;Functions in Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文包括如下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何定义函数&lt;/li&gt;
&lt;li&gt;如何执行函数&lt;/li&gt;
&lt;li&gt;多元数函数(Multi-arity Functions)&lt;/li&gt;
&lt;li&gt;不定参函数(Variadic Functions)&lt;/li&gt;
&lt;li&gt;高阶函数&lt;/li&gt;
&lt;li&gt;其它函数相关内容&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets). The source is available on Github.&lt;/p&gt;

&lt;h1&gt;针对Clojure版本&lt;/h1&gt;

&lt;p&gt;Clojure 1.5&lt;/p&gt;

&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;Clojure是函数式编程语言.自然的,函数是Clojure非常重要的一部分.&lt;/p&gt;

&lt;h1&gt;如何定义函数&lt;/h1&gt;

&lt;p&gt;函数定义一般使用defn宏:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  [d precision]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型提示有时能避免编译器使用反射,从而能生成更高效的字节码.但是,基本上你没必要使用类型提示.后期优化时再考虑.&lt;/p&gt;

&lt;p&gt;函数可以添加注释文档,给API添加文档说明是个好习惯:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  &quot;Round down a double to the given precision (number of significant digits)&quot;
  [d precision]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Clojure中函数参数可以有类型提示,不过是可选的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  [^double d ^long precision]
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数还可以定义前置和后置条件来限制函数的参数和返回值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn round
  &quot;Round down a double to the given precision (number of significant digits)&quot;
  [^double d ^long precision]
  {:pre [(not-nil? d) (not-nil? precision)]}
  (let [factor (Math/pow 10 precision)]
    (/ (Math/floor (* d factor)) factor)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,我们使用了前置条件来检查两个参数是否为nil.&lt;/p&gt;

&lt;p&gt;not-nil?宏(或函数),没有在该例子中展示,我们假设它已经在其它地方实现了.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;匿名函数&lt;/h1&gt;

&lt;p&gt;匿名函数使用fn特殊形式来定义;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(fn [x]
  (* 2 x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名函数可以赋给局部变量,作为参数传递给函数或作为函数的返回值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [f (fn [x]
          (* 2 x))]
  (map f (range 0 10)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clojure提供了语法糖来简化匿名函数的编写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [f #(* 2 %)]
  (map f (range 0 10)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;%表示第一个参数.如果要引用多个参数,可以使用%1,%2.以此类推:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 一个包含了三个参数的匿名函数,返回三个参数的和
(let [f #(+ %1 %2 %3)]
  (f 1 2 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;语法糖简化了代码,但是降低了代码的可读性.所以使用前请斟酌.&lt;/p&gt;

&lt;h1&gt;如何执行函数&lt;/h1&gt;

&lt;p&gt;要执行函数,只需要将函数名放在list的第一个位置就行了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(format &quot;Hello, %s&quot; &quot;world&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于赋给局部变量,变量或这从参数传递的函数,此法同样适用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [f format]
  (f &quot;Hello, %s&quot; &quot;world&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外你也可以使用clojure.core/apply来执行函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply format &quot;Hello, %s&quot; [&quot;world&quot;])

(apply format &quot;Hello, %s %s&quot; [&quot;Clojure&quot; &quot;world&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clojure.core/apply一般在调用不定参函数或者需要将参数作为集合传递时才会使用&lt;/p&gt;

&lt;h1&gt;多元数函数&lt;/h1&gt;

&lt;p&gt;在Clojure中有多元数函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn tax-amount
  ([amount]
     (tax-amount amount 35))
  ([amount rate]
     (Math/round (double (* amount (/ rate 100))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,只有一个参数的函数调用了有两个参数的函数.这在多参函数中很常见(相当于默认值的功能).Clojure没有提供默认值的功能,是因为JVM不支持.&lt;/p&gt;

&lt;p&gt;在Clojure中,元数只和参数个数有关,而和参数类型无关.这是因为Clojure是动态语言,类型信息可能在编译期是无效的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn range
  ([]
    (range 0 Double/POSITIVE_INFINITY 1))
  ([end]
    (range 0 end 1))
  ([start end]
    (range start end 1))
  ([start end step]
    (comment Omitted for clarity)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;解构函数参数&lt;/h1&gt;

&lt;p&gt;有时函数的参数是数据结构:向量,序列,map.当你想访问这些数据结构的其中一部分数据时,你可能需要编写类似下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [m]
  (let [currency (get m :currency)]
    currency))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对向量来说,需要编写类似这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [pair]
  (let [amount   (first  pair)
        currency (second pair)]
    currency))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是呢,这样的样板代码可重用性并不高.所以Clojure提供了解构.&lt;/p&gt;

&lt;h2&gt;基于位置的解构&lt;/h2&gt;

&lt;p&gt;解构向量的方式如下:使用一个向量替换原来作为函数参数的数据结构,这个向量包含了占位符,而占位符会将对应位置的数据结构的值绑定过来.&lt;/p&gt;

&lt;p&gt;举例来说,如果一个参数是一对值,你想要获得第二个参数值,那么代码可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [[amount currency]]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,参数的第一个值被绑定到了amount上,第二个参数是被绑定到了currency上.看起来很棒,但是,这里我们并没有使用amount.在这种情况下,我们可以使用下划线来忽略它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [[_ currency]]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解构是能够嵌套的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn first-first
  [[[i _] _]]
  i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然本文不会涉及到let这个form和本地变量.但是需要提一下,解构对let也生效,而且作用一模一样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [pair         [10 :gbp]
      [_ currency] pair]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;解构Map&lt;/h2&gt;

&lt;p&gt;对Map和Record的解构方式与解构向量略有不同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{currency :currency}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,我们想把:currency这个key对应的value绑定到currency上.Key并不一定需要是关键字:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{currency &quot;currency&quot;}]
  currency)

(defn currency-of
  [{currency 'currency}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以一次性解构多个key:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:keys [currency amount]}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中,keys需要为关键字,其名字与currency和amount相同(即:currency,:amount).如果keys是字符串,则将上面的:keys改为:strs即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:strs [currency amount]}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以是symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:syms [currency amount]}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了,使用关键字作为key在Clojure中是推荐做法.&lt;/p&gt;

&lt;p&gt;解构Map时,如果找不到我们需要的key的值,我们可以设置默认值:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn currency-of
  [{:keys [currency amount] :or {currency :gbp}}]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此功能对于编写包含额外属性的函数大有裨益.和基于位置的解构相同,Map解构对let同样适用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [money               {:currency :gbp :amount 10}
     {currency :currency} money]
  currency)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;变参函数&lt;/h1&gt;

&lt;p&gt;参数数量可变的函数叫做变参函数.clojure.core/str和clojure.core/format就是两个变参函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(str &quot;a&quot; &quot;b&quot;)      ; ⇒ &quot;ab&quot;
(str &quot;a&quot; &quot;b&quot; &quot;c&quot;)  ; ⇒ &quot;abc&quot;

(format &quot;Hello, %s&quot; &quot;world&quot;)               ; ⇒ &quot;Hello, world&quot;
(format &quot;Hello, %s %s&quot; &quot;Clojure&quot; &quot;world&quot;)  ; ⇒ &quot;Hello, Clojure world&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要定义变参函数,只需要在变参前面加个&amp;amp;就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn log
  [message &amp;amp; args]
  (comment ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中,只有一个参数是必须的.变参函数的调用方式和普通函数相同:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn log
  [message &amp;amp; args]
  (println &quot;args: &quot; args))

(log &quot;message from &quot; &quot;192.0.0.76&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在REPL中执行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (log &quot;message from &quot; &quot;192.0.0.76&quot;)
args:  (192.0.0.76)

user=&amp;gt; (log &quot;message from &quot; &quot;192.0.0.76&quot; &quot;service:xyz&quot;)
args:  (192.0.0.76 service:xyz)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以看到,可选的参数被包装到了一个list里面.&lt;/p&gt;

&lt;h2&gt;具名参数(Named Parameters)&lt;/h2&gt;

&lt;p&gt;具名参数是通过对变参函数的解构来实现的.&lt;/p&gt;

&lt;p&gt;从解构变参函数的立场上来看,具名参数具有较好的可读性.下面是一个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn job-info
  [&amp;amp; {:keys [name job income] :or {job &quot;unemployed&quot; income &quot;$0.00&quot;}}]
  (if name
    [name job income]
    (println &quot;No name specified&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用函数方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;user=&amp;gt; (job-info :name &quot;Robert&quot; :job &quot;Engineer&quot;)
[&quot;Robert&quot; &quot;Engineer&quot; &quot;$0.00&quot;]

user=&amp;gt; (job-info :job &quot;Engineer&quot;)
No name specified
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不使用变参列表,那么你需要使用形如{:name &quot;Robert&quot; :job &quot;Engineer&quot;}这样的map作为参数.&lt;/p&gt;

&lt;p&gt;关键字的默认值依据:or后跟的map来确定.如果关键字没有传递值,且无默认值,则为nil.&lt;/p&gt;

&lt;h1&gt;高阶函数&lt;/h1&gt;

&lt;p&gt;高阶函数是将其它函数作为参数的函数.高阶函数在函数式编程中是很重要的技术,在Clojure中经常使用到.一个高阶函数的例子是将一个函数和一个集合作为参数,返回符合这个函数条件的集合.在Clojure中,这叫做clojure.core/filter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(filter even? (range 0 10))  ;=&amp;gt;(0 2 4 6 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子中,clojure.core/filter函数接收clojure.core/even?作为参数.
clojure.core中有很多高阶函数.经常使用的函数请参见&lt;a href=&quot;http://clojure-doc.org/articles/language/core_overview.html&quot;&gt;clojure.core&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;私有函数&lt;/h1&gt;

&lt;p&gt;在Clojure中,函数可以在其命名空间中设置为私有的.&lt;/p&gt;

&lt;p&gt;具体细节请参考&lt;a href=&quot;http://clojure-doc.org/articles/language/namespaces.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;关键字作为函数&lt;/h1&gt;

&lt;p&gt;在Clojure中,关键字可以作为函数使用.他们接收map或record并从中查找信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:age {:age 27 :name &quot;Michael&quot;})  ; ⇒ 27
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他们经常和高阶函数结合使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(map :age [{:age 45 :name &quot;Joe&quot;} {:age 42 :name &quot;Jill&quot;} {:age 17 :name &quot;Matt&quot;}])  ; ⇒ (45 42 17)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也能和-&gt;宏一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(-&amp;gt; [{:age 45 :name &quot;Joe&quot;} {:age 42 :name &quot;Jill&quot;}] first :name)  ; ⇒ &quot;Joe&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Map作为函数&lt;/h1&gt;

&lt;p&gt;Clojure的Map也能作为函数使用,来查找key对应的value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;({:age 42 :name &quot;Joe&quot;} :name)     ; ⇒ &quot;Joe&quot;
({:age 42 :name &quot;Joe&quot;} :age)      ; ⇒ 42
({:age 42 :name &quot;Joe&quot;} :unknown)  ; ⇒ nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是,虽然大部分情况下map和record可以等同对待,但是这里不行!record不能作为函数使用!&lt;/p&gt;

&lt;h1&gt;Set作为函数&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(#{1 2 3} 1)   ; ⇒ 1
(#{1 2 3} 10)  ; ⇒ nil

(#{:us :au :ru :uk} :uk)  ; ⇒ :uk
(#{:us :au :ru :uk} :cn)  ; ⇒ nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此功能被用来验证某值是否在set中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(when (countries :in)
  (comment ...))

(if (countries :in)
  (comment Implement positive case)
  (comment Implement negative case))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为在Clojure中除了false和nil,其它值都是true.&lt;/p&gt;

&lt;h1&gt;函数作为比较器&lt;/h1&gt;

&lt;p&gt;Clojure函数实现了java.util.Comparator接口,所以能作为比较器使用.&lt;/p&gt;

&lt;h1&gt;结束语&lt;/h1&gt;

&lt;p&gt;函数是Clojure的核心.他们通过defn宏来定义,可以有多个元数,不定参数并支持参数解构.&lt;/p&gt;

&lt;p&gt;函数参数和返回值可以有类型提示,当然这不是必须的.&lt;/p&gt;

&lt;p&gt;函数是一等值,它能被传递给其它函数.这是函数式编程的基石.&lt;/p&gt;

&lt;p&gt;有一些数据类型有函数特性.适时的使用这些特性可以是代码更简洁易读.&lt;/p&gt;

&lt;h1&gt;贡献&lt;/h1&gt;

&lt;p&gt;Michael Klishin michael@defprotocol.org, 2012 (original author)
Translated by Ivan 2014&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-数学计算</title>
        <link href="http://ivanpig.github.io/2014/02/19/math.html"/>
        <updated>2014-02-19T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/02/19/math</id>
        <content type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/cookbooks/math.html&quot;&gt;Mathematics with Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文包含了使用Clojure的内建函数,扩展包和部分JDK功能进行数学计算.&lt;/p&gt;

&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported
License (including images &amp;amp; stylesheets). The source is available on
Github.&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;p&gt;这里的一些例子使用了&lt;a href=&quot;https://github.com/clojure/math.numeric-tower&quot;&gt;math.numeric-tower&lt;/a&gt;和&lt;a href=&quot;https://github.com/clojure/math.combinatorics&quot;&gt;math.combinatorics&lt;/a&gt;库.所以需要
你在代码的命名空间中包含如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [clojure.math.numeric-tower :as math]
          [clojure.math.combinatorics :as combo])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在REPL里载入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[clojure.math.numeric-tower :as math])
(require '[clojure.math.combinatorics :as combo])
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;方法&lt;/h1&gt;

&lt;h2&gt;简单计算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(+ 3 4)    ;=&amp;gt; 7
(- 3 4)    ;=&amp;gt; -1
(* 3 4)    ;=&amp;gt; 12
(/ 3 4)    ;=&amp;gt; 3/4  (an exact ratio)
(/ 3.0 4)  ;=&amp;gt; 0.75

(inc 5)    ;=&amp;gt; 6
(dec 5)    ;=&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要计算整数的除法,取余和取模,请看&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/quot&quot;&gt;quot&lt;/a&gt;,&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/rem&quot;&gt;rem&lt;/a&gt;,&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/mod&quot;&gt;mod&lt;/a&gt;
想计算指数的平方根,四舍五入,上下限,绝对值和最大公约数/最小公倍数,请看&lt;a href=&quot;http://clojure.github.com/math.numeric-tower/&quot;&gt;math.numeric-tower&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;三角函数&lt;/h2&gt;

&lt;p&gt;使用Java平台提供的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;Math/PI       ;=&amp;gt; 3.14159...
(Math/sin x)
(Math/cos x)
(Math/tan x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有很多的函数,你可以查看&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html&quot;&gt;java.lang.Math&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;组合数学&lt;/h2&gt;

&lt;p&gt;对于组合数学相关函数(比如:combinations和permutations),请看&lt;a href=&quot;http://clojure.github.com/math.combinatorics/&quot;&gt;math.combinatorics&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/cookbooks/math.html&quot;&gt;Mathematics with Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文包含了使用Clojure的内建函数,扩展包和部分JDK功能进行数学计算.&lt;/p&gt;

&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported
License (including images &amp;amp; stylesheets). The source is available on
Github.&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;p&gt;这里的一些例子使用了&lt;a href=&quot;https://github.com/clojure/math.numeric-tower&quot;&gt;math.numeric-tower&lt;/a&gt;和&lt;a href=&quot;https://github.com/clojure/math.combinatorics&quot;&gt;math.combinatorics&lt;/a&gt;库.所以需要
你在代码的命名空间中包含如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [clojure.math.numeric-tower :as math]
          [clojure.math.combinatorics :as combo])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在REPL里载入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[clojure.math.numeric-tower :as math])
(require '[clojure.math.combinatorics :as combo])
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;方法&lt;/h1&gt;

&lt;h2&gt;简单计算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(+ 3 4)    ;=&amp;gt; 7
(- 3 4)    ;=&amp;gt; -1
(* 3 4)    ;=&amp;gt; 12
(/ 3 4)    ;=&amp;gt; 3/4  (an exact ratio)
(/ 3.0 4)  ;=&amp;gt; 0.75

(inc 5)    ;=&amp;gt; 6
(dec 5)    ;=&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要计算整数的除法,取余和取模,请看&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/quot&quot;&gt;quot&lt;/a&gt;,&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/rem&quot;&gt;rem&lt;/a&gt;,&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/mod&quot;&gt;mod&lt;/a&gt;
想计算指数的平方根,四舍五入,上下限,绝对值和最大公约数/最小公倍数,请看&lt;a href=&quot;http://clojure.github.com/math.numeric-tower/&quot;&gt;math.numeric-tower&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;三角函数&lt;/h2&gt;

&lt;p&gt;使用Java平台提供的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;Math/PI       ;=&amp;gt; 3.14159...
(Math/sin x)
(Math/cos x)
(Math/tan x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有很多的函数,你可以查看&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html&quot;&gt;java.lang.Math&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;组合数学&lt;/h2&gt;

&lt;p&gt;对于组合数学相关函数(比如:combinations和permutations),请看&lt;a href=&quot;http://clojure.github.com/math.combinatorics/&quot;&gt;math.combinatorics&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-文件处理</title>
        <link href="http://ivanpig.github.io/2014/02/08/file.html"/>
        <updated>2014-02-08T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/02/08/file</id>
        <content type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/cookbooks/files_and_directories.html&quot;&gt;Working with Files and Directories in Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文介绍使用Clojure的clojure.java.io命名空间下的函数以及JDK相关方法来操作文件和目录.&lt;/p&gt;

&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets). The source is available on Github.&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;p&gt;请注意,在下面的例子中,&quot;io&quot;是clojure.java.io命名空间的简写引用.请确保你的ns宏包含如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [clojure.java.io :as io])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在REPL中加载了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[clojure.java.io :as io])
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;方法&lt;/h1&gt;

&lt;h2&gt;将文件读到字符串中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def a-long-string (slurp &quot;foo.txt&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意,你可以给slurp函数传递url.请看&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/slurp&quot;&gt;slurp文档&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;一行一行的读取文件&lt;/h2&gt;

&lt;p&gt;假设你想针对文件的每行内容调用my-func函数,并返回结果序列:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-open [rdr (io/reader &quot;foo.txt&quot;)]
  (doall (map my-func (line-seq rdr))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doall函数是必须的,因为map函数返回的是个lazy序列.line-seq返回的每行内容没有是去除了末尾的回车标记的,且空行将返回空字符串.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;将字符串写到文件中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spit &quot;foo.txt&quot;
      &quot;A long
multi-line string.
Bye.&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果foo.txt文件不存在则会创建,如果存在,将会覆盖其内容.如果想追加内容,而不是覆盖:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spit &quot;foo.txt&quot; &quot;file content&quot; :append true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;每次向文件中写一行&lt;/h2&gt;

&lt;p&gt;假设你想将vector里的内容写到文件中,每个元素一行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-open [wrtr (io/writer &quot;foo.txt&quot;)]
  (doseq [i my-vec]
    (.write wrtr (str i &quot;\n&quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;检查文件是否存在&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.exists (io/file &quot;filename.txt&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否是目录:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.isDirectory (io/file &quot;path/to/something&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;io/file是java.io.File对象(文件或目录).你能直接调用该对象上的方法,包括:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;exists        文件是否存在?
isDirectory   文件还是目录?
getName       获取文件名字
getParent     过去文件所在目录名称
getPath       获取文件全路径
mkdir         创建目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多内容请查看&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/io/File.html&quot;&gt;java.io.File&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;获取给定目录下的文件列表和目录列表&lt;/h2&gt;

&lt;p&gt;对于File对象:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.listFiles (io/file &quot;path/to/some-dir&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方法返回File对象序列,如果想返回字符串序列:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.list (io/file &quot;path/to/some-dir&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的结果都是列表形式的,可使用Clojure中的seq相关函数对其操作.&lt;/p&gt;

&lt;h1&gt;更多内容&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Raynes/fs&quot;&gt;https://github.com/Raynes/fs&lt;/a&gt;
&lt;a href=&quot;http://clojure.org/cheatsheet&quot;&gt;cheatsheet&lt;/a&gt;的I/O节&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/cookbooks/files_and_directories.html&quot;&gt;Working with Files and Directories in Clojure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文介绍使用Clojure的clojure.java.io命名空间下的函数以及JDK相关方法来操作文件和目录.&lt;/p&gt;

&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets). The source is available on Github.&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;p&gt;请注意,在下面的例子中,&quot;io&quot;是clojure.java.io命名空间的简写引用.请确保你的ns宏包含如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [clojure.java.io :as io])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在REPL中加载了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[clojure.java.io :as io])
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;方法&lt;/h1&gt;

&lt;h2&gt;将文件读到字符串中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def a-long-string (slurp &quot;foo.txt&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意,你可以给slurp函数传递url.请看&lt;a href=&quot;http://clojuredocs.org/clojure_core/clojure.core/slurp&quot;&gt;slurp文档&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;一行一行的读取文件&lt;/h2&gt;

&lt;p&gt;假设你想针对文件的每行内容调用my-func函数,并返回结果序列:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-open [rdr (io/reader &quot;foo.txt&quot;)]
  (doall (map my-func (line-seq rdr))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doall函数是必须的,因为map函数返回的是个lazy序列.line-seq返回的每行内容没有是去除了末尾的回车标记的,且空行将返回空字符串.&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;将字符串写到文件中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spit &quot;foo.txt&quot;
      &quot;A long
multi-line string.
Bye.&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果foo.txt文件不存在则会创建,如果存在,将会覆盖其内容.如果想追加内容,而不是覆盖:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(spit &quot;foo.txt&quot; &quot;file content&quot; :append true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;每次向文件中写一行&lt;/h2&gt;

&lt;p&gt;假设你想将vector里的内容写到文件中,每个元素一行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(with-open [wrtr (io/writer &quot;foo.txt&quot;)]
  (doseq [i my-vec]
    (.write wrtr (str i &quot;\n&quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;检查文件是否存在&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.exists (io/file &quot;filename.txt&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否是目录:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.isDirectory (io/file &quot;path/to/something&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;io/file是java.io.File对象(文件或目录).你能直接调用该对象上的方法,包括:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;exists        文件是否存在?
isDirectory   文件还是目录?
getName       获取文件名字
getParent     过去文件所在目录名称
getPath       获取文件全路径
mkdir         创建目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多内容请查看&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/io/File.html&quot;&gt;java.io.File&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;获取给定目录下的文件列表和目录列表&lt;/h2&gt;

&lt;p&gt;对于File对象:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.listFiles (io/file &quot;path/to/some-dir&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的方法返回File对象序列,如果想返回字符串序列:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.list (io/file &quot;path/to/some-dir&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的结果都是列表形式的,可使用Clojure中的seq相关函数对其操作.&lt;/p&gt;

&lt;h1&gt;更多内容&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Raynes/fs&quot;&gt;https://github.com/Raynes/fs&lt;/a&gt;
&lt;a href=&quot;http://clojure.org/cheatsheet&quot;&gt;cheatsheet&lt;/a&gt;的I/O节&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-字符串处理</title>
        <link href="http://ivanpig.github.io/2014/02/05/string.html"/>
        <updated>2014-02-05T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/02/05/string</id>
        <content type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/cookbooks/strings.html&quot;&gt;Strings&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文内容包括使用Clojure内建的函数和标准库来操作字符串,以及JDK中的相关操作.&lt;/p&gt;

&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets).&lt;/p&gt;

&lt;p&gt;源代码在&lt;a href=&quot;https://github.com/clojuredocs/guides&quot;&gt;Github&lt;/a&gt;上.&lt;/p&gt;

&lt;h1&gt;概述&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Clojure中的字符串就是Java字符串.你可以使用Java中的相应方法来对其进行处理.&lt;/li&gt;
&lt;li&gt;Java字符串是不可变的,所以能很方便的在Clojure中使用&lt;/li&gt;
&lt;li&gt;你不能给Java字符串添加元数据&lt;/li&gt;
&lt;li&gt;Clojure提供一些方便的符号&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;    &quot;foo&quot;    java.lang.String
    #&quot;\d&quot;    java.util.regex.Pattern (正则表达式,匹配一个数字)
    \f       java.lang.Character (表示'f')
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;:
人类的大脑和计算机之间还是有很大的差异的.所以Java的字符串(UTF-16编码)并不能像人们所认为的那样很好的和字符一一对应.比如说,一个Unicode的位和我们所认为的字符的一位是无法对应的(像韩国韩语尊宝,这些词由多个字符组成.)同样的,一个Unicode位可能是由2个UTF-16字符组成.&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;预备知识&lt;/h1&gt;

&lt;p&gt;一些例子用到了clojure.string,clojure.edn和clojure.pprint.我们假设你的ns宏里面已经包含了如下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [clojure.string :as str]
          [clojure.edn :as edn]
          [clojure.pprint :as pp])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在REPL里面,你需要载入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[clojure.string :as str])
(require '[clojure.edn :as edn])
(require '[clojure.pprint :as pp])
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;方法&lt;/h1&gt;

&lt;h2&gt;基础方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 长度计算
(count &quot;0123&quot;)      ;=&amp;gt; 4
(empty? &quot;0123&quot;)     ;=&amp;gt; false
(empty? &quot;&quot;)         ;=&amp;gt; true
(str/blank? &quot;    &quot;) ;=&amp;gt; true

;; 字符串连接
(str &quot;foo&quot; &quot;bar&quot;)            ;=&amp;gt; &quot;foobar&quot;
(str/join [&quot;0&quot; &quot;1&quot; &quot;2&quot;])     ;=&amp;gt; &quot;012&quot;
(str/join &quot;.&quot; [&quot;0&quot; &quot;1&quot; &quot;2&quot;]) ;=&amp;gt; &quot;0.1.2&quot;

;; 使用Java方法来匹配.
;;
;; 对于下面的情况,你应该更喜欢使用正则表达式.比如,你在进行测试,当失败时需要返回-1.
;; 或者一个字符\o需要转换成字符串或数字.
(.indexOf &quot;foo&quot; &quot;oo&quot;)         ;=&amp;gt; 1
(.indexOf &quot;foo&quot; &quot;x&quot;)          ;=&amp;gt; -1
(.lastIndexOf &quot;foo&quot; (int \o)) ;=&amp;gt; 2

;; 字符串截取
(subs &quot;0123&quot; 1)       ;=&amp;gt; &quot;123&quot;
(subs &quot;0123&quot; 1 3)     ;=&amp;gt; &quot;12&quot;
(str/trim &quot;  foo  &quot;)  ;=&amp;gt; &quot;foo&quot;
(str/triml &quot;  foo  &quot;) ;=&amp;gt; &quot;foo  &quot;
(str/trimr &quot;  foo  &quot;) ;=&amp;gt; &quot;  foo&quot;

;; 切分字符串
(seq &quot;foo&quot;)                       ;=&amp;gt; (\f \o \o)
(str/split &quot;foo/bar/quux&quot; #&quot;/&quot;)   ;=&amp;gt; [&quot;foo&quot; &quot;bar&quot; &quot;quux&quot;]
(str/split &quot;foo/bar/quux&quot; #&quot;/&quot; 2) ;=&amp;gt; [&quot;foo&quot; &quot;bar/quux&quot;]
(str/split-lines &quot;foo
bar&quot;)                             ;=&amp;gt; [&quot;foo&quot; &quot;bar&quot;]

;; 大小写转换
(str/lower-case &quot;fOo&quot;) ;=&amp;gt; &quot;foo&quot;
(str/upper-case &quot;fOo&quot;) ;=&amp;gt; &quot;FOO&quot;
(str/capitalize &quot;fOo&quot;) ;=&amp;gt; &quot;Foo&quot;

;; 转换
(str/escape &quot;foo|bar|quux&quot; {\| &quot;||&quot;}) ;=&amp;gt; &quot;foo||bar||quux&quot;

;; 获得给定编码的字节数组
;; (输出可能和下面的&quot;3c3660&quot;不同)
(.getBytes &quot;foo&quot; &quot;UTF-8&quot;) ;=&amp;gt; #&amp;lt;byte[] [B@3c3660&amp;gt;

;; 解析为keyword
(keyword &quot;foo&quot;)    ;=&amp;gt; :foo

;; 解析为数字
(bigint &quot;20000000000000000000000000000&quot;) ;=&amp;gt; 20000000000000000000000000000N
(bigdec &quot;20000000000000000000.00000000&quot;) ;=&amp;gt; 20000000000000000000.00000000M
(Integer/parseInt &quot;2&quot;)                   ;=&amp;gt; 2
(Float/parseFloat &quot;2&quot;)                   ;=&amp;gt; 2.0

;; 解析为edn,它是Clojure形式的一个子集
(edn/read-string &quot;0xffff&quot;) ;=&amp;gt; 65535

;; 读取Clojure形式的方法.
;;
;; 安全警告:当你无法确保你能100%信任要处理的字符串时,请将*read-eval*置为false.
;; 从Clojure1.5开始*read-eval*默认为false,但为了安全起见,
;; 在处理字符串时还是先手动置一下false
;; 因为可能有操作将其置为了true.

(binding [*read-eval* false]
  (read-string &quot;#\&quot;[abc]\&quot;&quot;))
;=&amp;gt; #&quot;[abc]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;解析复杂字符串&lt;/h2&gt;

&lt;h3&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式增强了字符串匹配.你可以重复匹配,匹配其中之一,等等等等&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html&quot;&gt;Regex reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;Groups&lt;/em&gt;:当我们想匹配多于一个子串时,正则表达式的组就起到了作用.在正则表达式#&quot;(group-1) (group-2)&quot;中,第0个组为整个匹配表达式.第1个组从最左边的(开始,第2个组从左起第二个(开始,依次类推.你还可以嵌套组.也可以后续通过\$0,\$1等来引用组.&lt;/p&gt;

&lt;h4&gt;匹配&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 简单匹配
(re-find #&quot;\d+&quot; &quot;foo 123 bar&quot;) ;=&amp;gt; &quot;123&quot;

;; 匹配不到时会怎样?
(re-find #&quot;\d+&quot; &quot;foobar&quot;) ;=&amp;gt; nil

;; 对每个组返回第一个满足匹配条件的内容
(re-matches #&quot;(@\w+)\s([.0-9]+)%&quot;
            &quot;@shanley 19.8%&quot;)
;=&amp;gt;[&quot;@shanley 19.8%&quot; &quot;@shanley&quot; &quot;19.8&quot;]

;; 返回所有匹配的组的结果
(re-seq #&quot;(@\w+)\s([.0-9]+)%&quot;
        &quot;@davidgraeber 12.3%,@shanley 19.8%&quot;)
;=&amp;gt; ([&quot;@davidgraeber 12.3%&quot; &quot;@davidgraeber&quot; &quot;12.3&quot;]
;    [&quot;@shanley 19.8%&quot; &quot;@shanley&quot; &quot;19.8&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;替换&lt;/h4&gt;

&lt;p&gt;我们使用str/replace来进行替换.
第一个参数是源字符串,下一个是匹配字符串,最后一个是替换的内容.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;   match / replacement can be:
   string / string
   char / char
   pattern / (string or function of match).
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 在替换字符串中,$0,$1等用来引用匹配字符串中的组.
(str/replace &quot;@davidgraeber 12.3%,@shanley 19.8%&quot;
             #&quot;(@\S+)\s([.0-9]+)%&quot;
             &quot;$2 ($1)&quot;)
;=&amp;gt; &quot;12.3 (@davidgraeber),19.8 (@shanley)&quot;

;; 使用函数来替换字符串,更灵活
(println
  (str/replace &quot;@davidgraeber 12.3%,@shanley 19.8%&quot;
               #&quot;(@\w+)\s([.0-9]+)%,?&quot;
               (fn [[_ person percent]]
                   (let [points (-&amp;gt; percent Float/parseFloat (* 100) Math/round)]
                     (str person &quot;'s followers grew &quot; points &quot; points.\n&quot;)))))
;print=&amp;gt; @davidgraeber's followers grew 1230 points.
;print=&amp;gt; @shanley's followers grew 1980 points.
;print=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;上下文无关语法&lt;/h3&gt;

&lt;p&gt;和正则表达式相比上下文无关语法提供了更具表现力的匹配方式.你能使用例如嵌套来表达想法.
我们将在JSON语法上使用&lt;a href=&quot;https://github.com/Engelberg/instaparse&quot;&gt;Instapares&lt;/a&gt;.(这个例子没有经过严格的测试也没什么特色.如果想应用到实际开发中,请使用&lt;a href=&quot;https://github.com/clojure/data.json&quot;&gt;data.json&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 你项目中的project.clj需要包含如下依赖(你可能需要重启JVM)
;;   :dependencies [[instaparse &quot;1.2.4&quot;]]
;;
;;  我们假设你的ns宏包含了如下内容:
;;   (:require [instaparse.core :as insta])
;; 或你在REPL里加载了:
;;   (require '[instaparse.core :as insta])

(def barely-tested-json-parser
  (insta/parser
   &quot;object     = &amp;lt;'{'&amp;gt; &amp;lt;w*&amp;gt; (members &amp;lt;w*&amp;gt;)* &amp;lt;'}'&amp;gt;
    &amp;lt;members&amp;gt;  = pair (&amp;lt;w*&amp;gt; &amp;lt;','&amp;gt; &amp;lt;w*&amp;gt; members)*
    &amp;lt;pair&amp;gt;     = string &amp;lt;w*&amp;gt; &amp;lt;':'&amp;gt; &amp;lt;w*&amp;gt; value
    &amp;lt;value&amp;gt;    = string | number | object | array | 'true' | 'false' | 'null'
    array      = &amp;lt;'['&amp;gt; elements* &amp;lt;']'&amp;gt;
    &amp;lt;elements&amp;gt; = value &amp;lt;w*&amp;gt; (&amp;lt;','&amp;gt; &amp;lt;w*&amp;gt; elements)*
    number     = int frac? exp?
    &amp;lt;int&amp;gt;      = '-'? digits
    &amp;lt;frac&amp;gt;     = '.' digits
    &amp;lt;exp&amp;gt;      = e digits
    &amp;lt;e&amp;gt;        = ('e' | 'E') (&amp;lt;'+'&amp;gt; | '-')?
    &amp;lt;digits&amp;gt;   = #'[0-9]+'
    (* First sketched state machine; then it was easier to figure out
       regex syntax and all the maddening escape-backslashes. *)
    string     = &amp;lt;'\\\&quot;'&amp;gt; #'([^\&quot;\\\\]|\\\\.)*' &amp;lt;'\\\&quot;'&amp;gt;
    &amp;lt;w&amp;gt;        = #'\\s+'&quot;))

(barely-tested-json-parser &quot;{\&quot;foo\&quot;: {\&quot;bar\&quot;: 99.9e-9, \&quot;quux\&quot;: [1, 2, -3]}}&quot;)
;=&amp;gt; [:object
;     [:string &quot;foo&quot;]
;     [:object
;       [:string &quot;bar&quot;]
;       [:number &quot;99&quot; &quot;.&quot; &quot;9&quot; &quot;e&quot; &quot;-&quot; &quot;9&quot;]
;       [:string &quot;quux&quot;]
;       [:array [:number &quot;1&quot;] [:number &quot;2&quot;] [:number &quot;-&quot; &quot;3&quot;]]]]

;; 最后的输出有点啰嗦,我们改进一下.
(-&amp;gt;&amp;gt; (barely-tested-json-parser &quot;{\&quot;foo\&quot;: {\&quot;bar\&quot;: 99.9e-9, \&quot;quux\&quot;: [1, 2, -3]}}&quot;)
     (insta/transform {:object hash-map
                       :string str
                       :array vector
                       :number (comp edn/read-string str)}))
;=&amp;gt; {&quot;foo&quot; {&quot;quux&quot; [1 2 -3], &quot;bar&quot; 9.99E-8}}


;; 所有的内容都在上面了
;;
;; =右边的语法主要用来隐藏多余信息.比如说,我们不关心空格,所以我们通过设置&amp;lt;w*&amp;gt;来隐藏
;;
;; =左边的语法只是用来避免嵌套输出的.例如,&quot;members&quot;仅仅是一个人为设置的实体,
;; 所以我们阻止了这个无意义的嵌套关系
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;构建复杂的字符串&lt;/h2&gt;

&lt;h3&gt;重定向&lt;/h3&gt;

&lt;p&gt;with-out-str提供了一个简单的方法来构建字符串.它重定向标准输出(&lt;strong&gt;out&lt;/strong&gt;)到StringWriter,然后返回结果字符串.这样你就可以使用print这样的函数来获得字符串(即使在嵌套函数中)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [shrimp-varieties [&quot;shrimp-kabobs&quot; &quot;shrimp creole&quot; &quot;shrimp gumbo&quot;]]
  (with-out-str
    (print &quot;We have &quot;)
    (doseq [name (str/join &quot;, &quot; shrimp-varieties)]
      (print name))
    (print &quot;...&quot;)))
;=&amp;gt; &quot;We have shrimp-kabobs, shrimp creole, shrimp gumbo...&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;格式化字符串&lt;/h3&gt;

&lt;p&gt;Java里的模板能帮助你方便的构造字符串.&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Reference&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; %s经常会作为print的参数. 而%需要使用%%
(format &quot;%s enjoyed %s%%.&quot; &quot;Mozambique&quot; 19.8) ;=&amp;gt; &quot;Mozambique enjoyed 19.8%.&quot;

;; 1$前缀能引用到其后的第一个参数
(format &quot;%1$tY-%1$tm-%1$td&quot; #inst&quot;2000-01-02T00:00:00&quot;) ;=&amp;gt; &quot;2000-01-02&quot;

;; 同上1$, 2$前缀可以引用其后面的参数
(format &quot;New year: %2$tY. Old year: %1$tY&quot;
        #inst&quot;2000-01-02T00:00:00&quot;
        #inst&quot;3111-12-31T00:00:00&quot;)
;=&amp;gt; &quot;New year: 3111. Old year: 2000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;CL-Format&lt;/h3&gt;

&lt;p&gt;cl-format是Common
Lisp中的一个臭名昭著的功能.例如,你可以从序列来构建字符串(其怪异程度就像使用英文来表示数字,使用两种类型的罗马数字).但对于打印日期和上面的对无序参数的引用方面却又比普通的格式化功能弱.&lt;/p&gt;

&lt;p&gt;你只需要记住cl-format就是个无人问津的不值一学的语言.但是如果你喜欢并想学习它,那么看&lt;a href=&quot;http://www.gigamonkeys.com/book/a-few-format-recipes.html&quot;&gt;Practical
Common
Lisp教程&lt;/a&gt;.或者&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm&quot;&gt;Common
Lisp手册&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; The first param prints to *out* if true. To string if false.
;; To a stream if it's a stream.
(pp/cl-format true &quot;~{~{~a had ~s percentage point~:p.~}~^~%~}&quot;
              {&quot;@davidgraeber&quot; 12.3
               &quot;@shanley&quot; 19.8
               &quot;@tjgabbour&quot; 1})
;print=&amp;gt; @davidgraeber had 12.3 percentage points.
;print=&amp;gt; @tjgabbour had 1 percentage point.
;print=&amp;gt; @shanley had 19.8 percentage points.

(def format-string &quot;~{~#[~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~}&quot;)
(pp/cl-format nil format-string [])
;=&amp;gt; &quot;&quot;
(pp/cl-format nil format-string [&quot;@shanley&quot;])
;=&amp;gt; &quot;@shanley&quot;
(pp/cl-format nil format-string [&quot;@shanley&quot;, &quot;@davidgraeber&quot;])
;=&amp;gt; &quot;@shanley and @davidgraeber&quot;
(pp/cl-format nil format-string [&quot;@shanley&quot;, &quot;@davidgraeber&quot;, &quot;@sarahkendzior&quot;])
;=&amp;gt; &quot;@shanley, @davidgraeber, and @sarahkendzior&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;贡献者&lt;/h1&gt;

&lt;p&gt;Tj Gabbour tjg@simplevalue.de, 2013 (original author)&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;本文翻译自&lt;a href=&quot;http://clojure-doc.org/articles/cookbooks/strings.html&quot;&gt;Strings&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文内容包括使用Clojure内建的函数和标准库来操作字符串,以及JDK中的相关操作.&lt;/p&gt;

&lt;p&gt;版权:&lt;/p&gt;

&lt;p&gt;This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp;amp; stylesheets).&lt;/p&gt;

&lt;p&gt;源代码在&lt;a href=&quot;https://github.com/clojuredocs/guides&quot;&gt;Github&lt;/a&gt;上.&lt;/p&gt;

&lt;h1&gt;概述&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Clojure中的字符串就是Java字符串.你可以使用Java中的相应方法来对其进行处理.&lt;/li&gt;
&lt;li&gt;Java字符串是不可变的,所以能很方便的在Clojure中使用&lt;/li&gt;
&lt;li&gt;你不能给Java字符串添加元数据&lt;/li&gt;
&lt;li&gt;Clojure提供一些方便的符号&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;    &quot;foo&quot;    java.lang.String
    #&quot;\d&quot;    java.util.regex.Pattern (正则表达式,匹配一个数字)
    \f       java.lang.Character (表示'f')
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;:
人类的大脑和计算机之间还是有很大的差异的.所以Java的字符串(UTF-16编码)并不能像人们所认为的那样很好的和字符一一对应.比如说,一个Unicode的位和我们所认为的字符的一位是无法对应的(像韩国韩语尊宝,这些词由多个字符组成.)同样的,一个Unicode位可能是由2个UTF-16字符组成.&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;预备知识&lt;/h1&gt;

&lt;p&gt;一些例子用到了clojure.string,clojure.edn和clojure.pprint.我们假设你的ns宏里面已经包含了如下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [clojure.string :as str]
          [clojure.edn :as edn]
          [clojure.pprint :as pp])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在REPL里面,你需要载入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[clojure.string :as str])
(require '[clojure.edn :as edn])
(require '[clojure.pprint :as pp])
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;方法&lt;/h1&gt;

&lt;h2&gt;基础方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 长度计算
(count &quot;0123&quot;)      ;=&amp;gt; 4
(empty? &quot;0123&quot;)     ;=&amp;gt; false
(empty? &quot;&quot;)         ;=&amp;gt; true
(str/blank? &quot;    &quot;) ;=&amp;gt; true

;; 字符串连接
(str &quot;foo&quot; &quot;bar&quot;)            ;=&amp;gt; &quot;foobar&quot;
(str/join [&quot;0&quot; &quot;1&quot; &quot;2&quot;])     ;=&amp;gt; &quot;012&quot;
(str/join &quot;.&quot; [&quot;0&quot; &quot;1&quot; &quot;2&quot;]) ;=&amp;gt; &quot;0.1.2&quot;

;; 使用Java方法来匹配.
;;
;; 对于下面的情况,你应该更喜欢使用正则表达式.比如,你在进行测试,当失败时需要返回-1.
;; 或者一个字符\o需要转换成字符串或数字.
(.indexOf &quot;foo&quot; &quot;oo&quot;)         ;=&amp;gt; 1
(.indexOf &quot;foo&quot; &quot;x&quot;)          ;=&amp;gt; -1
(.lastIndexOf &quot;foo&quot; (int \o)) ;=&amp;gt; 2

;; 字符串截取
(subs &quot;0123&quot; 1)       ;=&amp;gt; &quot;123&quot;
(subs &quot;0123&quot; 1 3)     ;=&amp;gt; &quot;12&quot;
(str/trim &quot;  foo  &quot;)  ;=&amp;gt; &quot;foo&quot;
(str/triml &quot;  foo  &quot;) ;=&amp;gt; &quot;foo  &quot;
(str/trimr &quot;  foo  &quot;) ;=&amp;gt; &quot;  foo&quot;

;; 切分字符串
(seq &quot;foo&quot;)                       ;=&amp;gt; (\f \o \o)
(str/split &quot;foo/bar/quux&quot; #&quot;/&quot;)   ;=&amp;gt; [&quot;foo&quot; &quot;bar&quot; &quot;quux&quot;]
(str/split &quot;foo/bar/quux&quot; #&quot;/&quot; 2) ;=&amp;gt; [&quot;foo&quot; &quot;bar/quux&quot;]
(str/split-lines &quot;foo
bar&quot;)                             ;=&amp;gt; [&quot;foo&quot; &quot;bar&quot;]

;; 大小写转换
(str/lower-case &quot;fOo&quot;) ;=&amp;gt; &quot;foo&quot;
(str/upper-case &quot;fOo&quot;) ;=&amp;gt; &quot;FOO&quot;
(str/capitalize &quot;fOo&quot;) ;=&amp;gt; &quot;Foo&quot;

;; 转换
(str/escape &quot;foo|bar|quux&quot; {\| &quot;||&quot;}) ;=&amp;gt; &quot;foo||bar||quux&quot;

;; 获得给定编码的字节数组
;; (输出可能和下面的&quot;3c3660&quot;不同)
(.getBytes &quot;foo&quot; &quot;UTF-8&quot;) ;=&amp;gt; #&amp;lt;byte[] [B@3c3660&amp;gt;

;; 解析为keyword
(keyword &quot;foo&quot;)    ;=&amp;gt; :foo

;; 解析为数字
(bigint &quot;20000000000000000000000000000&quot;) ;=&amp;gt; 20000000000000000000000000000N
(bigdec &quot;20000000000000000000.00000000&quot;) ;=&amp;gt; 20000000000000000000.00000000M
(Integer/parseInt &quot;2&quot;)                   ;=&amp;gt; 2
(Float/parseFloat &quot;2&quot;)                   ;=&amp;gt; 2.0

;; 解析为edn,它是Clojure形式的一个子集
(edn/read-string &quot;0xffff&quot;) ;=&amp;gt; 65535

;; 读取Clojure形式的方法.
;;
;; 安全警告:当你无法确保你能100%信任要处理的字符串时,请将*read-eval*置为false.
;; 从Clojure1.5开始*read-eval*默认为false,但为了安全起见,
;; 在处理字符串时还是先手动置一下false
;; 因为可能有操作将其置为了true.

(binding [*read-eval* false]
  (read-string &quot;#\&quot;[abc]\&quot;&quot;))
;=&amp;gt; #&quot;[abc]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;解析复杂字符串&lt;/h2&gt;

&lt;h3&gt;正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式增强了字符串匹配.你可以重复匹配,匹配其中之一,等等等等&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html&quot;&gt;Regex reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;em&gt;Groups&lt;/em&gt;:当我们想匹配多于一个子串时,正则表达式的组就起到了作用.在正则表达式#&quot;(group-1) (group-2)&quot;中,第0个组为整个匹配表达式.第1个组从最左边的(开始,第2个组从左起第二个(开始,依次类推.你还可以嵌套组.也可以后续通过\$0,\$1等来引用组.&lt;/p&gt;

&lt;h4&gt;匹配&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 简单匹配
(re-find #&quot;\d+&quot; &quot;foo 123 bar&quot;) ;=&amp;gt; &quot;123&quot;

;; 匹配不到时会怎样?
(re-find #&quot;\d+&quot; &quot;foobar&quot;) ;=&amp;gt; nil

;; 对每个组返回第一个满足匹配条件的内容
(re-matches #&quot;(@\w+)\s([.0-9]+)%&quot;
            &quot;@shanley 19.8%&quot;)
;=&amp;gt;[&quot;@shanley 19.8%&quot; &quot;@shanley&quot; &quot;19.8&quot;]

;; 返回所有匹配的组的结果
(re-seq #&quot;(@\w+)\s([.0-9]+)%&quot;
        &quot;@davidgraeber 12.3%,@shanley 19.8%&quot;)
;=&amp;gt; ([&quot;@davidgraeber 12.3%&quot; &quot;@davidgraeber&quot; &quot;12.3&quot;]
;    [&quot;@shanley 19.8%&quot; &quot;@shanley&quot; &quot;19.8&quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;替换&lt;/h4&gt;

&lt;p&gt;我们使用str/replace来进行替换.
第一个参数是源字符串,下一个是匹配字符串,最后一个是替换的内容.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;   match / replacement can be:
   string / string
   char / char
   pattern / (string or function of match).
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 在替换字符串中,$0,$1等用来引用匹配字符串中的组.
(str/replace &quot;@davidgraeber 12.3%,@shanley 19.8%&quot;
             #&quot;(@\S+)\s([.0-9]+)%&quot;
             &quot;$2 ($1)&quot;)
;=&amp;gt; &quot;12.3 (@davidgraeber),19.8 (@shanley)&quot;

;; 使用函数来替换字符串,更灵活
(println
  (str/replace &quot;@davidgraeber 12.3%,@shanley 19.8%&quot;
               #&quot;(@\w+)\s([.0-9]+)%,?&quot;
               (fn [[_ person percent]]
                   (let [points (-&amp;gt; percent Float/parseFloat (* 100) Math/round)]
                     (str person &quot;'s followers grew &quot; points &quot; points.\n&quot;)))))
;print=&amp;gt; @davidgraeber's followers grew 1230 points.
;print=&amp;gt; @shanley's followers grew 1980 points.
;print=&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;上下文无关语法&lt;/h3&gt;

&lt;p&gt;和正则表达式相比上下文无关语法提供了更具表现力的匹配方式.你能使用例如嵌套来表达想法.
我们将在JSON语法上使用&lt;a href=&quot;https://github.com/Engelberg/instaparse&quot;&gt;Instapares&lt;/a&gt;.(这个例子没有经过严格的测试也没什么特色.如果想应用到实际开发中,请使用&lt;a href=&quot;https://github.com/clojure/data.json&quot;&gt;data.json&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; 你项目中的project.clj需要包含如下依赖(你可能需要重启JVM)
;;   :dependencies [[instaparse &quot;1.2.4&quot;]]
;;
;;  我们假设你的ns宏包含了如下内容:
;;   (:require [instaparse.core :as insta])
;; 或你在REPL里加载了:
;;   (require '[instaparse.core :as insta])

(def barely-tested-json-parser
  (insta/parser
   &quot;object     = &amp;lt;'{'&amp;gt; &amp;lt;w*&amp;gt; (members &amp;lt;w*&amp;gt;)* &amp;lt;'}'&amp;gt;
    &amp;lt;members&amp;gt;  = pair (&amp;lt;w*&amp;gt; &amp;lt;','&amp;gt; &amp;lt;w*&amp;gt; members)*
    &amp;lt;pair&amp;gt;     = string &amp;lt;w*&amp;gt; &amp;lt;':'&amp;gt; &amp;lt;w*&amp;gt; value
    &amp;lt;value&amp;gt;    = string | number | object | array | 'true' | 'false' | 'null'
    array      = &amp;lt;'['&amp;gt; elements* &amp;lt;']'&amp;gt;
    &amp;lt;elements&amp;gt; = value &amp;lt;w*&amp;gt; (&amp;lt;','&amp;gt; &amp;lt;w*&amp;gt; elements)*
    number     = int frac? exp?
    &amp;lt;int&amp;gt;      = '-'? digits
    &amp;lt;frac&amp;gt;     = '.' digits
    &amp;lt;exp&amp;gt;      = e digits
    &amp;lt;e&amp;gt;        = ('e' | 'E') (&amp;lt;'+'&amp;gt; | '-')?
    &amp;lt;digits&amp;gt;   = #'[0-9]+'
    (* First sketched state machine; then it was easier to figure out
       regex syntax and all the maddening escape-backslashes. *)
    string     = &amp;lt;'\\\&quot;'&amp;gt; #'([^\&quot;\\\\]|\\\\.)*' &amp;lt;'\\\&quot;'&amp;gt;
    &amp;lt;w&amp;gt;        = #'\\s+'&quot;))

(barely-tested-json-parser &quot;{\&quot;foo\&quot;: {\&quot;bar\&quot;: 99.9e-9, \&quot;quux\&quot;: [1, 2, -3]}}&quot;)
;=&amp;gt; [:object
;     [:string &quot;foo&quot;]
;     [:object
;       [:string &quot;bar&quot;]
;       [:number &quot;99&quot; &quot;.&quot; &quot;9&quot; &quot;e&quot; &quot;-&quot; &quot;9&quot;]
;       [:string &quot;quux&quot;]
;       [:array [:number &quot;1&quot;] [:number &quot;2&quot;] [:number &quot;-&quot; &quot;3&quot;]]]]

;; 最后的输出有点啰嗦,我们改进一下.
(-&amp;gt;&amp;gt; (barely-tested-json-parser &quot;{\&quot;foo\&quot;: {\&quot;bar\&quot;: 99.9e-9, \&quot;quux\&quot;: [1, 2, -3]}}&quot;)
     (insta/transform {:object hash-map
                       :string str
                       :array vector
                       :number (comp edn/read-string str)}))
;=&amp;gt; {&quot;foo&quot; {&quot;quux&quot; [1 2 -3], &quot;bar&quot; 9.99E-8}}


;; 所有的内容都在上面了
;;
;; =右边的语法主要用来隐藏多余信息.比如说,我们不关心空格,所以我们通过设置&amp;lt;w*&amp;gt;来隐藏
;;
;; =左边的语法只是用来避免嵌套输出的.例如,&quot;members&quot;仅仅是一个人为设置的实体,
;; 所以我们阻止了这个无意义的嵌套关系
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;构建复杂的字符串&lt;/h2&gt;

&lt;h3&gt;重定向&lt;/h3&gt;

&lt;p&gt;with-out-str提供了一个简单的方法来构建字符串.它重定向标准输出(&lt;strong&gt;out&lt;/strong&gt;)到StringWriter,然后返回结果字符串.这样你就可以使用print这样的函数来获得字符串(即使在嵌套函数中)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(let [shrimp-varieties [&quot;shrimp-kabobs&quot; &quot;shrimp creole&quot; &quot;shrimp gumbo&quot;]]
  (with-out-str
    (print &quot;We have &quot;)
    (doseq [name (str/join &quot;, &quot; shrimp-varieties)]
      (print name))
    (print &quot;...&quot;)))
;=&amp;gt; &quot;We have shrimp-kabobs, shrimp creole, shrimp gumbo...&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;格式化字符串&lt;/h3&gt;

&lt;p&gt;Java里的模板能帮助你方便的构造字符串.&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Reference&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; %s经常会作为print的参数. 而%需要使用%%
(format &quot;%s enjoyed %s%%.&quot; &quot;Mozambique&quot; 19.8) ;=&amp;gt; &quot;Mozambique enjoyed 19.8%.&quot;

;; 1$前缀能引用到其后的第一个参数
(format &quot;%1$tY-%1$tm-%1$td&quot; #inst&quot;2000-01-02T00:00:00&quot;) ;=&amp;gt; &quot;2000-01-02&quot;

;; 同上1$, 2$前缀可以引用其后面的参数
(format &quot;New year: %2$tY. Old year: %1$tY&quot;
        #inst&quot;2000-01-02T00:00:00&quot;
        #inst&quot;3111-12-31T00:00:00&quot;)
;=&amp;gt; &quot;New year: 3111. Old year: 2000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;CL-Format&lt;/h3&gt;

&lt;p&gt;cl-format是Common
Lisp中的一个臭名昭著的功能.例如,你可以从序列来构建字符串(其怪异程度就像使用英文来表示数字,使用两种类型的罗马数字).但对于打印日期和上面的对无序参数的引用方面却又比普通的格式化功能弱.&lt;/p&gt;

&lt;p&gt;你只需要记住cl-format就是个无人问津的不值一学的语言.但是如果你喜欢并想学习它,那么看&lt;a href=&quot;http://www.gigamonkeys.com/book/a-few-format-recipes.html&quot;&gt;Practical
Common
Lisp教程&lt;/a&gt;.或者&lt;a href=&quot;http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm&quot;&gt;Common
Lisp手册&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;;; The first param prints to *out* if true. To string if false.
;; To a stream if it's a stream.
(pp/cl-format true &quot;~{~{~a had ~s percentage point~:p.~}~^~%~}&quot;
              {&quot;@davidgraeber&quot; 12.3
               &quot;@shanley&quot; 19.8
               &quot;@tjgabbour&quot; 1})
;print=&amp;gt; @davidgraeber had 12.3 percentage points.
;print=&amp;gt; @tjgabbour had 1 percentage point.
;print=&amp;gt; @shanley had 19.8 percentage points.

(def format-string &quot;~{~#[~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~}&quot;)
(pp/cl-format nil format-string [])
;=&amp;gt; &quot;&quot;
(pp/cl-format nil format-string [&quot;@shanley&quot;])
;=&amp;gt; &quot;@shanley&quot;
(pp/cl-format nil format-string [&quot;@shanley&quot;, &quot;@davidgraeber&quot;])
;=&amp;gt; &quot;@shanley and @davidgraeber&quot;
(pp/cl-format nil format-string [&quot;@shanley&quot;, &quot;@davidgraeber&quot;, &quot;@sarahkendzior&quot;])
;=&amp;gt; &quot;@shanley, @davidgraeber, and @sarahkendzior&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;贡献者&lt;/h1&gt;

&lt;p&gt;Tj Gabbour tjg@simplevalue.de, 2013 (original author)&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-基本语法</title>
        <link href="http://ivanpig.github.io/2014/02/02/basic.html"/>
        <updated>2014-02-02T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/02/02/basic</id>
        <content type="html">&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;学习一门语言最好的方法就是去使用它。我们就从一个小例子来学习Clojure语法.&lt;/p&gt;

&lt;h1&gt;核心语法&lt;/h1&gt;

&lt;p&gt;首先先来看一下Clojure的核心语法。&lt;/p&gt;

&lt;p&gt;Clojure的使用的是Lisp语法,又叫S表达式。核心语法非常的简单。但是对于熟悉c系语法(c,c++,java)的朋友来说，第一次接触会非常的不习惯。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有代码以&quot;(&quot;开始,&quot;)&quot;结束。即所有的代码都被()包裹&lt;/li&gt;
&lt;li&gt;&quot;(&quot;后的第一个数据被当作函数或者宏来调用&lt;/li&gt;
&lt;li&gt;接着的数据被当作参数传递&lt;/li&gt;
&lt;li&gt;如果想原样返回数据，在&quot;(&quot;前面添加&quot;'&quot;。此写法是(quote (...))的简写&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以前面的hello world程序为例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(println &quot;Hello World&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它以&quot;(&quot;开始，后面跟的是函数println，接着空格跟的是参数&quot;HelloWorld&quot;，最后&quot;)&quot;结尾。&lt;/p&gt;

&lt;p&gt;了解了如上规则，你就基本学会了Clojure的大部分语法。&lt;/p&gt;

&lt;p&gt;下面比较一下Clojure,Java,Python,Ruby的一些语法.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left;&quot;&gt; Clojure 表达式&lt;/th&gt;
&lt;th style=&quot;text-align:left;&quot;&gt; 对应的 Java 语法   &lt;/th&gt;
&lt;th style=&quot;text-align:left;&quot;&gt; 对应的 Python 语法 &lt;/th&gt;
&lt;th style=&quot;text-align:left;&quot;&gt;对应的 Ruby 语法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (not k)                        &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; !k                           &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; not k                   &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; not k or !k                                       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (inc a)                        &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; a++、++a、a += 1、a + 1&lt;sup&gt;a&lt;/sup&gt;    &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; a += 1、a + 1           &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; a += 1                                              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (/ (+ x y) 2)                  &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (x + y) / 2                  &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (x + y) / 2             &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (x + y) / 2                                       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (instance? java. util.List al) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; al instanceof java.util.List &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; isinstance(al,list)     &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; al.is_a? Array                                    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (if (not a) (inc b) (dec b))   &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; !a ? b + 1 : b - 1           &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; b + 1 if not a else b-1 &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; !a ? b + 1 : b - 1                                &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (Math/pow 2 10)&lt;sup&gt;c&lt;/sup&gt;              &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; Math.pow(2, 10)              &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; pow(2, 10)              &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; 2 ** 10                                           &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (.someMethod someObj &quot;foo&quot; (.otherMethod otherObj 0)) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt;someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0)) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt;someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0)) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt;someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0)) &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;可以看出Clojure的语法有高度的一致性，即使你不熟悉S表达式，但是依据上面的原则，可以看懂它想表达的是一个什么意思。&lt;/p&gt;

&lt;p&gt;而对于其他三门语言，如果你没有一个个的学习相应的语法，你还是比较难理解它的意思的。&lt;/p&gt;

&lt;h1&gt;代码功能&lt;/h1&gt;

&lt;p&gt;了解了核心语法，我们就可以来编写代码了。我们要编写的代码功能很简单，进行简繁翻译，其中过滤不需要翻译以及需要特殊翻译的文字。我们将分几步来完成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读取简繁字典&lt;/li&gt;
&lt;li&gt;进行简繁翻译&lt;/li&gt;
&lt;li&gt;读取不需要翻译的文字&lt;/li&gt;
&lt;li&gt;过滤不翻译的文字&lt;/li&gt;
&lt;li&gt;提供给Java调用&lt;/li&gt;
&lt;li&gt;打包&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- more --&gt;


&lt;h2&gt;读取简繁字典&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;语法点

&lt;ul&gt;
&lt;li&gt;查看Clojure API&lt;/li&gt;
&lt;li&gt;第一个函数的编写&lt;/li&gt;
&lt;li&gt;Namespace的引入&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;Clojure字面量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我们先看第一个功能。我们要读取简繁字典。简繁字典其实就是简繁对照的文件，我这里叫jfmap.clj 格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;万 萬 与 與 丑 醜 专 專 业 業 丛 叢 东 東 丝 絲 丢 丟 两 兩 严 嚴 丧 喪 个 個 丬 爿
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只是简单的列了一点。具体内容请见附件。有了这个文件，我们如何把内容读出来呢？熟悉Java的都知道，我们要创建文件流来读取，然后要打开流，循环读取，最后关闭流，还要抓异常。很繁琐。&lt;/p&gt;

&lt;p&gt;在Clojure中如何处理呢？Clojure提供了slurp函数，可以根据提供的路径将文件内容读入。API如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;clojure.core/slurp
([f &amp;amp; opts])
  Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK。我们知道了要用什么函数。那么根据API和上面说的总规则，我们来写代码.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先是&quot;(&quot;&lt;/li&gt;
&lt;li&gt;然后是函数名slurp&lt;/li&gt;
&lt;li&gt;空格，参数。这里是要读取的文件路径&lt;/li&gt;
&lt;li&gt;最后&quot;)&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(slurp &quot;jfmap-path&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在REPL里面去实验这行代码的执行结果。执行此行代码，clojure会将jfmap.clj的内容以字符串的形式全部读入。&lt;/p&gt;

&lt;p&gt;接着呢？要做简繁翻译，字符串肯定不方便我们的操作。很明显map才是最适合的数据结构。那么我们如何将字符串变成map呢？&lt;/p&gt;

&lt;p&gt;我们只能求助于API了，你可以在&lt;a href=&quot;http://clojure.github.io/clojure/api-index.html&quot;&gt;Clojure的Index页面&lt;/a&gt;搜索map,可以找到hash-map函数。它的API说明如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;hash-map
function
Usage: (hash-map)
       (hash-map &amp;amp; keyvals)
keyval =&amp;gt; key val
Returns a new hash map with supplied mappings.  If any keys are
equal, they are handled as if by repeated uses of assoc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据提供的映射关系返回一个新的hashmap。而这里我们是一个字符串，如何提供映射关系呢？按照空格将文字切开就行了嘛！！继续找API。&lt;/p&gt;

&lt;p&gt;Java里有split方法，Clojure里有没有相应的函数呢？试试再说。。有了！在clojure.string的Namespace(Namespace和Java中的包类似，但是在Clojure中叫Namespace。这里没有将其翻译为命名空间，主要是怕有误解。)中，我们找到了叫split的函数！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;split
function
Usage: (split s re)
       (split s re limit)
Splits string on a regular expression.  Optional argument limit is
the maximum number of splits. Not lazy. Returns vector of the splits.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过正则表达式来切割字符串。看着挺像，先用再说！我们有repl嘛！直接在
repl里面输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(split &quot;万 萬&quot; #&quot; &quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行!Oops,报错了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;CompilerException java.lang.RuntimeException: Unable to resolve symbol: split in this context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找不到split?!如果在Java中报类似的错误，你会想到什么？没有引入包阿！&lt;/p&gt;

&lt;p&gt;这里也是。在Java中会默认引入java.lang包，同理在Clojure中会引入clojure.core和java.lang包。其他包则要自己引入，这里split在clojure.string包中。所以你需要引入clojure.string包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require 'clojure.string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也就是调用了require函数来进行引入！为什么clojure.string前面有个单引号呢？想想核心语法！这里暂不展开说！给大家留个思考题！！后续会专门对命名空间引入做详细介绍！&lt;/p&gt;

&lt;p&gt;光引入还没用！调用代码也需要修改！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(clojure.string/split &quot;万 萬&quot; #&quot; &quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能要吐槽了！既然引入了，为什么还要加Namespace前缀？！&lt;/p&gt;

&lt;p&gt;我们可以和Java作个比较！如果这里是Java的话，那么我们在调用split的时候，实际上是需要一个类作为前缀的，比如StringUtils.split()!但是在clojure中并没有类的概念！Namespace下面只有函数，所以它使用命名空间来确保函数的唯一性引用！&lt;/p&gt;

&lt;p&gt;当然了每次都要写这么长的命名空间的名字也是挺烦人的。Clojure提供了简写.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require ['clojure.stirng :as 'cstr])
(cstr/split &quot;万 萬&quot; #&quot; &quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:as是Keyword,是Clojure字面量的一种。它和String很类似，不过有些区别，它比String有更多的功能。
下表是Clojure所包含的字面量。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type   &lt;/th&gt;
&lt;th&gt;     Example(s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; Boolean    &lt;/td&gt;
&lt;td&gt; true,false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Character  &lt;/td&gt;
&lt;td&gt; \a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Keyword    &lt;/td&gt;
&lt;td&gt; :tag,:doc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; List       &lt;/td&gt;
&lt;td&gt; (1 2 3),(println &quot;foo&quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Map        &lt;/td&gt;
&lt;td&gt; {:name &quot;Bill&quot;,:age 42}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Nil        &lt;/td&gt;
&lt;td&gt; nil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Number     &lt;/td&gt;
&lt;td&gt; 1,4.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Set        &lt;/td&gt;
&lt;td&gt; #{:snap :crackle :pop}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; String     &lt;/td&gt;
&lt;td&gt; &quot;hello&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Symbol     &lt;/td&gt;
&lt;td&gt; user/foo,java.lang.String&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Vector     &lt;/td&gt;
&lt;td&gt; [1 2 3]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;ok.终于得到了我们要的结果。&lt;/p&gt;

&lt;p&gt;这里的#&quot;&quot;是正则表达式(这是你遇到的第一个特殊语法，学习方法---死记！！)，它构建了Java中的Pattern，所以正则表达式内容和Java完全相同，这里就不废话了。你只需要记住其语法就行了。&lt;/p&gt;

&lt;p&gt;切开了字符串，我们来生成map吧！如何生成呢？你应该有答案了吧？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(hash-map (cstr/split &quot;万 萬&quot; #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又报错了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;IllegalArgumentException No value supplied for key: [&quot;万&quot; &quot;萬&quot;]  clojure.lang.PersistentHashMap.create (PersistentHashMap.java:77)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不合法的参数！！split得到的是个Vector([]包裹的数据结构是Vector),而hash-map要的参数类似于Java中的可变参数！如何匹配这两者呢？&lt;/p&gt;

&lt;p&gt;Clojure中提供了apply函数!API如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;clojure.core/apply
([f args] [f x args] [f x y args] [f x y z args] [f a b c d &amp;amp; args])
  Applies fn f to the argument list formed by prepending intervening arguments to args.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此函数有点特别！它的第一个参数是函数，后面是该函数所需要的参数！知道怎么调用吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply hash-map (cstr/split &quot;万 萬&quot; #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于成功了！！我们看到了结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{&quot;万&quot; &quot;萬&quot;}   ;以{}包裹的数据结构是map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后呢！我们需要对jfmap.clj的内容进行处理！So easy!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply hash-map (cstr/split (slurp &quot;jfmap-path&quot;) #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;进行简繁翻译&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;语法点

&lt;ul&gt;
&lt;li&gt;var的定义&lt;/li&gt;
&lt;li&gt;函数的定义&lt;/li&gt;
&lt;li&gt;闭包的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上一节我们完成了对jfmap.clj的读取，并生成了hashmap。但是呢，如果我们每次要使用jfmap.clj的时候都要写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply hash-map (cstr/split (slurp &quot;jfmap-path&quot;) #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;太麻烦了。在Java中的可以将其封装为一个方法来进行调用。Clojure也可以将其封装为函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn read-map
  &quot;Read trans map from file&quot;
  [path]
  (apply hash-map (clstr/split (slurp path) #&quot; &quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defn是个宏，宏的定义后面讨论。&lt;/p&gt;

&lt;p&gt;defn是用来定义有名函数的。read-map就是函数名，和Java中的驼峰式取名不同，List系的取名方式一般是使用&quot;-&quot;。给出的原因是大写字母要按两个按键，&quot;-&quot;只需要按一个按键！！&lt;/p&gt;

&lt;p&gt;紧接着函数名的是注释，类似Java中的注释，不同的是其双引号内的内容可以多行。后面的vector是参数
列表，最后就是函数体了。&lt;/p&gt;

&lt;p&gt;现在当你再读取jfmap的时候。只需要这样调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(read-map &quot;jfmap-path&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比刚才简单了很多。但是每次都要去读取，还是不够方便。在Java中会将其赋值给一个变量，然后去调用。Clojure当然也可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def jfmap (read-map &quot;jfmap-path&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你直接操作jfmap就可以了。 现在我们就来按照jfmap来进行简繁翻译吧！&lt;/p&gt;

&lt;p&gt;你可能会想，很简单吧？只需要遍历需要翻译的字符串，然后到jfmap中去找对应的翻译，然后将翻译组装成字符串就行了。so easy!但当你这么想的时候，你已经陷入到了实现的细节中了！Clojure让你能够更加的关注业务而不是实现细节！&lt;/p&gt;

&lt;p&gt;这里给出的建议是：
&lt;strong&gt;请先查找Clojure是否可通过函数组合来解决问题？如果不能再考虑自己编写函
数！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么这么说呢？因为在Clojure中大部分的问题都可以通过其提供的函数组合来解决。你需要做的就是根据需要来组合函数！这使你能更多的思考业务而非实现细节！比如这里的问题！ 我们需要一个函数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接受一个字符串&lt;/li&gt;
&lt;li&gt;返回翻译完成的字符串&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;很简单，我们先编写函数的定义。这里我们叫translate。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后呢？需要翻译字符串。这里叫翻译字符串，实际上就是根据map的key找到value而已。在Clojure中找到这样的函数就可以了。你可以找到get函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get map k default)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很好理解吧？根据k从map中查找value，如果找不到则返回default。其实这就是核心代码了！&lt;/p&gt;

&lt;p&gt;我们知道map就是我们这里的jfmap，k实际上是获取的字符串的每个字符，而default呢？这里如果我们根据k找不到的话，就直接返回k，也就是不翻译了。所以代码修改为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get jfmap k k)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在只需要解决k就行了！继续寻找函数！现在需要的是在Clojure中用得还比较多的一个函数---map!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;clojure.core/map
([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp;amp; colls])
  Returns a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到作用了吗？将函数应用到序列的每个元素上去！并返回一个由结果组成的lazy序列！你可能会问了：这是针对序列的，对字符串有效吗？试试不就知道了？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(map class &quot;aaa&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在repl里面输入如上的代码！你看到了什么？java.lang.Character?!没错，字符串会被当作字符序列来操作！但是我们需要的是字符串啊？没关系，我们有str函数!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(map (comp class str) &quot;aaa&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;comp是个什么东东？它的作用是将多个函数组合起来，从右向左的执行！！这里就是先执行str再执行class,可以看到结果打印的是java.lang.String,正是我们需要的。&lt;/p&gt;

&lt;p&gt;OK，现在我们来组合这两个函数就行了.但是问题又来了！map的第二个参数是个函数，我们怎么办呢？既然它需要函数，那我们就定义一个给它咯！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn tmp [k]
   (get jfmap k k))

(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map tmp s)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能要抱怨了！取了个什么烂名字！！居然叫tmp?!呵呵，别急！我把函数定义为tmp，是因为我要将优化掉！可以看出，这个功能非常的简单，而且只会给translate使用，那么我们需要特意定义一个单独的函数吗？&lt;/p&gt;

&lt;p&gt;不需要吧？我们直接将两个函数合并好了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map (defn tmp [k] (get jfmap k k)) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单，但是呢！既然都放到函数内部了！还需要函数名吗？&lt;/p&gt;

&lt;p&gt;就像Java中的匿名内部类一样，直接定义直接使用，不需要名字！&lt;/p&gt;

&lt;p&gt;在Clojure中有fn这个specialform来定义匿名函数！&lt;/p&gt;

&lt;p&gt;上面说defn是个宏！它的功能就类似于(还有其他功能，比如注释)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def tmp (fn [k] (get jfmap k k)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用fn来简化一下代码!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map (fn [k] (get jfmap k k)) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;舒服很多！还能更简单吗？当然！Clojure提供了#这个语法糖来定义匿名函数!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map #(get jfmap k k) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好！问题来了！这里没有了参数列表！那get函数怎么知道k是个什么东西呢？所以，这里使用%来替换，第一个参数用%或者%1替换，第二个则是%2,依次类推！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map #(get jfmap % %) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定了吗？没有！translate需要返回一个字符串，而map返回的是个lazy序列！需要将序列转化为字符串！到clojure.string找找！有个join函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (clstr/join (map #(get jfmap % %) s)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不废话了！记得要引入Namespace哦！！&lt;/p&gt;

&lt;p&gt;实际上一行代码我们就搞定了基本的翻译了！很简单吧？&lt;/p&gt;

&lt;h2&gt;读取不需要翻译的文字&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;复习&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;翻译的字，是使用的map来存储的？那不需要翻译的文字该如何存储呢？这要看你如何处理了！我这里采用的是一个很简单的方式！&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先对文字全文翻译&lt;/li&gt;
&lt;li&gt;然后对翻译后的文字再反翻译&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;比如说，&quot;阿里山&quot;直接翻译的话，那么就会变成&quot;阿裡山&quot;，但是&quot;里&quot;字是不需要翻译的。&lt;/p&gt;

&lt;p&gt;那么我就新建一个map，保存&quot;阿裡山&quot;-&gt;&quot;阿里山&quot;，将文字再翻回来！&lt;/p&gt;

&lt;p&gt;那么这里我就再需要一个类似jfmap.clj的文件就可以了。我这里叫ntmap.clj。&lt;/p&gt;

&lt;p&gt;格式和jfmap.clj类似！只不过里面存储的是需要反翻译的文字!&lt;/p&gt;

&lt;p&gt;如何读取和组装map?不需要我废话吧？&lt;/p&gt;

&lt;h2&gt;过滤不翻译的文字&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Special Form

&lt;ul&gt;
&lt;li&gt;let&lt;/li&gt;
&lt;li&gt;loop&lt;/li&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;li&gt;recur&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;过滤不翻译的文字，实际上就是反翻译!如何进行呢？原来在翻译的过程中我们是一个字符一个字符的匹配的！但是这里是一个一个的字符串！这就比较难办了！&lt;/p&gt;

&lt;p&gt;不管怎么说我们先定义函数!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn do-trans
  [s tmap ntmap]
   )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先第一件事就是去全文翻译！然后获得结果！提供给后续函数使用！&lt;/p&gt;

&lt;p&gt;Java中有局部变量！只需要将变量写在方法里就可以了！但是在Clojure中不同，它需要通过let这个Special Form来处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn do-trans
  [s tmap ntmap]
  (let [re (translate s tmap)]

))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let后面是个Vector，用来进行var绑定，这里translate翻译的结果会被绑定到re这个var上！而re的作用范围就只在let这个括号内部！&lt;/p&gt;

&lt;p&gt;接着呢！就是对re进行反翻译！没啥现成的函数了！只能自己处理！代码如下！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn do-trans
  [s tmap ntmap]
  (let [re (translate s tmap)]
    (loop [result re
           k (keys ntmap)]
      (if (seq k)
        (recur (clstr/replace result (first k) (ntmap (first k))) (rest k))
          result))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loop又是个Special Form，看起来像循环！实际上它是个递归！&lt;/p&gt;

&lt;p&gt;loop后面也是个参数Vector，功能和let的相同！这里将re绑定到了result，以及ntmap的key绑定到了k上！&lt;/p&gt;

&lt;p&gt;然后是if判断，还是个Special Form，(seq k)判断k是否是个序列！如果是则执行recur，如果不是则返回result.其实seq并不是判断函数！&lt;/p&gt;

&lt;p&gt;它是用来构建序列的！这里之所以能用来判断，基于两个原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Clojure中除了nil和false是假，其他全是真&lt;/li&gt;
&lt;li&gt;(seq nil)和(seq ())返回nil&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;然后seq就可以用来作为判断条件了！&lt;/p&gt;

&lt;p&gt;recur是递归调用！这里调用的是loop，传递的参数是替换后的s和剩余的k.&lt;/p&gt;

&lt;p&gt;实际功能就是，遍历ntmap中的key，如果找到了，则使用value替换掉！&lt;/p&gt;

&lt;p&gt;至此，就完成了翻译的所有功能！考虑下如果使用Java需要多少行代码？？&lt;/p&gt;

&lt;p&gt;测试翻译一个页面的时间为70毫秒左右，速度还是不错的！&lt;/p&gt;

&lt;h2&gt;提供给Java调用&lt;/h2&gt;

&lt;p&gt;Clojure提供了将函数给Java调用的功能！&lt;/p&gt;

&lt;p&gt;首先，在core.clj文件中编写函数，比如下面的翻译:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn -transAll
  &quot;翻译所有&quot;
  [source mapPath]
  (trans/translate source (trans/read-map mapPath) &quot;&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数名前面一定要有个&quot;-&quot;。 然后在命名空间里添加如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns jft.core
;这里开始
 (:gen-class
   :name jft.core.Trans
   :methods [#^{:static true} [transAll [String String] String]])
;这里结束
  (:require [clojure.string :as cstr]
            [jft.trans :as trans])
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该不难理解吧？name是在Java中import的时候的名字！methods是可以调用的方法,这里注解为静态方法！&lt;/p&gt;

&lt;p&gt;注意这里的transAll前面是没有&quot;-&quot;的，后面是参数和返回类型！&lt;/p&gt;

&lt;h2&gt;打包&lt;/h2&gt;

&lt;p&gt;需要给Java调用，那就要先封装为jar包。非常简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以提供给Java调用了！&lt;/p&gt;

&lt;h1&gt;源码&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;/assets/clojure/jft.zip&quot;&gt;jft&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;学习一门语言最好的方法就是去使用它。我们就从一个小例子来学习Clojure语法.&lt;/p&gt;

&lt;h1&gt;核心语法&lt;/h1&gt;

&lt;p&gt;首先先来看一下Clojure的核心语法。&lt;/p&gt;

&lt;p&gt;Clojure的使用的是Lisp语法,又叫S表达式。核心语法非常的简单。但是对于熟悉c系语法(c,c++,java)的朋友来说，第一次接触会非常的不习惯。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有代码以&quot;(&quot;开始,&quot;)&quot;结束。即所有的代码都被()包裹&lt;/li&gt;
&lt;li&gt;&quot;(&quot;后的第一个数据被当作函数或者宏来调用&lt;/li&gt;
&lt;li&gt;接着的数据被当作参数传递&lt;/li&gt;
&lt;li&gt;如果想原样返回数据，在&quot;(&quot;前面添加&quot;'&quot;。此写法是(quote (...))的简写&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以前面的hello world程序为例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(println &quot;Hello World&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它以&quot;(&quot;开始，后面跟的是函数println，接着空格跟的是参数&quot;HelloWorld&quot;，最后&quot;)&quot;结尾。&lt;/p&gt;

&lt;p&gt;了解了如上规则，你就基本学会了Clojure的大部分语法。&lt;/p&gt;

&lt;p&gt;下面比较一下Clojure,Java,Python,Ruby的一些语法.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left;&quot;&gt; Clojure 表达式&lt;/th&gt;
&lt;th style=&quot;text-align:left;&quot;&gt; 对应的 Java 语法   &lt;/th&gt;
&lt;th style=&quot;text-align:left;&quot;&gt; 对应的 Python 语法 &lt;/th&gt;
&lt;th style=&quot;text-align:left;&quot;&gt;对应的 Ruby 语法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (not k)                        &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; !k                           &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; not k                   &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; not k or !k                                       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (inc a)                        &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; a++、++a、a += 1、a + 1&lt;sup&gt;a&lt;/sup&gt;    &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; a += 1、a + 1           &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; a += 1                                              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (/ (+ x y) 2)                  &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (x + y) / 2                  &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (x + y) / 2             &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (x + y) / 2                                       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (instance? java. util.List al) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; al instanceof java.util.List &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; isinstance(al,list)     &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; al.is_a? Array                                    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (if (not a) (inc b) (dec b))   &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; !a ? b + 1 : b - 1           &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; b + 1 if not a else b-1 &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; !a ? b + 1 : b - 1                                &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (Math/pow 2 10)&lt;sup&gt;c&lt;/sup&gt;              &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; Math.pow(2, 10)              &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; pow(2, 10)              &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; 2 ** 10                                           &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left;&quot;&gt; (.someMethod someObj &quot;foo&quot; (.otherMethod otherObj 0)) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt;someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0)) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt;someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0)) &lt;/td&gt;
&lt;td style=&quot;text-align:left;&quot;&gt;someObj.someMethod(&quot;foo&quot; , otherObj.otherMethod(0)) &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;可以看出Clojure的语法有高度的一致性，即使你不熟悉S表达式，但是依据上面的原则，可以看懂它想表达的是一个什么意思。&lt;/p&gt;

&lt;p&gt;而对于其他三门语言，如果你没有一个个的学习相应的语法，你还是比较难理解它的意思的。&lt;/p&gt;

&lt;h1&gt;代码功能&lt;/h1&gt;

&lt;p&gt;了解了核心语法，我们就可以来编写代码了。我们要编写的代码功能很简单，进行简繁翻译，其中过滤不需要翻译以及需要特殊翻译的文字。我们将分几步来完成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读取简繁字典&lt;/li&gt;
&lt;li&gt;进行简繁翻译&lt;/li&gt;
&lt;li&gt;读取不需要翻译的文字&lt;/li&gt;
&lt;li&gt;过滤不翻译的文字&lt;/li&gt;
&lt;li&gt;提供给Java调用&lt;/li&gt;
&lt;li&gt;打包&lt;/li&gt;
&lt;/ul&gt;


&lt;!-- more --&gt;


&lt;h2&gt;读取简繁字典&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;语法点

&lt;ul&gt;
&lt;li&gt;查看Clojure API&lt;/li&gt;
&lt;li&gt;第一个函数的编写&lt;/li&gt;
&lt;li&gt;Namespace的引入&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;Clojure字面量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;我们先看第一个功能。我们要读取简繁字典。简繁字典其实就是简繁对照的文件，我这里叫jfmap.clj 格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;万 萬 与 與 丑 醜 专 專 业 業 丛 叢 东 東 丝 絲 丢 丟 两 兩 严 嚴 丧 喪 个 個 丬 爿
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只是简单的列了一点。具体内容请见附件。有了这个文件，我们如何把内容读出来呢？熟悉Java的都知道，我们要创建文件流来读取，然后要打开流，循环读取，最后关闭流，还要抓异常。很繁琐。&lt;/p&gt;

&lt;p&gt;在Clojure中如何处理呢？Clojure提供了slurp函数，可以根据提供的路径将文件内容读入。API如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;clojure.core/slurp
([f &amp;amp; opts])
  Opens a reader on f and reads all its contents, returning a string.
  See clojure.java.io/reader for a complete list of supported arguments.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK。我们知道了要用什么函数。那么根据API和上面说的总规则，我们来写代码.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先是&quot;(&quot;&lt;/li&gt;
&lt;li&gt;然后是函数名slurp&lt;/li&gt;
&lt;li&gt;空格，参数。这里是要读取的文件路径&lt;/li&gt;
&lt;li&gt;最后&quot;)&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(slurp &quot;jfmap-path&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在REPL里面去实验这行代码的执行结果。执行此行代码，clojure会将jfmap.clj的内容以字符串的形式全部读入。&lt;/p&gt;

&lt;p&gt;接着呢？要做简繁翻译，字符串肯定不方便我们的操作。很明显map才是最适合的数据结构。那么我们如何将字符串变成map呢？&lt;/p&gt;

&lt;p&gt;我们只能求助于API了，你可以在&lt;a href=&quot;http://clojure.github.io/clojure/api-index.html&quot;&gt;Clojure的Index页面&lt;/a&gt;搜索map,可以找到hash-map函数。它的API说明如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;hash-map
function
Usage: (hash-map)
       (hash-map &amp;amp; keyvals)
keyval =&amp;gt; key val
Returns a new hash map with supplied mappings.  If any keys are
equal, they are handled as if by repeated uses of assoc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据提供的映射关系返回一个新的hashmap。而这里我们是一个字符串，如何提供映射关系呢？按照空格将文字切开就行了嘛！！继续找API。&lt;/p&gt;

&lt;p&gt;Java里有split方法，Clojure里有没有相应的函数呢？试试再说。。有了！在clojure.string的Namespace(Namespace和Java中的包类似，但是在Clojure中叫Namespace。这里没有将其翻译为命名空间，主要是怕有误解。)中，我们找到了叫split的函数！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;split
function
Usage: (split s re)
       (split s re limit)
Splits string on a regular expression.  Optional argument limit is
the maximum number of splits. Not lazy. Returns vector of the splits.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过正则表达式来切割字符串。看着挺像，先用再说！我们有repl嘛！直接在
repl里面输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(split &quot;万 萬&quot; #&quot; &quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行!Oops,报错了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;CompilerException java.lang.RuntimeException: Unable to resolve symbol: split in this context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找不到split?!如果在Java中报类似的错误，你会想到什么？没有引入包阿！&lt;/p&gt;

&lt;p&gt;这里也是。在Java中会默认引入java.lang包，同理在Clojure中会引入clojure.core和java.lang包。其他包则要自己引入，这里split在clojure.string包中。所以你需要引入clojure.string包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require 'clojure.string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也就是调用了require函数来进行引入！为什么clojure.string前面有个单引号呢？想想核心语法！这里暂不展开说！给大家留个思考题！！后续会专门对命名空间引入做详细介绍！&lt;/p&gt;

&lt;p&gt;光引入还没用！调用代码也需要修改！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(clojure.string/split &quot;万 萬&quot; #&quot; &quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能要吐槽了！既然引入了，为什么还要加Namespace前缀？！&lt;/p&gt;

&lt;p&gt;我们可以和Java作个比较！如果这里是Java的话，那么我们在调用split的时候，实际上是需要一个类作为前缀的，比如StringUtils.split()!但是在clojure中并没有类的概念！Namespace下面只有函数，所以它使用命名空间来确保函数的唯一性引用！&lt;/p&gt;

&lt;p&gt;当然了每次都要写这么长的命名空间的名字也是挺烦人的。Clojure提供了简写.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require ['clojure.stirng :as 'cstr])
(cstr/split &quot;万 萬&quot; #&quot; &quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:as是Keyword,是Clojure字面量的一种。它和String很类似，不过有些区别，它比String有更多的功能。
下表是Clojure所包含的字面量。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type   &lt;/th&gt;
&lt;th&gt;     Example(s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; Boolean    &lt;/td&gt;
&lt;td&gt; true,false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Character  &lt;/td&gt;
&lt;td&gt; \a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Keyword    &lt;/td&gt;
&lt;td&gt; :tag,:doc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; List       &lt;/td&gt;
&lt;td&gt; (1 2 3),(println &quot;foo&quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Map        &lt;/td&gt;
&lt;td&gt; {:name &quot;Bill&quot;,:age 42}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Nil        &lt;/td&gt;
&lt;td&gt; nil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Number     &lt;/td&gt;
&lt;td&gt; 1,4.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Set        &lt;/td&gt;
&lt;td&gt; #{:snap :crackle :pop}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; String     &lt;/td&gt;
&lt;td&gt; &quot;hello&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Symbol     &lt;/td&gt;
&lt;td&gt; user/foo,java.lang.String&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; Vector     &lt;/td&gt;
&lt;td&gt; [1 2 3]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;ok.终于得到了我们要的结果。&lt;/p&gt;

&lt;p&gt;这里的#&quot;&quot;是正则表达式(这是你遇到的第一个特殊语法，学习方法---死记！！)，它构建了Java中的Pattern，所以正则表达式内容和Java完全相同，这里就不废话了。你只需要记住其语法就行了。&lt;/p&gt;

&lt;p&gt;切开了字符串，我们来生成map吧！如何生成呢？你应该有答案了吧？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(hash-map (cstr/split &quot;万 萬&quot; #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又报错了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;IllegalArgumentException No value supplied for key: [&quot;万&quot; &quot;萬&quot;]  clojure.lang.PersistentHashMap.create (PersistentHashMap.java:77)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不合法的参数！！split得到的是个Vector([]包裹的数据结构是Vector),而hash-map要的参数类似于Java中的可变参数！如何匹配这两者呢？&lt;/p&gt;

&lt;p&gt;Clojure中提供了apply函数!API如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;clojure.core/apply
([f args] [f x args] [f x y args] [f x y z args] [f a b c d &amp;amp; args])
  Applies fn f to the argument list formed by prepending intervening arguments to args.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此函数有点特别！它的第一个参数是函数，后面是该函数所需要的参数！知道怎么调用吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply hash-map (cstr/split &quot;万 萬&quot; #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;终于成功了！！我们看到了结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{&quot;万&quot; &quot;萬&quot;}   ;以{}包裹的数据结构是map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后呢！我们需要对jfmap.clj的内容进行处理！So easy!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply hash-map (cstr/split (slurp &quot;jfmap-path&quot;) #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;进行简繁翻译&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;语法点

&lt;ul&gt;
&lt;li&gt;var的定义&lt;/li&gt;
&lt;li&gt;函数的定义&lt;/li&gt;
&lt;li&gt;闭包的使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;上一节我们完成了对jfmap.clj的读取，并生成了hashmap。但是呢，如果我们每次要使用jfmap.clj的时候都要写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(apply hash-map (cstr/split (slurp &quot;jfmap-path&quot;) #&quot; &quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;太麻烦了。在Java中的可以将其封装为一个方法来进行调用。Clojure也可以将其封装为函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn read-map
  &quot;Read trans map from file&quot;
  [path]
  (apply hash-map (clstr/split (slurp path) #&quot; &quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;defn是个宏，宏的定义后面讨论。&lt;/p&gt;

&lt;p&gt;defn是用来定义有名函数的。read-map就是函数名，和Java中的驼峰式取名不同，List系的取名方式一般是使用&quot;-&quot;。给出的原因是大写字母要按两个按键，&quot;-&quot;只需要按一个按键！！&lt;/p&gt;

&lt;p&gt;紧接着函数名的是注释，类似Java中的注释，不同的是其双引号内的内容可以多行。后面的vector是参数
列表，最后就是函数体了。&lt;/p&gt;

&lt;p&gt;现在当你再读取jfmap的时候。只需要这样调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(read-map &quot;jfmap-path&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比刚才简单了很多。但是每次都要去读取，还是不够方便。在Java中会将其赋值给一个变量，然后去调用。Clojure当然也可以。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def jfmap (read-map &quot;jfmap-path&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你直接操作jfmap就可以了。 现在我们就来按照jfmap来进行简繁翻译吧！&lt;/p&gt;

&lt;p&gt;你可能会想，很简单吧？只需要遍历需要翻译的字符串，然后到jfmap中去找对应的翻译，然后将翻译组装成字符串就行了。so easy!但当你这么想的时候，你已经陷入到了实现的细节中了！Clojure让你能够更加的关注业务而不是实现细节！&lt;/p&gt;

&lt;p&gt;这里给出的建议是：
&lt;strong&gt;请先查找Clojure是否可通过函数组合来解决问题？如果不能再考虑自己编写函
数！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为什么这么说呢？因为在Clojure中大部分的问题都可以通过其提供的函数组合来解决。你需要做的就是根据需要来组合函数！这使你能更多的思考业务而非实现细节！比如这里的问题！ 我们需要一个函数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接受一个字符串&lt;/li&gt;
&lt;li&gt;返回翻译完成的字符串&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;很简单，我们先编写函数的定义。这里我们叫translate。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后呢？需要翻译字符串。这里叫翻译字符串，实际上就是根据map的key找到value而已。在Clojure中找到这样的函数就可以了。你可以找到get函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get map k default)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很好理解吧？根据k从map中查找value，如果找不到则返回default。其实这就是核心代码了！&lt;/p&gt;

&lt;p&gt;我们知道map就是我们这里的jfmap，k实际上是获取的字符串的每个字符，而default呢？这里如果我们根据k找不到的话，就直接返回k，也就是不翻译了。所以代码修改为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get jfmap k k)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在只需要解决k就行了！继续寻找函数！现在需要的是在Clojure中用得还比较多的一个函数---map!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;clojure.core/map
([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp;amp; colls])
  Returns a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  Any remaining items in other colls are ignored. Function
  f should accept number-of-colls arguments.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到作用了吗？将函数应用到序列的每个元素上去！并返回一个由结果组成的lazy序列！你可能会问了：这是针对序列的，对字符串有效吗？试试不就知道了？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(map class &quot;aaa&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在repl里面输入如上的代码！你看到了什么？java.lang.Character?!没错，字符串会被当作字符序列来操作！但是我们需要的是字符串啊？没关系，我们有str函数!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(map (comp class str) &quot;aaa&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;comp是个什么东东？它的作用是将多个函数组合起来，从右向左的执行！！这里就是先执行str再执行class,可以看到结果打印的是java.lang.String,正是我们需要的。&lt;/p&gt;

&lt;p&gt;OK，现在我们来组合这两个函数就行了.但是问题又来了！map的第二个参数是个函数，我们怎么办呢？既然它需要函数，那我们就定义一个给它咯！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn tmp [k]
   (get jfmap k k))

(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map tmp s)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能要抱怨了！取了个什么烂名字！！居然叫tmp?!呵呵，别急！我把函数定义为tmp，是因为我要将优化掉！可以看出，这个功能非常的简单，而且只会给translate使用，那么我们需要特意定义一个单独的函数吗？&lt;/p&gt;

&lt;p&gt;不需要吧？我们直接将两个函数合并好了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map (defn tmp [k] (get jfmap k k)) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单，但是呢！既然都放到函数内部了！还需要函数名吗？&lt;/p&gt;

&lt;p&gt;就像Java中的匿名内部类一样，直接定义直接使用，不需要名字！&lt;/p&gt;

&lt;p&gt;在Clojure中有fn这个specialform来定义匿名函数！&lt;/p&gt;

&lt;p&gt;上面说defn是个宏！它的功能就类似于(还有其他功能，比如注释)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def tmp (fn [k] (get jfmap k k)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用fn来简化一下代码!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map (fn [k] (get jfmap k k)) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;舒服很多！还能更简单吗？当然！Clojure提供了#这个语法糖来定义匿名函数!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map #(get jfmap k k) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好！问题来了！这里没有了参数列表！那get函数怎么知道k是个什么东西呢？所以，这里使用%来替换，第一个参数用%或者%1替换，第二个则是%2,依次类推！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (map #(get jfmap % %) s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定了吗？没有！translate需要返回一个字符串，而map返回的是个lazy序列！需要将序列转化为字符串！到clojure.string找找！有个join函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn translate
  &quot;Trans string by map&quot;
  [s]
  (clstr/join (map #(get jfmap % %) s)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不废话了！记得要引入Namespace哦！！&lt;/p&gt;

&lt;p&gt;实际上一行代码我们就搞定了基本的翻译了！很简单吧？&lt;/p&gt;

&lt;h2&gt;读取不需要翻译的文字&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;复习&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;翻译的字，是使用的map来存储的？那不需要翻译的文字该如何存储呢？这要看你如何处理了！我这里采用的是一个很简单的方式！&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先对文字全文翻译&lt;/li&gt;
&lt;li&gt;然后对翻译后的文字再反翻译&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;比如说，&quot;阿里山&quot;直接翻译的话，那么就会变成&quot;阿裡山&quot;，但是&quot;里&quot;字是不需要翻译的。&lt;/p&gt;

&lt;p&gt;那么我就新建一个map，保存&quot;阿裡山&quot;-&gt;&quot;阿里山&quot;，将文字再翻回来！&lt;/p&gt;

&lt;p&gt;那么这里我就再需要一个类似jfmap.clj的文件就可以了。我这里叫ntmap.clj。&lt;/p&gt;

&lt;p&gt;格式和jfmap.clj类似！只不过里面存储的是需要反翻译的文字!&lt;/p&gt;

&lt;p&gt;如何读取和组装map?不需要我废话吧？&lt;/p&gt;

&lt;h2&gt;过滤不翻译的文字&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Special Form

&lt;ul&gt;
&lt;li&gt;let&lt;/li&gt;
&lt;li&gt;loop&lt;/li&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;li&gt;recur&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;过滤不翻译的文字，实际上就是反翻译!如何进行呢？原来在翻译的过程中我们是一个字符一个字符的匹配的！但是这里是一个一个的字符串！这就比较难办了！&lt;/p&gt;

&lt;p&gt;不管怎么说我们先定义函数!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn do-trans
  [s tmap ntmap]
   )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先第一件事就是去全文翻译！然后获得结果！提供给后续函数使用！&lt;/p&gt;

&lt;p&gt;Java中有局部变量！只需要将变量写在方法里就可以了！但是在Clojure中不同，它需要通过let这个Special Form来处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn do-trans
  [s tmap ntmap]
  (let [re (translate s tmap)]

))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let后面是个Vector，用来进行var绑定，这里translate翻译的结果会被绑定到re这个var上！而re的作用范围就只在let这个括号内部！&lt;/p&gt;

&lt;p&gt;接着呢！就是对re进行反翻译！没啥现成的函数了！只能自己处理！代码如下！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn do-trans
  [s tmap ntmap]
  (let [re (translate s tmap)]
    (loop [result re
           k (keys ntmap)]
      (if (seq k)
        (recur (clstr/replace result (first k) (ntmap (first k))) (rest k))
          result))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;loop又是个Special Form，看起来像循环！实际上它是个递归！&lt;/p&gt;

&lt;p&gt;loop后面也是个参数Vector，功能和let的相同！这里将re绑定到了result，以及ntmap的key绑定到了k上！&lt;/p&gt;

&lt;p&gt;然后是if判断，还是个Special Form，(seq k)判断k是否是个序列！如果是则执行recur，如果不是则返回result.其实seq并不是判断函数！&lt;/p&gt;

&lt;p&gt;它是用来构建序列的！这里之所以能用来判断，基于两个原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在Clojure中除了nil和false是假，其他全是真&lt;/li&gt;
&lt;li&gt;(seq nil)和(seq ())返回nil&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;然后seq就可以用来作为判断条件了！&lt;/p&gt;

&lt;p&gt;recur是递归调用！这里调用的是loop，传递的参数是替换后的s和剩余的k.&lt;/p&gt;

&lt;p&gt;实际功能就是，遍历ntmap中的key，如果找到了，则使用value替换掉！&lt;/p&gt;

&lt;p&gt;至此，就完成了翻译的所有功能！考虑下如果使用Java需要多少行代码？？&lt;/p&gt;

&lt;p&gt;测试翻译一个页面的时间为70毫秒左右，速度还是不错的！&lt;/p&gt;

&lt;h2&gt;提供给Java调用&lt;/h2&gt;

&lt;p&gt;Clojure提供了将函数给Java调用的功能！&lt;/p&gt;

&lt;p&gt;首先，在core.clj文件中编写函数，比如下面的翻译:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn -transAll
  &quot;翻译所有&quot;
  [source mapPath]
  (trans/translate source (trans/read-map mapPath) &quot;&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数名前面一定要有个&quot;-&quot;。 然后在命名空间里添加如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns jft.core
;这里开始
 (:gen-class
   :name jft.core.Trans
   :methods [#^{:static true} [transAll [String String] String]])
;这里结束
  (:require [clojure.string :as cstr]
            [jft.trans :as trans])
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该不难理解吧？name是在Java中import的时候的名字！methods是可以调用的方法,这里注解为静态方法！&lt;/p&gt;

&lt;p&gt;注意这里的transAll前面是没有&quot;-&quot;的，后面是参数和返回类型！&lt;/p&gt;

&lt;h2&gt;打包&lt;/h2&gt;

&lt;p&gt;需要给Java调用，那就要先封装为jar包。非常简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就可以提供给Java调用了！&lt;/p&gt;

&lt;h1&gt;源码&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;/assets/clojure/jft.zip&quot;&gt;jft&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Clojure教程-环境搭建与Hello World</title>
        <link href="http://ivanpig.github.io/2014/02/01/first_step.html"/>
        <updated>2014-02-01T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/02/01/first_step</id>
        <content type="html">&lt;h1&gt;环境搭建&lt;/h1&gt;

&lt;p&gt;Clojure是JVM上的一种语言，其语法是Lisp格式，所以称为是JVM上的Lisp方言。&lt;/p&gt;

&lt;p&gt;Clojure依赖于JDK。请确保你的机器上安装了JDK6+。Clojure的安装非常的简单。
可以分为两种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过Leiningen安装&lt;/li&gt;
&lt;li&gt;手动安装&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过Leiningen是比较普遍也很方便的方式。我们先通过Leiningen来安装。&lt;/p&gt;

&lt;h2&gt;通过Leiningen安装&lt;/h2&gt;

&lt;p&gt;Leiningen和Maven比较类似，是Clojure语言的管理工具。其实它就是基于Maven
构建的。我们先来安装Leiningen&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先下载&lt;a href=&quot;https://raw.github.com/technomancy/leiningen/stable/bin/lein&quot;&gt;lein
script&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;将lein script放置到你的path下(linux下直接放到用户目录下即可)，保存文
件名叫lein。&lt;/li&gt;
&lt;li&gt;将其权限设置为可执行(chmod a+x lein)&lt;/li&gt;
&lt;li&gt;打开shell，输入lein即可&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;leiningen会自动下载需要的依赖。运行完成后,Clojure开发环境即安装完成。&lt;/p&gt;

&lt;h2&gt;手动安装&lt;/h2&gt;

&lt;p&gt;leiningen需要以项目为单位才能运行。比如你想运行一个hello.clj程序，如果
你通过leiningen来运行，则hello.clj需要在lein项目内，且设置为core，才能
运行,比较麻烦(这个问题在Maven中同样存在)。&lt;/p&gt;

&lt;p&gt;而通过手动安装可以解决这个问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先下载&lt;a href=&quot;http://repo1.maven.org/maven2/org/clojure/clojure/1.5.1/clojure-1.5.1.zip&quot;&gt;Clojure&lt;/a&gt;,
目前稳定版本是1.5.1&lt;/li&gt;
&lt;li&gt;解压到任意位置，其中最主要的文件就是clojure-1.5.1.jar&lt;/li&gt;
&lt;li&gt;在path下编写脚本clj,输入如下内容&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;java -jar /home/ivan/soft/clojure-1.5.1/clojure-1.5.1.jar $1
 #clojure.jar请输入你本机的路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以执行单个的Clojure文件了&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;HelloWorld&lt;/h1&gt;

&lt;h2&gt;REPL&lt;/h2&gt;

&lt;p&gt;老掉牙的入门程序。如果你想体验Clojure。那么只需要在Shell中运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein repl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则会运行一个Clojure的REPL环境，你可以直接输入Clojure代码，REPL直接反馈结果。&lt;/p&gt;

&lt;p&gt;试试输入如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(println &quot;Hello World&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/repl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;运行单个文件&lt;/h2&gt;

&lt;p&gt;如果你想将Clojure代码保存到文件中去运行，那么将上面的代码保存到.clj结尾的文件中，并在shell中运行如下命令即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;clj hello.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编辑器&lt;/h2&gt;

&lt;p&gt;Clojure编辑器主要还是文本编辑器，比如emacs,vim等,大部分的文本编辑器都有Clojure语言的支持。&lt;/p&gt;

&lt;p&gt;IDE的话，Intellij IDEA有Clojure环境，不过速度太慢了。一般编写使用文本编辑器即可。
这里使用Emacs的clojure-mode作为开发环境。&lt;/p&gt;

&lt;p&gt;界面如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/emacs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外还有lighttable，详细介绍可见&lt;a href=&quot;http://lighttable.com/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关文章见&lt;a href=&quot;/2014/11/28/pigtheme.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;环境搭建&lt;/h1&gt;

&lt;p&gt;Clojure是JVM上的一种语言，其语法是Lisp格式，所以称为是JVM上的Lisp方言。&lt;/p&gt;

&lt;p&gt;Clojure依赖于JDK。请确保你的机器上安装了JDK6+。Clojure的安装非常的简单。
可以分为两种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过Leiningen安装&lt;/li&gt;
&lt;li&gt;手动安装&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过Leiningen是比较普遍也很方便的方式。我们先通过Leiningen来安装。&lt;/p&gt;

&lt;h2&gt;通过Leiningen安装&lt;/h2&gt;

&lt;p&gt;Leiningen和Maven比较类似，是Clojure语言的管理工具。其实它就是基于Maven
构建的。我们先来安装Leiningen&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先下载&lt;a href=&quot;https://raw.github.com/technomancy/leiningen/stable/bin/lein&quot;&gt;lein
script&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;将lein script放置到你的path下(linux下直接放到用户目录下即可)，保存文
件名叫lein。&lt;/li&gt;
&lt;li&gt;将其权限设置为可执行(chmod a+x lein)&lt;/li&gt;
&lt;li&gt;打开shell，输入lein即可&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;leiningen会自动下载需要的依赖。运行完成后,Clojure开发环境即安装完成。&lt;/p&gt;

&lt;h2&gt;手动安装&lt;/h2&gt;

&lt;p&gt;leiningen需要以项目为单位才能运行。比如你想运行一个hello.clj程序，如果
你通过leiningen来运行，则hello.clj需要在lein项目内，且设置为core，才能
运行,比较麻烦(这个问题在Maven中同样存在)。&lt;/p&gt;

&lt;p&gt;而通过手动安装可以解决这个问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先下载&lt;a href=&quot;http://repo1.maven.org/maven2/org/clojure/clojure/1.5.1/clojure-1.5.1.zip&quot;&gt;Clojure&lt;/a&gt;,
目前稳定版本是1.5.1&lt;/li&gt;
&lt;li&gt;解压到任意位置，其中最主要的文件就是clojure-1.5.1.jar&lt;/li&gt;
&lt;li&gt;在path下编写脚本clj,输入如下内容&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;java -jar /home/ivan/soft/clojure-1.5.1/clojure-1.5.1.jar $1
 #clojure.jar请输入你本机的路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以执行单个的Clojure文件了&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;HelloWorld&lt;/h1&gt;

&lt;h2&gt;REPL&lt;/h2&gt;

&lt;p&gt;老掉牙的入门程序。如果你想体验Clojure。那么只需要在Shell中运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein repl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则会运行一个Clojure的REPL环境，你可以直接输入Clojure代码，REPL直接反馈结果。&lt;/p&gt;

&lt;p&gt;试试输入如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(println &quot;Hello World&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/repl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;运行单个文件&lt;/h2&gt;

&lt;p&gt;如果你想将Clojure代码保存到文件中去运行，那么将上面的代码保存到.clj结尾的文件中，并在shell中运行如下命令即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;clj hello.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编辑器&lt;/h2&gt;

&lt;p&gt;Clojure编辑器主要还是文本编辑器，比如emacs,vim等,大部分的文本编辑器都有Clojure语言的支持。&lt;/p&gt;

&lt;p&gt;IDE的话，Intellij IDEA有Clojure环境，不过速度太慢了。一般编写使用文本编辑器即可。
这里使用Emacs的clojure-mode作为开发环境。&lt;/p&gt;

&lt;p&gt;界面如图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/clojure/emacs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外还有lighttable，详细介绍可见&lt;a href=&quot;http://lighttable.com/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关文章见&lt;a href=&quot;/2014/11/28/pigtheme.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-升级</title>
        <link href="http://ivanpig.github.io/2013/10/02/upgrading.html"/>
        <updated>2013-10-02T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/10/02/upgrading</id>
        <content type="html">&lt;h1&gt;Upgrading to the Latest Version&lt;/h1&gt;

&lt;p&gt;不幸的是，框架无法自动从老版本升级到新版本。主要原因是新版本的依赖可能会有接口方面的修改，导致老代码无法正常运行。&lt;/p&gt;

&lt;p&gt;最好的方法是使用&lt;a href=&quot;https://github.com/xsc/lein-ancient&quot;&gt;lein-ancient&lt;/a&gt;插件来保持你的依赖包时刻为最新。这将会帮你很容易的发现哪些插件有了新的版本。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Upgrading to the Latest Version&lt;/h1&gt;

&lt;p&gt;不幸的是，框架无法自动从老版本升级到新版本。主要原因是新版本的依赖可能会有接口方面的修改，导致老代码无法正常运行。&lt;/p&gt;

&lt;p&gt;最好的方法是使用&lt;a href=&quot;https://github.com/xsc/lein-ancient&quot;&gt;lein-ancient&lt;/a&gt;插件来保持你的依赖包时刻为最新。这将会帮你很容易的发现哪些插件有了新的版本。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-实用库</title>
        <link href="http://ivanpig.github.io/2013/10/01/useful_libraries.html"/>
        <updated>2013-10-01T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/10/01/useful_libraries</id>
        <content type="html">&lt;p&gt;Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。&lt;/p&gt;

&lt;p&gt;包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，
Tower提供国际化等等其他包。&lt;/p&gt;

&lt;p&gt;当然，还有很多的包能给web开发带来便利。&lt;/p&gt;

&lt;p&gt;具体请见&lt;a href=&quot;http://www.luminusweb.net/docs/useful_libraries.md&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。&lt;/p&gt;

&lt;p&gt;包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，
Tower提供国际化等等其他包。&lt;/p&gt;

&lt;p&gt;当然，还有很多的包能给web开发带来便利。&lt;/p&gt;

&lt;p&gt;具体请见&lt;a href=&quot;http://www.luminusweb.net/docs/useful_libraries.md&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-部署</title>
        <link href="http://ivanpig.github.io/2013/09/30/deployment.html"/>
        <updated>2013-09-30T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/30/deployment</id>
        <content type="html">&lt;h1&gt;Running Standalone&lt;/h1&gt;

&lt;p&gt;要创建一个可独立运行的包，只需要运行如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包完成的jar会出现在target目录下。可以通过下面的命令运行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;java -jar myapp-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置\$PORT
环境变量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;export PORT=8080
java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Delpoying on Immutant&lt;/h1&gt;

&lt;p&gt;如果想部署应用到Immutant，请执行如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein immutant deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请访问&lt;a href=&quot;http://immutant.org/tutorials/deploying/index.html&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Deploying to Tomcat&lt;/h1&gt;

&lt;p&gt;如果想打包应用为war包:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后只需要将打好的包拷贝到tomcat的webapps目录下即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Heroku Deployment&lt;/h1&gt;

&lt;p&gt;首先确保你有git和Heroku，然后按照下面的步骤做就可以了。
要测试你的应用是否通过foreman在本地运行，只需要执行下面的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;foreman start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你能初始化你的git仓库，并提交你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git init
git add .
git commit -m &quot;init&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Heroku创建你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以创建数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku addons:add heroku-postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接信息可以在你的Heroku页面看到. 部署应用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你的应用就被部署到了Heroku上.
具体信息请看&lt;a href=&quot;https://devcenter.heroku.com/articles/clojure&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Running Standalone&lt;/h1&gt;

&lt;p&gt;要创建一个可独立运行的包，只需要运行如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包完成的jar会出现在target目录下。可以通过下面的命令运行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;java -jar myapp-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置\$PORT
环境变量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;export PORT=8080
java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Delpoying on Immutant&lt;/h1&gt;

&lt;p&gt;如果想部署应用到Immutant，请执行如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein immutant deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请访问&lt;a href=&quot;http://immutant.org/tutorials/deploying/index.html&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Deploying to Tomcat&lt;/h1&gt;

&lt;p&gt;如果想打包应用为war包:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后只需要将打好的包拷贝到tomcat的webapps目录下即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Heroku Deployment&lt;/h1&gt;

&lt;p&gt;首先确保你有git和Heroku，然后按照下面的步骤做就可以了。
要测试你的应用是否通过foreman在本地运行，只需要执行下面的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;foreman start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你能初始化你的git仓库，并提交你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git init
git add .
git commit -m &quot;init&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Heroku创建你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以创建数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku addons:add heroku-postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接信息可以在你的Heroku页面看到. 部署应用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你的应用就被部署到了Heroku上.
具体信息请看&lt;a href=&quot;https://devcenter.heroku.com/articles/clojure&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-国际化</title>
        <link href="http://ivanpig.github.io/2013/09/29/internationalization.html"/>
        <updated>2013-09-29T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/29/internationalization</id>
        <content type="html">&lt;h1&gt;Internationalization&lt;/h1&gt;

&lt;p&gt;Luminius模板包含了&lt;a href=&quot;https://github.com/ptaoussanis/tower&quot;&gt;Tower&lt;/a&gt;依赖，Tower提供了函数式的国际化和翻译。&lt;/p&gt;

&lt;p&gt;首先，我们需要创建一个字典map：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def tconfig
  {:fallback-locale :en-US
   :dictionary
   {:en-US   {:page {:title &quot;Here is a title&quot;
                     :content &quot;Time to start building your site.&quot;}
              :missing  &quot;&amp;lt;Missing translation: [%1$s %2$s %3$s]&amp;gt;&quot;}
    :fr-FR {:page {:title &quot;Voici un titre&quot;
                   :content &quot;Il est temps de commencer votre site.&quot;}}
    }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Tower中间件来包装我们的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def app
 (app-handler
   [routes]
   :middleware
   [#(taoensso.tower.ring/wrap-tower-middleware % {:tconfig tconfig})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间件将会通过accept-language头来确定相应的语言。中间件将会添加两个key到请求中。地一个key是:t,它的值是翻译函数。第二个key是:locale，它的值是中间件提供的语言类型。&lt;/p&gt;

&lt;p&gt;你可以提供一个自定义的locale-selector函数给中间件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn my-selector [req]
  (when (= (:remote-addr req) &quot;127.0.0.1&quot;) :en))

(def app
  (app-handler
    [routes]
    :middleware
    [#(wrap-tower-middleware % {:tconfig tconfig
                                :locale-selector my-selector})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;中间件将按照如下顺序查找，会使用第一个有效的语言来进行处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(:locale request)
(when-let [ls locale-selector] (ls request))
(:locale session)
(:locale params)
(locale-from-headers headers)
fallback-locale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当中间件设置完成后，我们可以通过下面的代码来实现国际化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns mysite.routes.home
  (:use compojure.core)
  (:require [i18ntest.layout :as layout]
            [i18ntest.util :as util]
            [taoensso.tower :refer [t]]))

(defn home-page [{:keys [locale tconfig]}]
  (layout/render
    &quot;home.html&quot; {:title   (t locale tconfig :page/title)
                 :content (t locale tconfig :page/content)}))

(defn about-page []
  (layout/render &quot;about.html&quot;))

(defroutes home-routes
  (GET &quot;/&quot; req (home-page req))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Internationalization&lt;/h1&gt;

&lt;p&gt;Luminius模板包含了&lt;a href=&quot;https://github.com/ptaoussanis/tower&quot;&gt;Tower&lt;/a&gt;依赖，Tower提供了函数式的国际化和翻译。&lt;/p&gt;

&lt;p&gt;首先，我们需要创建一个字典map：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def tconfig
  {:fallback-locale :en-US
   :dictionary
   {:en-US   {:page {:title &quot;Here is a title&quot;
                     :content &quot;Time to start building your site.&quot;}
              :missing  &quot;&amp;lt;Missing translation: [%1$s %2$s %3$s]&amp;gt;&quot;}
    :fr-FR {:page {:title &quot;Voici un titre&quot;
                   :content &quot;Il est temps de commencer votre site.&quot;}}
    }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Tower中间件来包装我们的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def app
 (app-handler
   [routes]
   :middleware
   [#(taoensso.tower.ring/wrap-tower-middleware % {:tconfig tconfig})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间件将会通过accept-language头来确定相应的语言。中间件将会添加两个key到请求中。地一个key是:t,它的值是翻译函数。第二个key是:locale，它的值是中间件提供的语言类型。&lt;/p&gt;

&lt;p&gt;你可以提供一个自定义的locale-selector函数给中间件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn my-selector [req]
  (when (= (:remote-addr req) &quot;127.0.0.1&quot;) :en))

(def app
  (app-handler
    [routes]
    :middleware
    [#(wrap-tower-middleware % {:tconfig tconfig
                                :locale-selector my-selector})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;中间件将按照如下顺序查找，会使用第一个有效的语言来进行处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(:locale request)
(when-let [ls locale-selector] (ls request))
(:locale session)
(:locale params)
(locale-from-headers headers)
fallback-locale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当中间件设置完成后，我们可以通过下面的代码来实现国际化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns mysite.routes.home
  (:use compojure.core)
  (:require [i18ntest.layout :as layout]
            [i18ntest.util :as util]
            [taoensso.tower :refer [t]]))

(defn home-page [{:keys [locale tconfig]}]
  (layout/render
    &quot;home.html&quot; {:title   (t locale tconfig :page/title)
                 :content (t locale tconfig :page/content)}))

(defn about-page []
  (layout/render &quot;about.html&quot;))

(defroutes home-routes
  (GET &quot;/&quot; req (home-page req))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-日志</title>
        <link href="http://ivanpig.github.io/2013/09/28/logging.html"/>
        <updated>2013-09-28T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/28/logging</id>
        <content type="html">&lt;h1&gt;Logging&lt;/h1&gt;

&lt;p&gt;Luminus模板中包括&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Timbre&lt;/a&gt;和&lt;a href=&quot;https://bitbucket.org/postspectacular/rotor&quot;&gt;Rotor&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;日志通过在handler/init函数中进行如下的设置进行初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/append})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;.log&quot; :max-size 10000 :backlog 10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timbre可以记录Clojure的所有日志.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example
 (:use [taoensso.timbre :only [trace debug info warn error fatal]]))

(info &quot;Hello&quot;)

=&amp;gt;2012-Dec-24 09:03:09 -0500 Helios.local INFO [timbretest] - Hello

(info {:user {:id &quot;Anonymous&quot;}})

=&amp;gt;2012-Dec-24 09:02:44 -0500 Helios.local INFO [timbretest] - {:user {:id &quot;Anonymous&quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请见&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Logging&lt;/h1&gt;

&lt;p&gt;Luminus模板中包括&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Timbre&lt;/a&gt;和&lt;a href=&quot;https://bitbucket.org/postspectacular/rotor&quot;&gt;Rotor&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;日志通过在handler/init函数中进行如下的设置进行初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/append})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;.log&quot; :max-size 10000 :backlog 10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timbre可以记录Clojure的所有日志.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example
 (:use [taoensso.timbre :only [trace debug info warn error fatal]]))

(info &quot;Hello&quot;)

=&amp;gt;2012-Dec-24 09:03:09 -0500 Helios.local INFO [timbretest] - Hello

(info {:user {:id &quot;Anonymous&quot;}})

=&amp;gt;2012-Dec-24 09:02:44 -0500 Helios.local INFO [timbretest] - {:user {:id &quot;Anonymous&quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请见&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-数据迁移</title>
        <link href="http://ivanpig.github.io/2013/09/27/database_migrations.html"/>
        <updated>2013-09-27T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/27/database_migrations</id>
        <content type="html">&lt;h1&gt;Migrations&lt;/h1&gt;

&lt;p&gt;默认情况下Luminus使用Ragtime来进行数据迁移。当你在创建Luminus项目时添加了+mysql或+postgres选项时，Ragtime会自动被添加进来。&lt;/p&gt;

&lt;h1&gt;Migrations with Ragtime&lt;/h1&gt;

&lt;p&gt;Ragtime通过Leiningen插件来执行。此插件需要配置project.clj的:plugins中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:plugins [... [ragtime/ragtime.lein &quot;0.3.4&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际的迁移动作是由ragtime.sql.files这个适配器来执行。此适配器需要配置在依赖列表中，同时配置相关数据库配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:dependencies [... [ragtime/ragtime.sql.files &quot;0.3.4&quot;]]
:ragtime {:migrations ragtime.sql.files/migrations
          :database &quot;jdbc:mysql://localhost:3306/example_db?user=root&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ragtime.sql.files适配器会从项目根目录下的指定目录查找sql脚本。我们只需要将脚本添加到对应目录下即可。&lt;/p&gt;

&lt;p&gt;脚本按字母顺序排序。我们来创建两个脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;migrations/2014-13-57-30-create-tables.up.sql

CREATE TABLE users (id INT, name VARCHAR(25));

migrations/2014-13-57-30-create-tables.down.sql

DROP TABLE users;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令回滚:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime rollback
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Migrations with Lobos&lt;/h1&gt;

&lt;p&gt;我们来看看如何在Luminus中集成Lobos.Lobos提供了功能强大的DSL来编
写迁移代码以及方便的对Korma进行扩展.&lt;/p&gt;

&lt;p&gt;首先，我们来创建一个Luminus项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus ltest +site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Lobos依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[lobos &quot;1.0.0-beta1&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们需要在src目录下创建一个lobos目录，并在该目录下创建两个文件
config.clj和migrations.clj，其中包含如下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.config
  (:use lobos.connectivity)
  (:require [ltest.models.schema :as schema]))

(open-global schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.migrations
  (:refer-clojure
   :exclude [alter drop bigint boolean char double float time])
  (:use (lobos [migration :only [defmigration]] core schema config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来创建我们的第一个迁移，使用lobos来管理create-users-table函数.
你只需要将create-users-table函数从schema.clj移动到migations.clj中即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmigration add-users-table
  (up [] (create
          (table :users
                 (varchar :id 20 :primary-key)
                 (varchar :first_name 30)
                 (varchar :last_name 30)
                 (varchar :email 30)
                 (boolean :admin)
                 (time    :last_login)
                 (boolean :is_active)
                 (varchar :pass 100))))
  (down [] (drop (table :users))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想添加其他的迁移，只需要再添加一个类似的definition即可。
现在我们定义了迁移，下面我们来看看schema命名空间，我们来更新并使用它。
我们将添加lobos.migration依赖:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns ltest.models.schema
  (:use [lobos.core :only (defcommand migrate)])
  (:require [noir.io :as io]
            [lobos.migration :as lm]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着定义一个command，返回给我们一个待迁移列表.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defcommand pending-migrations []
  (lm/pending-migrations db-spec sname))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据这个信息我们可以知道数据库的状态。我们来重命名initialised?和
actualized?函数，当待迁移列表没有数据时返回true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn actualized?
  &quot;checks if there are no pending migrations&quot;
  []
  (empty? (pending-migrations)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还需要将create-tables函数替换为actualize函数，actualize函数将会触
发迁移。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def actualize migrate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上actualize只是一个对migrate的引用，migrate是lobos.core中的函数.
最后我们需要做的就是更新handler.clj文件，来使用我们的新函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;runs when the application starts and checks if the database
   schema exists, calls schema/create-tables if not.&quot;
  []
  (if-not (schema/actualized?)
    (schema/actualize)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在运行你的服务器，你的应用将会自动运行所有的待执行迁移。
希望这个教程对你在Luminus中使用数据迁移有帮助。相关代码请见&lt;a href=&quot;https://github.com/edtsech/ltest&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Popular Migrations Alternatives&lt;/h1&gt;

&lt;p&gt;下面是几个比较流行的数据库迁移工具:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Drift - Drift是一个使用Clojure编写的数据库迁移工具。Drift工作方式和Rails迁移方式类似-使用一个目录来存放你所有的迁移文件。Drift将会决定去运行哪个合适的文件。&lt;/li&gt;
&lt;li&gt;Migratus - 一个通用的迁移框架，有一个数据库迁移的实现&lt;/li&gt;
&lt;li&gt;Ragtime - Ragtime是一个迁移结构化数据的Clojure库。它定义了一组接口来处理迁移，就像Ring定义了一组接口来处理web应用一样。&lt;/li&gt;
&lt;li&gt;Lobos - Lobos是一个使用Clojure编写的SQL数据库操作和迁移库.目前它提供对H2,MySQL,PostgreSQL,SQLite和SQL Server的支持.&lt;/li&gt;
&lt;/ul&gt;

</content>
        <summary type="html">&lt;h1&gt;Migrations&lt;/h1&gt;

&lt;p&gt;默认情况下Luminus使用Ragtime来进行数据迁移。当你在创建Luminus项目时添加了+mysql或+postgres选项时，Ragtime会自动被添加进来。&lt;/p&gt;

&lt;h1&gt;Migrations with Ragtime&lt;/h1&gt;

&lt;p&gt;Ragtime通过Leiningen插件来执行。此插件需要配置project.clj的:plugins中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:plugins [... [ragtime/ragtime.lein &quot;0.3.4&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际的迁移动作是由ragtime.sql.files这个适配器来执行。此适配器需要配置在依赖列表中，同时配置相关数据库配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:dependencies [... [ragtime/ragtime.sql.files &quot;0.3.4&quot;]]
:ragtime {:migrations ragtime.sql.files/migrations
          :database &quot;jdbc:mysql://localhost:3306/example_db?user=root&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ragtime.sql.files适配器会从项目根目录下的指定目录查找sql脚本。我们只需要将脚本添加到对应目录下即可。&lt;/p&gt;

&lt;p&gt;脚本按字母顺序排序。我们来创建两个脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;migrations/2014-13-57-30-create-tables.up.sql

CREATE TABLE users (id INT, name VARCHAR(25));

migrations/2014-13-57-30-create-tables.down.sql

DROP TABLE users;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令回滚:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime rollback
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Migrations with Lobos&lt;/h1&gt;

&lt;p&gt;我们来看看如何在Luminus中集成Lobos.Lobos提供了功能强大的DSL来编
写迁移代码以及方便的对Korma进行扩展.&lt;/p&gt;

&lt;p&gt;首先，我们来创建一个Luminus项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus ltest +site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Lobos依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[lobos &quot;1.0.0-beta1&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们需要在src目录下创建一个lobos目录，并在该目录下创建两个文件
config.clj和migrations.clj，其中包含如下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.config
  (:use lobos.connectivity)
  (:require [ltest.models.schema :as schema]))

(open-global schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.migrations
  (:refer-clojure
   :exclude [alter drop bigint boolean char double float time])
  (:use (lobos [migration :only [defmigration]] core schema config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来创建我们的第一个迁移，使用lobos来管理create-users-table函数.
你只需要将create-users-table函数从schema.clj移动到migations.clj中即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmigration add-users-table
  (up [] (create
          (table :users
                 (varchar :id 20 :primary-key)
                 (varchar :first_name 30)
                 (varchar :last_name 30)
                 (varchar :email 30)
                 (boolean :admin)
                 (time    :last_login)
                 (boolean :is_active)
                 (varchar :pass 100))))
  (down [] (drop (table :users))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想添加其他的迁移，只需要再添加一个类似的definition即可。
现在我们定义了迁移，下面我们来看看schema命名空间，我们来更新并使用它。
我们将添加lobos.migration依赖:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns ltest.models.schema
  (:use [lobos.core :only (defcommand migrate)])
  (:require [noir.io :as io]
            [lobos.migration :as lm]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着定义一个command，返回给我们一个待迁移列表.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defcommand pending-migrations []
  (lm/pending-migrations db-spec sname))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据这个信息我们可以知道数据库的状态。我们来重命名initialised?和
actualized?函数，当待迁移列表没有数据时返回true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn actualized?
  &quot;checks if there are no pending migrations&quot;
  []
  (empty? (pending-migrations)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还需要将create-tables函数替换为actualize函数，actualize函数将会触
发迁移。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def actualize migrate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上actualize只是一个对migrate的引用，migrate是lobos.core中的函数.
最后我们需要做的就是更新handler.clj文件，来使用我们的新函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;runs when the application starts and checks if the database
   schema exists, calls schema/create-tables if not.&quot;
  []
  (if-not (schema/actualized?)
    (schema/actualize)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在运行你的服务器，你的应用将会自动运行所有的待执行迁移。
希望这个教程对你在Luminus中使用数据迁移有帮助。相关代码请见&lt;a href=&quot;https://github.com/edtsech/ltest&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Popular Migrations Alternatives&lt;/h1&gt;

&lt;p&gt;下面是几个比较流行的数据库迁移工具:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Drift - Drift是一个使用Clojure编写的数据库迁移工具。Drift工作方式和Rails迁移方式类似-使用一个目录来存放你所有的迁移文件。Drift将会决定去运行哪个合适的文件。&lt;/li&gt;
&lt;li&gt;Migratus - 一个通用的迁移框架，有一个数据库迁移的实现&lt;/li&gt;
&lt;li&gt;Ragtime - Ragtime是一个迁移结构化数据的Clojure库。它定义了一组接口来处理迁移，就像Ring定义了一组接口来处理web应用一样。&lt;/li&gt;
&lt;li&gt;Lobos - Lobos是一个使用Clojure编写的SQL数据库操作和迁移库.目前它提供对H2,MySQL,PostgreSQL,SQLite和SQL Server的支持.&lt;/li&gt;
&lt;/ul&gt;

</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-访问数据库</title>
        <link href="http://ivanpig.github.io/2013/09/26/database_access.html"/>
        <updated>2013-09-26T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/26/database_access</id>
        <content type="html">&lt;h1&gt;Configuring the Database&lt;/h1&gt;

&lt;p&gt;当你使用数据库参数来创建Luminus工程时，比如+postgress，那么Luminus会使用Korma来处理数据库操作.&lt;/p&gt;

&lt;p&gt;Korma是一个基于Clojure的数据库操作DSL。Korma提供了一套简单的接口，方便你来处理复杂的数据。&lt;/p&gt;

&lt;p&gt;给一个现有的项目添加数据库支持，非常的简单。首先，你需要在project.clj文件中添加Korma依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[korma &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还需要相应数据库的驱动，所以你还需要在project.clj中添加相关的数据库驱动。比如说，你要连接PostreSQL数据库，你需要添加如下的依赖.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[postgresql/postgresql &quot;9.3-1102-jdbc41&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完依赖后，你可以创建一个新的namespace来管理你的model,这个namespace建议叫db.core。你需要在里面引入korma.db。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:use korma.core
        [korma.db :only (defdb)]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Setting up the database connection&lt;/h2&gt;

&lt;p&gt;配置完依赖后，我们要做的事情就是定义数据库连接。我们只需要提供一个包含连接信息的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:subprotocol &quot;postgresql&quot;
         :subname &quot;//localhost/my_website&quot;
         :user &quot;admin&quot;
         :password &quot;admin&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者也可以配置服务器提供的JNDI名称来创建连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:name &quot;jdbc/myDatasource&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这种方式适合当你有多个连接的时候。比如说，你有个dev/staging/production
服务器，你可以将JNDI连接指向它所配置的数据库。应用程序将会从环境中来加
载数据库连接信息。这意味着，你可以随意的改变你的数据库连接，而不需要修
改你的代码。 最后，你能自己配置JDBC连接:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec
  {:datasource
    (doto (new PGPoolingDataSource)
     (.setServerName   &quot;localhost&quot;)
     (.setDatabaseName &quot;my_website&quot;)
     (.setUser         &quot;admin&quot;)
     (.setPassword     &quot;admin&quot;)
     (.setMaxConnections 10))})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Creating tables&lt;/h2&gt;

&lt;p&gt;Korma依赖clojure.java.jdbc.这个库提供操作表的功能。&lt;/p&gt;

&lt;p&gt;你可以使用create-table函数来从应用中创建数据表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn create-users-table []
  (sql/db-do-commands db-spec
    (sql/create-table-ddl
      :users
      [:id &quot;varchar(32)&quot;]
      [:pass &quot;varchar(100)&quot;])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create-table-ddl函数需要包含在db-do-commands内，db-do-commands保证了数据库连接的关闭。&lt;/p&gt;

&lt;h1&gt;Accessing the Database&lt;/h1&gt;

&lt;p&gt;当使用Korma时，你需要先用defdb来包裹db-spec。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defdb db schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会使用c3p0来创建一个连接池。需要注意的是，最后创建的连接池会被设为默认的连接池。&lt;/p&gt;

&lt;p&gt;Korma使用entities来表示sql表。这个entities构成了你查询的核心。&lt;/p&gt;

&lt;p&gt;entities使用defentity宏来创建:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defentity users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来创建user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-user [user]
  (insert users
          (values user)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果我们想查询user，我们可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn get-user [id]
  (first (select users
                 (where {:id id})
                 (limit 1))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细文档可参考&lt;a href=&quot;http://sqlkorma.com/docs&quot;&gt;Korma官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Yesql&lt;/h1&gt;

&lt;p&gt;Korma提供了操作SQL的DSL，而Yesql可以直接操作SQL.&lt;/p&gt;

&lt;p&gt;如果要使用Yesql你需要添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[yesql &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在classpath下创建一个包含查询的SQL文件，比如resources/queries.sql.文件格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -- name: find-users
    -- Find the users with the given ID(s).
    SELECT *
    FROM user
    WHERE user_id IN (:id)
    AND age &amp;gt; :min_age

    -- name: user-count
    -- Counts all the users.
    SELECT count(*) AS count
    FROM user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建问上述文件后，你需要在需要的地方引入yesql.core/defqueries。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:require [yesql.core :refer [defqueries]]))

(defqueries &quot;resources/queries.sql&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个查询可以像函数一样通过名字来调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(find-users db-spec [1001 1003 1005] 18)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Configuring the Database&lt;/h1&gt;

&lt;p&gt;当你使用数据库参数来创建Luminus工程时，比如+postgress，那么Luminus会使用Korma来处理数据库操作.&lt;/p&gt;

&lt;p&gt;Korma是一个基于Clojure的数据库操作DSL。Korma提供了一套简单的接口，方便你来处理复杂的数据。&lt;/p&gt;

&lt;p&gt;给一个现有的项目添加数据库支持，非常的简单。首先，你需要在project.clj文件中添加Korma依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[korma &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还需要相应数据库的驱动，所以你还需要在project.clj中添加相关的数据库驱动。比如说，你要连接PostreSQL数据库，你需要添加如下的依赖.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[postgresql/postgresql &quot;9.3-1102-jdbc41&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完依赖后，你可以创建一个新的namespace来管理你的model,这个namespace建议叫db.core。你需要在里面引入korma.db。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:use korma.core
        [korma.db :only (defdb)]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Setting up the database connection&lt;/h2&gt;

&lt;p&gt;配置完依赖后，我们要做的事情就是定义数据库连接。我们只需要提供一个包含连接信息的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:subprotocol &quot;postgresql&quot;
         :subname &quot;//localhost/my_website&quot;
         :user &quot;admin&quot;
         :password &quot;admin&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者也可以配置服务器提供的JNDI名称来创建连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:name &quot;jdbc/myDatasource&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这种方式适合当你有多个连接的时候。比如说，你有个dev/staging/production
服务器，你可以将JNDI连接指向它所配置的数据库。应用程序将会从环境中来加
载数据库连接信息。这意味着，你可以随意的改变你的数据库连接，而不需要修
改你的代码。 最后，你能自己配置JDBC连接:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec
  {:datasource
    (doto (new PGPoolingDataSource)
     (.setServerName   &quot;localhost&quot;)
     (.setDatabaseName &quot;my_website&quot;)
     (.setUser         &quot;admin&quot;)
     (.setPassword     &quot;admin&quot;)
     (.setMaxConnections 10))})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Creating tables&lt;/h2&gt;

&lt;p&gt;Korma依赖clojure.java.jdbc.这个库提供操作表的功能。&lt;/p&gt;

&lt;p&gt;你可以使用create-table函数来从应用中创建数据表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn create-users-table []
  (sql/db-do-commands db-spec
    (sql/create-table-ddl
      :users
      [:id &quot;varchar(32)&quot;]
      [:pass &quot;varchar(100)&quot;])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create-table-ddl函数需要包含在db-do-commands内，db-do-commands保证了数据库连接的关闭。&lt;/p&gt;

&lt;h1&gt;Accessing the Database&lt;/h1&gt;

&lt;p&gt;当使用Korma时，你需要先用defdb来包裹db-spec。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defdb db schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会使用c3p0来创建一个连接池。需要注意的是，最后创建的连接池会被设为默认的连接池。&lt;/p&gt;

&lt;p&gt;Korma使用entities来表示sql表。这个entities构成了你查询的核心。&lt;/p&gt;

&lt;p&gt;entities使用defentity宏来创建:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defentity users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来创建user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-user [user]
  (insert users
          (values user)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果我们想查询user，我们可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn get-user [id]
  (first (select users
                 (where {:id id})
                 (limit 1))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细文档可参考&lt;a href=&quot;http://sqlkorma.com/docs&quot;&gt;Korma官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Yesql&lt;/h1&gt;

&lt;p&gt;Korma提供了操作SQL的DSL，而Yesql可以直接操作SQL.&lt;/p&gt;

&lt;p&gt;如果要使用Yesql你需要添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[yesql &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在classpath下创建一个包含查询的SQL文件，比如resources/queries.sql.文件格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -- name: find-users
    -- Find the users with the given ID(s).
    SELECT *
    FROM user
    WHERE user_id IN (:id)
    AND age &amp;gt; :min_age

    -- name: user-count
    -- Counts all the users.
    SELECT count(*) AS count
    FROM user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建问上述文件后，你需要在需要的地方引入yesql.core/defqueries。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:require [yesql.core :refer [defqueries]]))

(defqueries &quot;resources/queries.sql&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个查询可以像函数一样通过名字来调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(find-users db-spec [1001 1003 1005] 18)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-安全</title>
        <link href="http://ivanpig.github.io/2013/09/25/security.html"/>
        <updated>2013-09-25T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/25/security</id>
        <content type="html">&lt;h1&gt;Security&lt;/h1&gt;

&lt;p&gt;密码的散列和对比由noir.util.crypt提供。&lt;/p&gt;

&lt;p&gt;他提供了两个函数$encrypt$,$compare$.其中第一个函数加密密码，而第二个则是对比密码。实际上加密是通过BCrypt来处理的。&lt;/p&gt;

&lt;p&gt;对比代码的函数看起来像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(compare raw encrypted)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加密函数可以自定义salt，或者就不使用salt加密。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(encrypt salt raw)
(encrypt raw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想了解Secutiry库的更多内容，&lt;a href=&quot;https://github.com/cemerick/friend&quot;&gt;请点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;LDAP Authentication&lt;/h1&gt;

&lt;p&gt;下面的列子演示了如何通过clj-ldap来验证sAMAccountName&lt;/p&gt;

&lt;p&gt;首先，我们先添加依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[org.clojars.pntblnk/clj-ldap &quot;0.0.9&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要引入authentication命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns ldap-auth
  (:require [clj-ldap.client :as client]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;我们可以像下面这样定义LDAP主机。注意host键指向一个Vector。这个Vector里可以包含多个LDAP服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def host
  {:host
    [{:address &quot;my-ldap-server.ca&quot;
      :port 389
      :connect-timeout (* 1000 5)
      :timeout (* 1000 30)}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们可以编写一个函数使用上面的LDAP来验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn authenticate [username password &amp;amp; [attributes]]
  (let [server (client/connect host)
        qualified-name (str username &quot;@&quot; (-&amp;gt; host :host first :address))]
    (if (client/bind? server qualified-name  password)
      (first (client/search server &quot;OU=MyOrgPeople,DC=myorg,DC=ca&quot;
                            {:filter (str &quot;sAMAccountName=&quot; username)
                             :attributes (or attributes [])})))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性Vector可以用来过滤返回值，如果所有的验证都通过，则返回空Vector&lt;/p&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击是第三方通过拦截已登录的用户来操作你的网站的一个攻击。此攻击一般通过你的网站的恶意链接，表单提交或js来进行攻击。&lt;/p&gt;

&lt;p&gt;Ring-Anti-Forgery使用来防止CSRF攻击的。只需要引入相关命名空间并将mk-defaults设为true即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def app (app-handler
           [home-routes base-routes]
           :middleware (load-middleware)
           ;; set this to true in order to enable CSRF protection
           :ring-defaults (mk-defaults true)
           :access-rules []
           :formats [:json-kw :edn :transit-json]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当CSRF中间件开启后，一个随机产生的字符串会被绑定到anti-forgery-token上。任何POST请求需要包含__anti-forgery-token。&lt;/p&gt;

&lt;p&gt;我们需要先引入anti-forgery。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(require ... [ring.util.anti-forgery :refer [anti-forgery-field]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，定义一个CSRF标签到我们的初始化函数中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn init
  ...
  (parser/add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在表单中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
      &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有包含此token的POST请求会被拦截。服务器响应403&quot;Invalid anti-forgery token&quot;。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Security&lt;/h1&gt;

&lt;p&gt;密码的散列和对比由noir.util.crypt提供。&lt;/p&gt;

&lt;p&gt;他提供了两个函数$encrypt$,$compare$.其中第一个函数加密密码，而第二个则是对比密码。实际上加密是通过BCrypt来处理的。&lt;/p&gt;

&lt;p&gt;对比代码的函数看起来像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(compare raw encrypted)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加密函数可以自定义salt，或者就不使用salt加密。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(encrypt salt raw)
(encrypt raw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想了解Secutiry库的更多内容，&lt;a href=&quot;https://github.com/cemerick/friend&quot;&gt;请点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;LDAP Authentication&lt;/h1&gt;

&lt;p&gt;下面的列子演示了如何通过clj-ldap来验证sAMAccountName&lt;/p&gt;

&lt;p&gt;首先，我们先添加依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[org.clojars.pntblnk/clj-ldap &quot;0.0.9&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要引入authentication命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns ldap-auth
  (:require [clj-ldap.client :as client]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;我们可以像下面这样定义LDAP主机。注意host键指向一个Vector。这个Vector里可以包含多个LDAP服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def host
  {:host
    [{:address &quot;my-ldap-server.ca&quot;
      :port 389
      :connect-timeout (* 1000 5)
      :timeout (* 1000 30)}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们可以编写一个函数使用上面的LDAP来验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn authenticate [username password &amp;amp; [attributes]]
  (let [server (client/connect host)
        qualified-name (str username &quot;@&quot; (-&amp;gt; host :host first :address))]
    (if (client/bind? server qualified-name  password)
      (first (client/search server &quot;OU=MyOrgPeople,DC=myorg,DC=ca&quot;
                            {:filter (str &quot;sAMAccountName=&quot; username)
                             :attributes (or attributes [])})))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性Vector可以用来过滤返回值，如果所有的验证都通过，则返回空Vector&lt;/p&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击是第三方通过拦截已登录的用户来操作你的网站的一个攻击。此攻击一般通过你的网站的恶意链接，表单提交或js来进行攻击。&lt;/p&gt;

&lt;p&gt;Ring-Anti-Forgery使用来防止CSRF攻击的。只需要引入相关命名空间并将mk-defaults设为true即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def app (app-handler
           [home-routes base-routes]
           :middleware (load-middleware)
           ;; set this to true in order to enable CSRF protection
           :ring-defaults (mk-defaults true)
           :access-rules []
           :formats [:json-kw :edn :transit-json]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当CSRF中间件开启后，一个随机产生的字符串会被绑定到anti-forgery-token上。任何POST请求需要包含__anti-forgery-token。&lt;/p&gt;

&lt;p&gt;我们需要先引入anti-forgery。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(require ... [ring.util.anti-forgery :refer [anti-forgery-field]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，定义一个CSRF标签到我们的初始化函数中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn init
  ...
  (parser/add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在表单中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
      &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有包含此token的POST请求会被拦截。服务器响应403&quot;Invalid anti-forgery token&quot;。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-输入验证</title>
        <link href="http://ivanpig.github.io/2013/09/24/input_validation.html"/>
        <updated>2013-09-24T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/24/input_validation</id>
        <content type="html">&lt;h1&gt;Input Validation&lt;/h1&gt;

&lt;p&gt;验证相关助手方法在noir.validation命名空间中。如果我们要使用验证，我们需要先引入这个命名空间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.routes
  (:require ... [noir.validation :as v]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证函数在当验证不通过时，将相应的错误设置到对应的字段上。验证函数接受一个条件函数和一个包含了需要验证的字段和错误信息的Vector.当验证函数验证通过时需要返回true否则返回false.&lt;/p&gt;

&lt;p&gt;下面是已经存在的验证函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;has-value? args: [v] - returns true if v is truthy and not an empty string.
has-values? args: [coll] - returns true if all members of the collection has-value? This works on maps as well.
not-nil? args: [v] - returns true if v is not nil
min-length? args: [v len] - returns true if v is greater than or equal to the given len
max-length? args: [v len - returns true if v is less than or equal to the given len
matches-regex? args: [v regex] - returns true if the string matches the given regular expression
is-email? args: [v] - returns true if v is an email address
valid-file? args: [m] - returns true if a valid file was supplied
valid-number? args: [v] - returns true if the string can be parsed to a Long
greater-than? args: [v n] - returns true if the string represents a number &amp;gt; given
less-than? args: [v n] - returns true if the string represents a number &amp;lt; given
equal-to? args: [v n] - returns true if the string represents a number = given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：如果我们想检查id和pass字段不能为空，则可以创建如下验证规则：&lt;/p&gt;

&lt;p&gt;````clojure
(v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])&lt;/p&gt;

&lt;p&gt;(v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])
```&lt;/p&gt;

&lt;p&gt;错误信息被保存在noir.validation/&lt;em&gt;errors&lt;/em&gt;这个atom中，这个atom被绑定到了request上。每个error都包含一个key和一个对应的错误Vector.验证函数可以在同一字段上多次调用来设置多个错误。&lt;/p&gt;

&lt;p&gt;一旦验证规则被执行了，我们可以通过errors?这个函数来检查是否有错误。如果没有传递参数，则此函数会检查noir.validation/&lt;em&gt;error&lt;/em&gt;是否为空，如果传递了参数，次函数根据传递的值来查询是否有错误。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns true if any errors have been set
(v/errors?)
;; returns true if any errors have been set for the key :id
(v/errors? :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，我们可以通过调用get-errors函数来获取当前的错误。当不传递参数时，返回所有的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns a sequence of all errors that have been set
(v/get-errors)
;; returns all the errors set for the key :id
(v/get-errors :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以通过on-error来提供自定义的错误处理函数。这个函数需要一个字段相关联的error集合作为参数。函数结果由on-error返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/on-error :id (fn [errors] (clojure.string/join &quot;, &quot; errors)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，错误可以通过clear-errors!函数来清除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/clear-errors!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个完整的登录相关验证。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn set-errors [id pass]
  (v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])

  (v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])

  (if (v/errors? :id :pass)
    {:body {:status &quot;error&quot; :errors (get-errors)}}
    (do
    (session/put! :user id)
     {:body {:status &quot;ok&quot;}})))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Input Validation&lt;/h1&gt;

&lt;p&gt;验证相关助手方法在noir.validation命名空间中。如果我们要使用验证，我们需要先引入这个命名空间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.routes
  (:require ... [noir.validation :as v]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证函数在当验证不通过时，将相应的错误设置到对应的字段上。验证函数接受一个条件函数和一个包含了需要验证的字段和错误信息的Vector.当验证函数验证通过时需要返回true否则返回false.&lt;/p&gt;

&lt;p&gt;下面是已经存在的验证函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;has-value? args: [v] - returns true if v is truthy and not an empty string.
has-values? args: [coll] - returns true if all members of the collection has-value? This works on maps as well.
not-nil? args: [v] - returns true if v is not nil
min-length? args: [v len] - returns true if v is greater than or equal to the given len
max-length? args: [v len - returns true if v is less than or equal to the given len
matches-regex? args: [v regex] - returns true if the string matches the given regular expression
is-email? args: [v] - returns true if v is an email address
valid-file? args: [m] - returns true if a valid file was supplied
valid-number? args: [v] - returns true if the string can be parsed to a Long
greater-than? args: [v n] - returns true if the string represents a number &amp;gt; given
less-than? args: [v n] - returns true if the string represents a number &amp;lt; given
equal-to? args: [v n] - returns true if the string represents a number = given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：如果我们想检查id和pass字段不能为空，则可以创建如下验证规则：&lt;/p&gt;

&lt;p&gt;````clojure
(v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])&lt;/p&gt;

&lt;p&gt;(v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])
```&lt;/p&gt;

&lt;p&gt;错误信息被保存在noir.validation/&lt;em&gt;errors&lt;/em&gt;这个atom中，这个atom被绑定到了request上。每个error都包含一个key和一个对应的错误Vector.验证函数可以在同一字段上多次调用来设置多个错误。&lt;/p&gt;

&lt;p&gt;一旦验证规则被执行了，我们可以通过errors?这个函数来检查是否有错误。如果没有传递参数，则此函数会检查noir.validation/&lt;em&gt;error&lt;/em&gt;是否为空，如果传递了参数，次函数根据传递的值来查询是否有错误。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns true if any errors have been set
(v/errors?)
;; returns true if any errors have been set for the key :id
(v/errors? :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，我们可以通过调用get-errors函数来获取当前的错误。当不传递参数时，返回所有的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns a sequence of all errors that have been set
(v/get-errors)
;; returns all the errors set for the key :id
(v/get-errors :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以通过on-error来提供自定义的错误处理函数。这个函数需要一个字段相关联的error集合作为参数。函数结果由on-error返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/on-error :id (fn [errors] (clojure.string/join &quot;, &quot; errors)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，错误可以通过clear-errors!函数来清除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/clear-errors!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个完整的登录相关验证。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn set-errors [id pass]
  (v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])

  (v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])

  (if (v/errors? :id :pass)
    {:body {:status &quot;error&quot; :errors (get-errors)}}
    (do
    (session/put! :user id)
     {:body {:status &quot;ok&quot;}})))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-Session与Cookie</title>
        <link href="http://ivanpig.github.io/2013/09/23/sessions_cookies.html"/>
        <updated>2013-09-23T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/23/sessions_cookies</id>
        <content type="html">&lt;h1&gt;Sessions&lt;/h1&gt;

&lt;p&gt;Session管理相关功能由noir.session提供。默认提供的noir.util.middleware/app-handler函数默认将Session保存在内存里。&lt;/p&gt;

&lt;p&gt;当然你可以修改它，只需要给函数传递第二个参数，告诉它将Session保存在哪里就可
以了。 下面的例子创建了一个保存在内存里的session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler [home-routes app-routes]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面，我们来重新定义session的保存位置。使用:session-options来替换掉默认的值就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app
  (middleware/app-handler
    [home-routes app-routes]
    :session-options {:cookie-name &quot;example-app-session&quot;
                      :store (cookie-store)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Accessing the session&lt;/h1&gt;

&lt;p&gt;你可以在任意范围内的任何函数里访问并操作session。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.session :as session])

(defn set-user [id]
  (session/put! :user id)
  (session/get :user))

(defn remove-user []
  (session/remove! :user)
  (session/get :user))

(defn set-user-if-nil [id]
  (session/get :user id))

(defn clear-session []
  (session/clear!))

(defroutes app-routes
  (GET &quot;/login/:id&quot; [id] (set-user id))
  (GET &quot;/remove&quot; [] (remove-user))
  (GET &quot;/set-if-nil/:id&quot; [id] (set-user-if-nil id))
  (GET &quot;/logout&quot; [] (clear-session)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以通过noir.session/flash-put!和noir.session/flash-get来创建flash变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(session/flash-put! :message &quot;User added!&quot;)
(session/flash-get :message)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Cookies&lt;/h1&gt;

&lt;p&gt;Cookie处理函数由noir.cookies提供。设置或获取Cookie和Session很类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.cookies :as cookies])

(defn set-user-cookie [id]
  (cookies/put! :user id)
  (cookies/get :user))

(defn set-user-if-nil [id]
  (cookies/get :user id))

(cookies/put! :track
              {:value (str (java.util.UUID/randomUUID))
              :path &quot;/&quot;
              :expires 1})
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Sessions&lt;/h1&gt;

&lt;p&gt;Session管理相关功能由noir.session提供。默认提供的noir.util.middleware/app-handler函数默认将Session保存在内存里。&lt;/p&gt;

&lt;p&gt;当然你可以修改它，只需要给函数传递第二个参数，告诉它将Session保存在哪里就可
以了。 下面的例子创建了一个保存在内存里的session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler [home-routes app-routes]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面，我们来重新定义session的保存位置。使用:session-options来替换掉默认的值就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app
  (middleware/app-handler
    [home-routes app-routes]
    :session-options {:cookie-name &quot;example-app-session&quot;
                      :store (cookie-store)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Accessing the session&lt;/h1&gt;

&lt;p&gt;你可以在任意范围内的任何函数里访问并操作session。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.session :as session])

(defn set-user [id]
  (session/put! :user id)
  (session/get :user))

(defn remove-user []
  (session/remove! :user)
  (session/get :user))

(defn set-user-if-nil [id]
  (session/get :user id))

(defn clear-session []
  (session/clear!))

(defroutes app-routes
  (GET &quot;/login/:id&quot; [id] (set-user id))
  (GET &quot;/remove&quot; [] (remove-user))
  (GET &quot;/set-if-nil/:id&quot; [id] (set-user-if-nil id))
  (GET &quot;/logout&quot; [] (clear-session)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以通过noir.session/flash-put!和noir.session/flash-get来创建flash变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(session/flash-put! :message &quot;User added!&quot;)
(session/flash-get :message)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Cookies&lt;/h1&gt;

&lt;p&gt;Cookie处理函数由noir.cookies提供。设置或获取Cookie和Session很类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.cookies :as cookies])

(defn set-user-cookie [id]
  (cookies/put! :user id)
  (cookies/get :user))

(defn set-user-if-nil [id]
  (cookies/get :user id))

(cookies/put! :track
              {:value (str (java.util.UUID/randomUUID))
              :path &quot;/&quot;
              :expires 1})
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-自定义中间件</title>
        <link href="http://ivanpig.github.io/2013/09/22/custom_middleware.html"/>
        <updated>2013-09-22T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/22/custom_middleware</id>
        <content type="html">&lt;h1&gt;Adding custom middleware&lt;/h1&gt;

&lt;p&gt;Luminus使用Ring来路由应用的处理程序，你也可以添加一些中间件。&lt;/p&gt;

&lt;p&gt;中间件可以给处理程序添加一些额外的功能。中间件函数主要被用来扩展Ring的基本处理函数。&lt;/p&gt;

&lt;p&gt;中间件其实就是个简单的函数，它接受现有的处理程序和一些可选参数作为函数参数并返回一个新的处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn wrap-nocache [handler]
  (fn [request]
     (let [response (handler request)]
        (assoc-in response [:headers  &quot;Pragma&quot;] &quot;no-cache&quot;))))

(def app (wrap-nocache handler))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上面的函数接受一个处理函数并返回一个新的函数，这个函数接受request作为参数。返回的函数只在handler所在的范围内有效。当调用这个函数时，它将会给响应map添加Pragma:no-cache键值对。&lt;/p&gt;

&lt;p&gt;你可以添加自定义的中间件，只需要使用:middleware关键字就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          ;;put any custom middleware
          ;;in the middleware vector
          :middleware [wrap-nocache]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体内容可参见Ring官方文档。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Useful ring middleware&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ring-middleware-format - Ring middleware for handling different fromats such as JSON and EDN&lt;/li&gt;
&lt;li&gt;ring-ratelimit - Rate limiting middleware&lt;/li&gt;
&lt;li&gt;ring-etag-middleware - Calculates etags for ring responses and returns 304 responses when appropriate&lt;/li&gt;
&lt;li&gt;ring-gzip-middleware - Gzips ring responses for user agents which can handle it&lt;/li&gt;
&lt;li&gt;ring-upload-progress - Provide upload progress data in ring session&lt;/li&gt;
&lt;li&gt;ring-anti-forgery - Ring middleware to prevent CSRF attacks&lt;/li&gt;
&lt;/ul&gt;

</content>
        <summary type="html">&lt;h1&gt;Adding custom middleware&lt;/h1&gt;

&lt;p&gt;Luminus使用Ring来路由应用的处理程序，你也可以添加一些中间件。&lt;/p&gt;

&lt;p&gt;中间件可以给处理程序添加一些额外的功能。中间件函数主要被用来扩展Ring的基本处理函数。&lt;/p&gt;

&lt;p&gt;中间件其实就是个简单的函数，它接受现有的处理程序和一些可选参数作为函数参数并返回一个新的处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn wrap-nocache [handler]
  (fn [request]
     (let [response (handler request)]
        (assoc-in response [:headers  &quot;Pragma&quot;] &quot;no-cache&quot;))))

(def app (wrap-nocache handler))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上面的函数接受一个处理函数并返回一个新的函数，这个函数接受request作为参数。返回的函数只在handler所在的范围内有效。当调用这个函数时，它将会给响应map添加Pragma:no-cache键值对。&lt;/p&gt;

&lt;p&gt;你可以添加自定义的中间件，只需要使用:middleware关键字就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          ;;put any custom middleware
          ;;in the middleware vector
          :middleware [wrap-nocache]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体内容可参见Ring官方文档。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Useful ring middleware&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ring-middleware-format - Ring middleware for handling different fromats such as JSON and EDN&lt;/li&gt;
&lt;li&gt;ring-ratelimit - Rate limiting middleware&lt;/li&gt;
&lt;li&gt;ring-etag-middleware - Calculates etags for ring responses and returns 304 responses when appropriate&lt;/li&gt;
&lt;li&gt;ring-gzip-middleware - Gzips ring responses for user agents which can handle it&lt;/li&gt;
&lt;li&gt;ring-upload-progress - Provide upload progress data in ring session&lt;/li&gt;
&lt;li&gt;ring-anti-forgery - Ring middleware to prevent CSRF attacks&lt;/li&gt;
&lt;/ul&gt;

</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-响应</title>
        <link href="http://ivanpig.github.io/2013/09/21/response_types.html"/>
        <updated>2013-09-21T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/21/response_types</id>
        <content type="html">&lt;h1&gt;Responses&lt;/h1&gt;

&lt;p&gt;noir.response提供了很多辅助函数来处理响应.&lt;/p&gt;

&lt;h1&gt;Setting headers&lt;/h1&gt;

&lt;p&gt;可以使用set-header来设置响应头，使用一个map作为参数。这里需要注意的是,map的key必须是字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set-headers {&quot;x-csrf&quot; csrf}
    (common/layout [:p &quot;hi there&quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Setting content type&lt;/h1&gt;

&lt;p&gt;你可以使用content-type函数来设置响应的类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/project&quot; []
       (noir.response/content-type
       &quot;application/pdf&quot;
       (clojure.java.io/input-stream &quot;report.pdf&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是有效的响应类型设置:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XML - Wraps the response with the content type for xml and sets the body to the content.&lt;/li&gt;
&lt;li&gt;JSON- Wraps the response in the json content type and generates JSON from the content&lt;/li&gt;
&lt;li&gt;JSONP - Generates JSON for the given content and creates a javascript response for calling func-name with it.&lt;/li&gt;
&lt;li&gt;edn - Wraps the response in the application/edn content-type and calls pr-str on the Clojure data stuctures passed in.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/xml&quot; [] (xml &quot;&amp;lt;foo&amp;gt;&amp;lt;/foo&amp;gt;&quot;))
(GET &quot;/json&quot; [] (json {:response &quot;ok&quot;}))
(GET &quot;/jsonp&quot; [] (jsonp  &quot;showUsers&quot; [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]))
(GET &quot;/edn&quot; [] (edn {:foo 1 :bar 2}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了设置响应类型，你还需要设置noir.util.middleware/app-handler中间件。和上一节的请求一样，你只需要配置:formats键就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(app-handler routes :formats [:json])
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;可用的格式化类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:json - JSON with string keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:json-kw - JSON with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:edn - native Clojure format.&lt;/li&gt;
&lt;li&gt;:yaml - YAML format&lt;/li&gt;
&lt;li&gt;:yaml-kw - YAML format with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:yaml-in-html - yaml in a html page&lt;/li&gt;
&lt;li&gt;Setting custom status&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以使用status函数来设置一个自定义的状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/missing-page&quot; [] (status 404 &quot;your page could not be found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Redirects&lt;/h1&gt;

&lt;p&gt;noir.response/redirect可以进行重定向。他可以向重定向函数传递参数。他支持如下类型:
-   :permanent
-   :found
-   :see-other
-   :not-modified
-   :proxy
-   :temporary&lt;/p&gt;

&lt;p&gt;如果不传递参数的话，那么默认为:found&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require 'noir.response)

(redirect &quot;/foo&quot;)
(redirect &quot;/bar&quot; :see-other)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Responses&lt;/h1&gt;

&lt;p&gt;noir.response提供了很多辅助函数来处理响应.&lt;/p&gt;

&lt;h1&gt;Setting headers&lt;/h1&gt;

&lt;p&gt;可以使用set-header来设置响应头，使用一个map作为参数。这里需要注意的是,map的key必须是字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set-headers {&quot;x-csrf&quot; csrf}
    (common/layout [:p &quot;hi there&quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Setting content type&lt;/h1&gt;

&lt;p&gt;你可以使用content-type函数来设置响应的类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/project&quot; []
       (noir.response/content-type
       &quot;application/pdf&quot;
       (clojure.java.io/input-stream &quot;report.pdf&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是有效的响应类型设置:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XML - Wraps the response with the content type for xml and sets the body to the content.&lt;/li&gt;
&lt;li&gt;JSON- Wraps the response in the json content type and generates JSON from the content&lt;/li&gt;
&lt;li&gt;JSONP - Generates JSON for the given content and creates a javascript response for calling func-name with it.&lt;/li&gt;
&lt;li&gt;edn - Wraps the response in the application/edn content-type and calls pr-str on the Clojure data stuctures passed in.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/xml&quot; [] (xml &quot;&amp;lt;foo&amp;gt;&amp;lt;/foo&amp;gt;&quot;))
(GET &quot;/json&quot; [] (json {:response &quot;ok&quot;}))
(GET &quot;/jsonp&quot; [] (jsonp  &quot;showUsers&quot; [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]))
(GET &quot;/edn&quot; [] (edn {:foo 1 :bar 2}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了设置响应类型，你还需要设置noir.util.middleware/app-handler中间件。和上一节的请求一样，你只需要配置:formats键就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(app-handler routes :formats [:json])
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;可用的格式化类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:json - JSON with string keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:json-kw - JSON with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:edn - native Clojure format.&lt;/li&gt;
&lt;li&gt;:yaml - YAML format&lt;/li&gt;
&lt;li&gt;:yaml-kw - YAML format with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:yaml-in-html - yaml in a html page&lt;/li&gt;
&lt;li&gt;Setting custom status&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以使用status函数来设置一个自定义的状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/missing-page&quot; [] (status 404 &quot;your page could not be found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Redirects&lt;/h1&gt;

&lt;p&gt;noir.response/redirect可以进行重定向。他可以向重定向函数传递参数。他支持如下类型:
-   :permanent
-   :found
-   :see-other
-   :not-modified
-   :proxy
-   :temporary&lt;/p&gt;

&lt;p&gt;如果不传递参数的话，那么默认为:found&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require 'noir.response)

(redirect &quot;/foo&quot;)
(redirect &quot;/bar&quot; :see-other)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-请求</title>
        <link href="http://ivanpig.github.io/2013/09/20/request_types.html"/>
        <updated>2013-09-20T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/20/request_types</id>
        <content type="html">&lt;h1&gt;Requests&lt;/h1&gt;

&lt;p&gt;默认情况下，请求的参数(比如一个form的POST请求)将会被自动绑定到request的:params键上。&lt;/p&gt;

&lt;p&gt;但是，如果你在请求体内传递一些特殊类型的参数，则你需要使用适合的中间件来处理他们。Luminus使用ring-middleware-format来处理这些参数。&lt;/p&gt;

&lt;p&gt;中间件可以通过在noir.util.middleware/app-handler上添加:formats键来开启:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          :formats [:json :edn]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样请求中的application/json和application/edn类型将会被中间件处理。相应的请求参数会在:params中。注意，这也会处理响应中的对应类型参数。具体信息请见Response Types章节。&lt;/p&gt;

&lt;p&gt;下面是有效的格式化类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:json - JSON with string keys in :params and :body-params
:json-kw - JSON with keywodized keys in :params and :body-params
:edn - native Clojure format.
:yaml - YAML format
:yaml-kw - YAML format with keywodized keys in :params and :body-params
:yaml-in-html - yaml in a html page
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Requests&lt;/h1&gt;

&lt;p&gt;默认情况下，请求的参数(比如一个form的POST请求)将会被自动绑定到request的:params键上。&lt;/p&gt;

&lt;p&gt;但是，如果你在请求体内传递一些特殊类型的参数，则你需要使用适合的中间件来处理他们。Luminus使用ring-middleware-format来处理这些参数。&lt;/p&gt;

&lt;p&gt;中间件可以通过在noir.util.middleware/app-handler上添加:formats键来开启:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          :formats [:json :edn]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样请求中的application/json和application/edn类型将会被中间件处理。相应的请求参数会在:params中。注意，这也会处理响应中的对应类型参数。具体信息请见Response Types章节。&lt;/p&gt;

&lt;p&gt;下面是有效的格式化类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:json - JSON with string keys in :params and :body-params
:json-kw - JSON with keywodized keys in :params and :body-params
:edn - native Clojure format.
:yaml - YAML format
:yaml-kw - YAML format with keywodized keys in :params and :body-params
:yaml-in-html - yaml in a html page
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-静态资源</title>
        <link href="http://ivanpig.github.io/2013/09/19/staticresource.html"/>
        <updated>2013-09-19T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/19/staticresource</id>
        <content type="html">&lt;h1&gt;Static resources&lt;/h1&gt;

&lt;p&gt;在noir.io下有多个访问静态资源的帮助方法。
你可以通过调用resource-path来获取public目录的路径。&lt;/p&gt;

&lt;h1&gt;Handling file uploads&lt;/h1&gt;

&lt;p&gt;上传文件通过noir.io空间下的upload-file方法来实现，upload-file接受一个路径和文件的map。
例如我们有一个upload.html文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;h2&amp;gt;Upload a file&amp;lt;/h2&amp;gt;
    &amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&amp;gt;
        &amp;lt;input id=&quot;file&quot; name=&quot;file&quot; type=&quot;file&quot; /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来处理文件上传。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.upload
  ...
  (:require [upload-test.views.layout :as layout]
            [noir.response :as response]
            [noir.io :as io]))

(defn upload-page []
  (layout/render &quot;upload.html&quot;))

(defn handle-upload [file]
  (io/upload-file &quot;/&quot; file)
  (response/redirect
    (str &quot;/&quot; (:filename file))))

(defroutes upload-routes
  (GET &quot;/upload&quot; [] (upload-page))
  (POST &quot;/upload&quot; [file] (handle-upload file)))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Serving static resources&lt;/h1&gt;

&lt;p&gt;你可以使用get-resource通过相对路径来加载public目录中的资源，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将返回在包含public/md/outline.md下资源的clojure.java.io/resource。
最后，我们可以使用slurp-resource来读取文件的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(slurp-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Static resources&lt;/h1&gt;

&lt;p&gt;在noir.io下有多个访问静态资源的帮助方法。
你可以通过调用resource-path来获取public目录的路径。&lt;/p&gt;

&lt;h1&gt;Handling file uploads&lt;/h1&gt;

&lt;p&gt;上传文件通过noir.io空间下的upload-file方法来实现，upload-file接受一个路径和文件的map。
例如我们有一个upload.html文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;h2&amp;gt;Upload a file&amp;lt;/h2&amp;gt;
    &amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&amp;gt;
        &amp;lt;input id=&quot;file&quot; name=&quot;file&quot; type=&quot;file&quot; /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来处理文件上传。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.upload
  ...
  (:require [upload-test.views.layout :as layout]
            [noir.response :as response]
            [noir.io :as io]))

(defn upload-page []
  (layout/render &quot;upload.html&quot;))

(defn handle-upload [file]
  (io/upload-file &quot;/&quot; file)
  (response/redirect
    (str &quot;/&quot; (:filename file))))

(defroutes upload-routes
  (GET &quot;/upload&quot; [] (upload-page))
  (POST &quot;/upload&quot; [file] (handle-upload file)))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Serving static resources&lt;/h1&gt;

&lt;p&gt;你可以使用get-resource通过相对路径来加载public目录中的资源，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将返回在包含public/md/outline.md下资源的clojure.java.io/resource。
最后，我们可以使用slurp-resource来读取文件的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(slurp-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-路由定义</title>
        <link href="http://ivanpig.github.io/2013/09/18/defining_routes.html"/>
        <updated>2013-09-18T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/18/defining_routes</id>
        <content type="html">&lt;h1&gt;Defining routes&lt;/h1&gt;

&lt;p&gt;Luminus使用Compojure来定义应用的路由.路由由HTTP请求方法和接受它的URI，
参数和以及相应的处理程序组成。Compojure定义了所有标准HTTP请求的路由，
比如ANY,DELETE,GET,HEAD,OPTIONS,PATCH,POST和PUT。&lt;/p&gt;

&lt;p&gt;例如：如果我们想定义一个应用，它指向/，/返回&quot;Hello World!&quot;字符串。我们
可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes app-routes
  (GET &quot;/&quot; [] &quot;Hello World!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想构建一个路由来响应POST请求，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/hello&quot; [id] (str &quot;Welcome &quot; id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些路由需要访问请求的map，我们只需要在路由上定义第二个参数就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/foo&quot; request (interpose &quot;, &quot; (keys request)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的路由读出请求map中所有的key并展示出来。结果如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;:ssl-client-cert, :remote-addr, :scheme, :query-params, :session, :form-params,
:multipart-params, :request-method, :query-string, :route-params, :content-type,
:cookies, :uri, :server-name, :params, :headers, :content-length, :server-port,
:character-encoding, :body, :flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compojure还提供了一些有用的函数来处理请求map和表单参数。例如，在
guestbook应用的例子中，我们看到了如下的路由定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/&quot;  [name message] (save-message name message))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这个路由从参数中获取到name和message的值，并将其绑定到相同名字的变量上。
我们能像使用其他定义的变量那样来使用他们。我们也可以直接在路由中使用Clojure的解构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/:foo&quot; { {foo &quot;foo&quot;} :params}
  (str &quot;Foo = &quot; foo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，Compojure还提供了解构部分参数，并将其他参数构建为一个map的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[x y &amp;amp; z]
x -&amp;gt; &quot;foo&quot;
y -&amp;gt; &quot;bar&quot;
z -&amp;gt; {:v &quot;baz&quot;, :w &quot;qux&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中,参数x和y被绑定到了变量上，而v和w还在叫z的map中。
最后，如果我们需要获取完整的请求，我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/&quot; [x y :as r] (str x y r))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们将表单参数绑定到了x和y上，而完整的请求则绑定到了变量r上。&lt;/p&gt;

&lt;h1&gt;Organizing application routes&lt;/h1&gt;

&lt;p&gt;对路由管理的最佳实践就是对其统一管理。Compojure提供了defroutes宏来方便
我们作这样的处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes auth-routes
  (POST &quot;/login&quot; [id pass] (login id pass))
  (POST &quot;/logout&quot; [] (logout)))

(defroutes app-routes
  (GET &quot;/&quot; [] (home))
  (route/resources &quot;/&quot;)
  (route/not-found &quot;Not Found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于路径相似的路由，可以使用context来简化管理。
例如，你的路径都以/user/:id为根路径:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes user-routes
      (GET &quot;/user/:id/profile&quot; [id] ...)
      (GET &quot;/user/:id/settings&quot; [id] ...)
      (GET &quot;/user/:id/change-password&quot; [id] ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以这样简写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def user-routes
      (context &quot;/user/:id&quot; [id]
        (GET &quot;/profile&quot; [] ...)
        (GET &quot;/settings&quot; [] ...)
        (GET &quot;/change-password&quot; [] ...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你定义好了所有的路由，你可以将他们添加到
noir.util.middleware/app-handler下的vector中，它在handler目录下。
你应该注意到了，生成的项目中已经定义了一个叫app的变量，你只需要添加新的路由就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware []
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的文档请键Compojure官方wiki.&lt;/p&gt;

&lt;h1&gt;Restricting access&lt;/h1&gt;

&lt;p&gt;有些页面只能在特定条件下才可以访问。
例如，你可能想定义一个只能给管理员查看的页面或者一个用户管理页面，只给
当前用户看。
使用lib-noir中的noir.util.route可以达到这个目的，我们可以定义访问特殊
页面的逻辑&lt;/p&gt;

&lt;h1&gt;Marking Routes as Restricted&lt;/h1&gt;

&lt;p&gt;noir.util.route/restricted宏被用来定义访问路由的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/private/:id&quot; [id] (restricted &quot;private!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想定义多个路由的访问权限，可以使用def-restricted-routes宏.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def-restricted-routes private-pages
  (GET &quot;/profile&quot; [] (show-profile))
  (GET &quot;/my-secret-page&quot; [] (show-secret-page))
  (GET &quot;/another-secret-page&quot; [] (another-secret-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes private-pages
  (GET &quot;/profile&quot; [] (restricted (show-profile)))
  (GET &quot;/secret-page1&quot; [] (restricted (show-secret-page)))
  (GET &quot;/secret-page2&quot; [] (restricted (another-secret-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，受限访问的路由会检查请求是否符合所有的条件。&lt;/p&gt;

&lt;h1&gt;Specifying Access Rules&lt;/h1&gt;

&lt;p&gt;我们来看看如何创建一个路由，它只有在session中存在:user所对应的值时，
才能访问。 首先，我们需要引用noir.util.route和noir.session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require ...
            [noir.util.route :refer [restricted]]
            [noir.session :as session]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将编写函数来实现上面我们所说的访问规则。函数必须接受request
作为其参数并且返回true或者false来确认页面是否可以访问。
下面就是该函数的实现，它检查当前session中是否存在user。如果没有则重定
向。默认重定向到根路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn user-access [request]
  (session/get :user))

(def app
 (middleware/app-handler
   [app-routes]
   :access-rules [user-access]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，所有的受限的处理程序在session中不存在:user时都会重定向到根目录。&lt;/p&gt;

&lt;h1&gt;Access Rule Groups&lt;/h1&gt;

&lt;p&gt;当你以map的方式来提供访问规则，则可以进行进一步的处理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:uri - 符合访问规则的URI&lt;/li&gt;
&lt;li&gt;:uris - 和:uri类似，匹配多个URI&lt;/li&gt;
&lt;li&gt;:redirect - 重定向地址&lt;/li&gt;
&lt;li&gt;:on-fail - 重定向可选项，可以指定一个请求错误时的处理函数，函数必须
以request为参数&lt;/li&gt;
&lt;li&gt;:rule - 一个规则&lt;/li&gt;
&lt;li&gt;:rules - 多个规则&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:rules可以用在下面集中情形下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:rules [rule1 rule2]
:rules {:any [rule1 rule2]}
:rules {:every [rule1 rule2] :any [rule3 rule4]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，每个规则都必须通过才能访问成功，:any则表示只要符合任何一个
规则即可访问。下面是一些例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn admin-access [req]
 (session/get :admin))

:access-rules [{:redirect &quot;/access-denied&quot;
                :rule user-access}]

:access-rules [{:uris [&quot;/user/*&quot; &quot;/private*&quot;]
                :rule user-access}]

:access-rules [{:uri &quot;/admin/*&quot; :rule admin-access}
               {:uri &quot;/user/*&quot;
                :rules {:any [user-access admin-access]}}]

:access-rules [{:on-fail (fn [req] &quot;access restricted&quot;)
                :rule user-access}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击指的是第三方通过一个验证过的用户来提交动作。当你的网站包含了一
个恶意链接或按钮或js的时候，很容易发生。
我们可以使用Ring-Anti-Forgery来放置csrf攻击. 首先添加[ring-anti-forgery
&quot;0.2.1&quot;]依赖。接着引入相应的包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require
    ...
    [selmer.parser :refer [add-tag!]]
    [ring.util.anti-forgery :refer [anti-forgery-field]]
    [ring.middleware.anti-forgery :refer [wrap-anti-forgery]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将添加wrap-anti-forgery中间件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware [wrap-anti-forgery]
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完后一个随机字符串将会被赋给anti-forgery-token变量。所有的POST请求
将会包含一个叫_~anti~-forgery-token的token.
接着我们在init函数中添加csrf标签:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  ...
  (add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的POST请求如果不包含这个token，则会被拒绝。服务器返回403错误。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Defining routes&lt;/h1&gt;

&lt;p&gt;Luminus使用Compojure来定义应用的路由.路由由HTTP请求方法和接受它的URI，
参数和以及相应的处理程序组成。Compojure定义了所有标准HTTP请求的路由，
比如ANY,DELETE,GET,HEAD,OPTIONS,PATCH,POST和PUT。&lt;/p&gt;

&lt;p&gt;例如：如果我们想定义一个应用，它指向/，/返回&quot;Hello World!&quot;字符串。我们
可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes app-routes
  (GET &quot;/&quot; [] &quot;Hello World!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想构建一个路由来响应POST请求，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/hello&quot; [id] (str &quot;Welcome &quot; id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些路由需要访问请求的map，我们只需要在路由上定义第二个参数就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/foo&quot; request (interpose &quot;, &quot; (keys request)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的路由读出请求map中所有的key并展示出来。结果如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;:ssl-client-cert, :remote-addr, :scheme, :query-params, :session, :form-params,
:multipart-params, :request-method, :query-string, :route-params, :content-type,
:cookies, :uri, :server-name, :params, :headers, :content-length, :server-port,
:character-encoding, :body, :flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compojure还提供了一些有用的函数来处理请求map和表单参数。例如，在
guestbook应用的例子中，我们看到了如下的路由定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/&quot;  [name message] (save-message name message))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这个路由从参数中获取到name和message的值，并将其绑定到相同名字的变量上。
我们能像使用其他定义的变量那样来使用他们。我们也可以直接在路由中使用Clojure的解构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/:foo&quot; { {foo &quot;foo&quot;} :params}
  (str &quot;Foo = &quot; foo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，Compojure还提供了解构部分参数，并将其他参数构建为一个map的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[x y &amp;amp; z]
x -&amp;gt; &quot;foo&quot;
y -&amp;gt; &quot;bar&quot;
z -&amp;gt; {:v &quot;baz&quot;, :w &quot;qux&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中,参数x和y被绑定到了变量上，而v和w还在叫z的map中。
最后，如果我们需要获取完整的请求，我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/&quot; [x y :as r] (str x y r))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们将表单参数绑定到了x和y上，而完整的请求则绑定到了变量r上。&lt;/p&gt;

&lt;h1&gt;Organizing application routes&lt;/h1&gt;

&lt;p&gt;对路由管理的最佳实践就是对其统一管理。Compojure提供了defroutes宏来方便
我们作这样的处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes auth-routes
  (POST &quot;/login&quot; [id pass] (login id pass))
  (POST &quot;/logout&quot; [] (logout)))

(defroutes app-routes
  (GET &quot;/&quot; [] (home))
  (route/resources &quot;/&quot;)
  (route/not-found &quot;Not Found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于路径相似的路由，可以使用context来简化管理。
例如，你的路径都以/user/:id为根路径:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes user-routes
      (GET &quot;/user/:id/profile&quot; [id] ...)
      (GET &quot;/user/:id/settings&quot; [id] ...)
      (GET &quot;/user/:id/change-password&quot; [id] ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以这样简写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def user-routes
      (context &quot;/user/:id&quot; [id]
        (GET &quot;/profile&quot; [] ...)
        (GET &quot;/settings&quot; [] ...)
        (GET &quot;/change-password&quot; [] ...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你定义好了所有的路由，你可以将他们添加到
noir.util.middleware/app-handler下的vector中，它在handler目录下。
你应该注意到了，生成的项目中已经定义了一个叫app的变量，你只需要添加新的路由就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware []
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的文档请键Compojure官方wiki.&lt;/p&gt;

&lt;h1&gt;Restricting access&lt;/h1&gt;

&lt;p&gt;有些页面只能在特定条件下才可以访问。
例如，你可能想定义一个只能给管理员查看的页面或者一个用户管理页面，只给
当前用户看。
使用lib-noir中的noir.util.route可以达到这个目的，我们可以定义访问特殊
页面的逻辑&lt;/p&gt;

&lt;h1&gt;Marking Routes as Restricted&lt;/h1&gt;

&lt;p&gt;noir.util.route/restricted宏被用来定义访问路由的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/private/:id&quot; [id] (restricted &quot;private!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想定义多个路由的访问权限，可以使用def-restricted-routes宏.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def-restricted-routes private-pages
  (GET &quot;/profile&quot; [] (show-profile))
  (GET &quot;/my-secret-page&quot; [] (show-secret-page))
  (GET &quot;/another-secret-page&quot; [] (another-secret-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes private-pages
  (GET &quot;/profile&quot; [] (restricted (show-profile)))
  (GET &quot;/secret-page1&quot; [] (restricted (show-secret-page)))
  (GET &quot;/secret-page2&quot; [] (restricted (another-secret-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，受限访问的路由会检查请求是否符合所有的条件。&lt;/p&gt;

&lt;h1&gt;Specifying Access Rules&lt;/h1&gt;

&lt;p&gt;我们来看看如何创建一个路由，它只有在session中存在:user所对应的值时，
才能访问。 首先，我们需要引用noir.util.route和noir.session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require ...
            [noir.util.route :refer [restricted]]
            [noir.session :as session]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将编写函数来实现上面我们所说的访问规则。函数必须接受request
作为其参数并且返回true或者false来确认页面是否可以访问。
下面就是该函数的实现，它检查当前session中是否存在user。如果没有则重定
向。默认重定向到根路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn user-access [request]
  (session/get :user))

(def app
 (middleware/app-handler
   [app-routes]
   :access-rules [user-access]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，所有的受限的处理程序在session中不存在:user时都会重定向到根目录。&lt;/p&gt;

&lt;h1&gt;Access Rule Groups&lt;/h1&gt;

&lt;p&gt;当你以map的方式来提供访问规则，则可以进行进一步的处理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:uri - 符合访问规则的URI&lt;/li&gt;
&lt;li&gt;:uris - 和:uri类似，匹配多个URI&lt;/li&gt;
&lt;li&gt;:redirect - 重定向地址&lt;/li&gt;
&lt;li&gt;:on-fail - 重定向可选项，可以指定一个请求错误时的处理函数，函数必须
以request为参数&lt;/li&gt;
&lt;li&gt;:rule - 一个规则&lt;/li&gt;
&lt;li&gt;:rules - 多个规则&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:rules可以用在下面集中情形下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:rules [rule1 rule2]
:rules {:any [rule1 rule2]}
:rules {:every [rule1 rule2] :any [rule3 rule4]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，每个规则都必须通过才能访问成功，:any则表示只要符合任何一个
规则即可访问。下面是一些例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn admin-access [req]
 (session/get :admin))

:access-rules [{:redirect &quot;/access-denied&quot;
                :rule user-access}]

:access-rules [{:uris [&quot;/user/*&quot; &quot;/private*&quot;]
                :rule user-access}]

:access-rules [{:uri &quot;/admin/*&quot; :rule admin-access}
               {:uri &quot;/user/*&quot;
                :rules {:any [user-access admin-access]}}]

:access-rules [{:on-fail (fn [req] &quot;access restricted&quot;)
                :rule user-access}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击指的是第三方通过一个验证过的用户来提交动作。当你的网站包含了一
个恶意链接或按钮或js的时候，很容易发生。
我们可以使用Ring-Anti-Forgery来放置csrf攻击. 首先添加[ring-anti-forgery
&quot;0.2.1&quot;]依赖。接着引入相应的包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require
    ...
    [selmer.parser :refer [add-tag!]]
    [ring.util.anti-forgery :refer [anti-forgery-field]]
    [ring.middleware.anti-forgery :refer [wrap-anti-forgery]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将添加wrap-anti-forgery中间件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware [wrap-anti-forgery]
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完后一个随机字符串将会被赋给anti-forgery-token变量。所有的POST请求
将会包含一个叫_~anti~-forgery-token的token.
接着我们在init函数中添加csrf标签:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  ...
  (add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的POST请求如果不包含这个token，则会被拒绝。服务器返回403错误。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-ClojureScript</title>
        <link href="http://ivanpig.github.io/2013/09/17/clojurescript.html"/>
        <updated>2013-09-17T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/17/clojurescript</id>
        <content type="html">&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;ClojureScript可以作为JavaScript在客户端的替代品。使用ClojureScript可以
有如下有点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在客户端和服务端使用相同的语言&lt;/li&gt;
&lt;li&gt;在前后端共用相同的代码&lt;/li&gt;
&lt;li&gt;简介流畅的语言&lt;/li&gt;
&lt;li&gt;使用Leiningen管理依赖关系&lt;/li&gt;
&lt;li&gt;不可变数据&lt;/li&gt;
&lt;li&gt;功能强大的库&lt;/li&gt;
&lt;li&gt;Adding ClojureScript Support&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最简单的添加ClojureScript支持的方法就是在创建新项目的时候添加+cljs选项
。不过在现有的项目中添加ClojureScript也同样的简单。你只需要在
project.clj文件中添加如下内容即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:plugins [...
          [lein-cljsbuild &quot;0.3.0&quot;]]

:hooks [... leiningen.cljsbuild]

:cljsbuild
{:builds [{:source-paths [&quot;src-cljs&quot;]
           :compiler {:output-to &quot;resources/public/js/site.js&quot;
                      :optimizations :advanced}}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将在项目中添加cljsbuild插件和一个钩子。
所有的命名空间需要在项目根目录下的src-cljs目录内。注意，ClojureScript
文件需要以.cljs结尾。如果文件以.clj结尾，它也会被编译，不过它就无法访
问js命名空间。&lt;/p&gt;

&lt;h1&gt;Using Libraries&lt;/h1&gt;

&lt;p&gt;使用ClojureScript的一个好处就是你可以使用Leiningen来管理客户端的依赖。
ClojureScript库和其他库一样都配置在project.clj文件中。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Running the Compiler&lt;/h1&gt;

&lt;p&gt;开发ClojureScript应用最简单的方法就是自动运行编译器。这样，你的任何修
改都会立即生效。要开启自动编译，只需要输入如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用一次编译的方式。这将会将所有的js编译到一个js文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild once
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Advanced Compilation and Exports&lt;/h1&gt;

&lt;p&gt;使用高级编译的话变量名会被编译器压缩。如果要确保函数被编译为js时函数名
不变，那么我们需要保证他们的名字是受保护的。而这只需要添加^:export注解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns main)

(defn ^:export init []
  (js/alert &quot;hello world&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以像这样来调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;script&amp;gt;
    main.init();
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在代码里使用js库，那么我们必须要保护我们所调用的函数名。例如，
如果我们想使用AlbumColors库，如果我们这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn ^:export init []
  (.getColors (js/AlbumColors. &quot;/img/foo.jpg&quot;)
    (fn [[background]]
     (.log js/console background))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用高级编译时AlbumColors和getColors将会被改写。为了不让编译器改写他
们，我们需要创建一个js文件，里面包含了我们需要保护的函数，并在代码里引
用它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.javascript}&quot;&gt;var AlbumColors = {};
AlbumColors.getColors = function() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把上面的代码放到resource目录下一个叫externs.js文件里面。并在
cljsbuild丽引用它，像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{:source-paths [&quot;src-cljs&quot;]
     :compiler
     {:pretty-print false
      :output-to &quot;resources/public/js/site.js&quot;
      ;;specify the externs file to protect function names
      :externs [&quot;resources/externs.js&quot;]
      :optimizations :advanced}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Interacting with JavaScript&lt;/h1&gt;

&lt;p&gt;所有的js函数和变量都是在js这个Namespace的。&lt;/p&gt;

&lt;p&gt;*方法调用*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.method object params)

(.log js/console &quot;hello world!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*访问属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.-property object)

(.-style div)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*设置属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set! (.-property object))

(set! (.-color (.-style div) &quot;#234567&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的例子请查看&lt;a href=&quot;http://himera.herokuapp.com/synonym.html&quot;&gt;Himera文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Working With the DOM&lt;/h1&gt;

&lt;p&gt;有不少的库可以访问和修改DOM元素。一般用得比较多的是&lt;a href=&quot;https://github.com/levand/domina&quot;&gt;Domina&lt;/a&gt;和&lt;a href=&quot;https://github.com/Prismatic/dommy&quot;&gt;Dommy&lt;/a&gt;。
Domina对选择和操作DOM元素做了轻量级的封装。而Dommy是个类似hiccup的模板。&lt;/p&gt;

&lt;h1&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Luminus使用cljs-ajax来处理Ajax请求。这个库提供的ajax-request，GET和
POST函数能很方便的发送ajax请求。&lt;/p&gt;

&lt;p&gt;*ajax-request* ajax-request是最基本的请求函数，有如下参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;uri - 请求URI&lt;/li&gt;
&lt;li&gt;method - 一个表示http请求类型的字符串,比如：&quot;PUT&quot;, &quot;DELETE&quot;&lt;/li&gt;
&lt;li&gt;format - 一个表示响应类型的关键字,比如： :json 或者 :edn,默认是 :edn&lt;/li&gt;
&lt;li&gt;handler - 请求成功的回调函数，以响应为参数&lt;/li&gt;
&lt;li&gt;error-handler - 请求失败的回调函数,以一个map为参数，map包含了错误信
息，相应的key为: :status 和 :status-text&lt;/li&gt;
&lt;li&gt;params - 一个包含参数的map，发送给服务器&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;*GET/POST helpers* GET和POST助手接收一个URL和选项，来简化请求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:handler - 请求成功回调函数&lt;/li&gt;
&lt;li&gt;:error-handler - 请求失败函数&lt;/li&gt;
&lt;li&gt;:format - 相应格式化&lt;/li&gt;
&lt;li&gt;:params - 发送给服务器的参数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;和ajax-request参数功能相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns foo
  (:require [ajax.core :refer [GET POST]]))

(defn handler [response]
  (.log js/console (str response)))

(defn error-handler [{:keys [status status-text]}]
  (.log js/console
    (str &quot;something bad happened: &quot; status &quot; &quot; status-text)))

(GET &quot;/hello&quot;)

(GET &quot;/hello&quot; {:handler handler})

(POST &quot;/hello&quot;)

(POST &quot;/send-message&quot;
        {:params {:message &quot;Hello World&quot;
                  :user    &quot;Bob&quot;}
         :handler handler
         :error-handler error-handler})
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;ClojureScript可以作为JavaScript在客户端的替代品。使用ClojureScript可以
有如下有点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在客户端和服务端使用相同的语言&lt;/li&gt;
&lt;li&gt;在前后端共用相同的代码&lt;/li&gt;
&lt;li&gt;简介流畅的语言&lt;/li&gt;
&lt;li&gt;使用Leiningen管理依赖关系&lt;/li&gt;
&lt;li&gt;不可变数据&lt;/li&gt;
&lt;li&gt;功能强大的库&lt;/li&gt;
&lt;li&gt;Adding ClojureScript Support&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最简单的添加ClojureScript支持的方法就是在创建新项目的时候添加+cljs选项
。不过在现有的项目中添加ClojureScript也同样的简单。你只需要在
project.clj文件中添加如下内容即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:plugins [...
          [lein-cljsbuild &quot;0.3.0&quot;]]

:hooks [... leiningen.cljsbuild]

:cljsbuild
{:builds [{:source-paths [&quot;src-cljs&quot;]
           :compiler {:output-to &quot;resources/public/js/site.js&quot;
                      :optimizations :advanced}}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将在项目中添加cljsbuild插件和一个钩子。
所有的命名空间需要在项目根目录下的src-cljs目录内。注意，ClojureScript
文件需要以.cljs结尾。如果文件以.clj结尾，它也会被编译，不过它就无法访
问js命名空间。&lt;/p&gt;

&lt;h1&gt;Using Libraries&lt;/h1&gt;

&lt;p&gt;使用ClojureScript的一个好处就是你可以使用Leiningen来管理客户端的依赖。
ClojureScript库和其他库一样都配置在project.clj文件中。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Running the Compiler&lt;/h1&gt;

&lt;p&gt;开发ClojureScript应用最简单的方法就是自动运行编译器。这样，你的任何修
改都会立即生效。要开启自动编译，只需要输入如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用一次编译的方式。这将会将所有的js编译到一个js文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild once
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Advanced Compilation and Exports&lt;/h1&gt;

&lt;p&gt;使用高级编译的话变量名会被编译器压缩。如果要确保函数被编译为js时函数名
不变，那么我们需要保证他们的名字是受保护的。而这只需要添加^:export注解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns main)

(defn ^:export init []
  (js/alert &quot;hello world&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以像这样来调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;script&amp;gt;
    main.init();
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在代码里使用js库，那么我们必须要保护我们所调用的函数名。例如，
如果我们想使用AlbumColors库，如果我们这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn ^:export init []
  (.getColors (js/AlbumColors. &quot;/img/foo.jpg&quot;)
    (fn [[background]]
     (.log js/console background))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用高级编译时AlbumColors和getColors将会被改写。为了不让编译器改写他
们，我们需要创建一个js文件，里面包含了我们需要保护的函数，并在代码里引
用它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.javascript}&quot;&gt;var AlbumColors = {};
AlbumColors.getColors = function() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把上面的代码放到resource目录下一个叫externs.js文件里面。并在
cljsbuild丽引用它，像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{:source-paths [&quot;src-cljs&quot;]
     :compiler
     {:pretty-print false
      :output-to &quot;resources/public/js/site.js&quot;
      ;;specify the externs file to protect function names
      :externs [&quot;resources/externs.js&quot;]
      :optimizations :advanced}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Interacting with JavaScript&lt;/h1&gt;

&lt;p&gt;所有的js函数和变量都是在js这个Namespace的。&lt;/p&gt;

&lt;p&gt;*方法调用*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.method object params)

(.log js/console &quot;hello world!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*访问属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.-property object)

(.-style div)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*设置属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set! (.-property object))

(set! (.-color (.-style div) &quot;#234567&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的例子请查看&lt;a href=&quot;http://himera.herokuapp.com/synonym.html&quot;&gt;Himera文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Working With the DOM&lt;/h1&gt;

&lt;p&gt;有不少的库可以访问和修改DOM元素。一般用得比较多的是&lt;a href=&quot;https://github.com/levand/domina&quot;&gt;Domina&lt;/a&gt;和&lt;a href=&quot;https://github.com/Prismatic/dommy&quot;&gt;Dommy&lt;/a&gt;。
Domina对选择和操作DOM元素做了轻量级的封装。而Dommy是个类似hiccup的模板。&lt;/p&gt;

&lt;h1&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Luminus使用cljs-ajax来处理Ajax请求。这个库提供的ajax-request，GET和
POST函数能很方便的发送ajax请求。&lt;/p&gt;

&lt;p&gt;*ajax-request* ajax-request是最基本的请求函数，有如下参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;uri - 请求URI&lt;/li&gt;
&lt;li&gt;method - 一个表示http请求类型的字符串,比如：&quot;PUT&quot;, &quot;DELETE&quot;&lt;/li&gt;
&lt;li&gt;format - 一个表示响应类型的关键字,比如： :json 或者 :edn,默认是 :edn&lt;/li&gt;
&lt;li&gt;handler - 请求成功的回调函数，以响应为参数&lt;/li&gt;
&lt;li&gt;error-handler - 请求失败的回调函数,以一个map为参数，map包含了错误信
息，相应的key为: :status 和 :status-text&lt;/li&gt;
&lt;li&gt;params - 一个包含参数的map，发送给服务器&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;*GET/POST helpers* GET和POST助手接收一个URL和选项，来简化请求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:handler - 请求成功回调函数&lt;/li&gt;
&lt;li&gt;:error-handler - 请求失败函数&lt;/li&gt;
&lt;li&gt;:format - 相应格式化&lt;/li&gt;
&lt;li&gt;:params - 发送给服务器的参数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;和ajax-request参数功能相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns foo
  (:require [ajax.core :refer [GET POST]]))

(defn handler [response]
  (.log js/console (str response)))

(defn error-handler [{:keys [status status-text]}]
  (.log js/console
    (str &quot;something bad happened: &quot; status &quot; &quot; status-text)))

(GET &quot;/hello&quot;)

(GET &quot;/hello&quot; {:handler handler})

(POST &quot;/hello&quot;)

(POST &quot;/send-message&quot;
        {:params {:message &quot;Hello World&quot;
                  :user    &quot;Bob&quot;}
         :handler handler
         :error-handler error-handler})
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-HTML模板</title>
        <link href="http://ivanpig.github.io/2013/09/16/html_templating.html"/>
        <updated>2013-09-16T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/16/html_templating</id>
        <content type="html">&lt;h1&gt;Templating Options&lt;/h1&gt;

&lt;p&gt;Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。
Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成
HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。
你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢
的模板框架，比如Enlive或者Stencil。&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Selmer&lt;/h1&gt;

&lt;p&gt;Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语
言，那么你会感觉很熟悉.&lt;/p&gt;

&lt;h2&gt;Creating Templates&lt;/h2&gt;

&lt;p&gt;Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的
HTML文件。来看下面的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;My First Template&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;Hello { {name}}&amp;lt;/h2&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们
需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为
name的变量的值。
有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来
渲染模板。而render-file接收一个字符串作为路径来渲染模板。
如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example.routes.home
  (:use [selmer.parser :only [render-file]]))

(defn index [request]
  (render-file &quot;example/views/templates/index.html&quot;
               {:name &quot;John&quot;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;render-file函数将src目录作为根路径，使用相对路径来查找模板。
上面，我们传递了一个字符串作为变量name的值。实际上，我们可以传递任何类
型的值。比如，我们传递一个集合，在模板里我们可以使用tag来遍历这个集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;ul&amp;gt;
        { % for item in items %}
        &amp;lt;li&amp;gt; { {item}} &amp;lt;/li&amp;gt;
        { % endfor %}
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render-file &quot;/example/views/templates/items.html {:items (range 10)}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果传递的是个map，我们可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;&amp;lt;p&amp;gt;Hello { {user.first}} { {user.last}}&amp;lt;/p&amp;gt;&quot;
        {:user {:first &quot;John&quot; :last &quot;Doe&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有指定的展示方式，那么默认调用toString方法。
默认情况下，Selmer会缓存编译后的模板。只有当文件发生变化时，才会触发
Selmer重新编译模板。你也可以选择Selmer是开启缓存还是关闭缓存。只需要调
用(selmer.parser/cache-on!)或(selmer.parser/cache-off!).&lt;/p&gt;

&lt;h2&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filter允许我们在渲染变量之前对其做一些处理。比如将其值变为大写，计算一
个hash或者是计算长度。Filter的使用方法很简单，只需要在变量名后面跟一个
&quot;|&quot;接着是Filter即可。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { {name|upper}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是内置的filter:&lt;/p&gt;

&lt;p&gt;*add*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {add_me|add:2:3:4}}&quot; {:add_me 2}) =&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*addslashes* 为了保留字符串中的转义符&quot;&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|addslashes}}&quot; {:name &quot;\&quot;Russian tea is best tea\&quot;&quot;}) =&amp;gt; &quot;\&quot;Russian tea is best tea\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block.super* 在代码块中插入上级代码块中的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;        { % block foo %} { {block.super}} some content{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*capitalize*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|capitalize}}&quot; {:name &quot;russian tea is best tea&quot;}) =&amp;gt; &quot;Russian tea is best tea&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*center*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|center:20}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot; bitemyapp &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*count*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|count}}&quot; {:name &quot;Yogthos&quot;}) =&amp;gt; &quot;7&quot;

(render &quot;{ {items|count}}&quot; {:items [1 2 3 4]}) =&amp;gt; &quot;4&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*date*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {creation-time|date:\&quot;yyyy-MM-dd_HH:mm:ss\&quot;}}&quot; {:created-at (java.util.Date.)}) =&amp;gt; &quot;2013-07-28_20:51:48&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;[]&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default-if-empty*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*double-format*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|double-format:2}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.00

(render &quot;{ {tis-a-number|double-format}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*first*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {seq-of-some-sort|first}}&quot; {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]}) =&amp;gt; :dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*get-digit* 从右边返回相应位数的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|get-digit:1}}&quot; {:tis-a-number 12.34567}) =&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*hash* 有效的hash方式: md5, sha, sha256, sha384, sha512&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {domain|hash:\&quot;md5\&quot;}}&quot; {:domain &quot;example.org&quot;}) =&amp;gt; &quot;1bdf72e04d6b50c82a48c7e4dd38cc69&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*join*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|join}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; &quot;1234&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*json* 生成json格式，默认情况下特殊字符会被编码.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data|json}}&quot; {:data [1 2 {:foo 27 :dan &quot;awesome&quot;}]})
               =&amp;gt; &quot;[1,2,{&amp;amp;quot;foo&amp;amp;quot;:27,&amp;amp;quot;dan&amp;amp;quot;:&amp;amp;quot;awesome&amp;amp;quot;}]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不希望被编码则使用safe过滤器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {f|json|safe}}&quot; {:f {:foo 27 :dan &quot;awesome&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*last*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|last}}&quot; {:sequence 12.34567}) =&amp;gt; 7

(render &quot;{ {sequence|last}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length-is*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length-is:4}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks* 普通换行替换为html换行,结果在\&amp;lt;p&gt;标签内&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;&amp;lt;p&amp;gt;&amp;lt;br /&amp;gt;bar&amp;lt;br /&amp;gt;baz&amp;lt;/p&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks-br* 和linebreaks功能相同，但是没有\&amp;lt;p&gt;标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks-br|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;bar&amp;lt;br /&amp;gt;baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linenumbers* 显示行号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linenumbers&quot; {:foo &quot;foo\n\bar\nbaz&quot;}) =&amp;gt; &quot;1. foo\n2. \bar\n3. baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*lower*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|lower}}&quot; {:foo &quot;FOOBaR&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*pluralize* 返回单词的复数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items []}) =&amp;gt; &quot;0 items&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1]}) =&amp;gt; &quot;1 item&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1 2]}) =&amp;gt; &quot;2 items&quot;

(render &quot;{ {fruit|count}} tomato{ {fruit|pluralize:\&quot;es\&quot;}}&quot; {:fruit []}) =&amp;gt; &quot;0 tomatoes&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1]}) =&amp;gt; &quot;1 lady&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1 2]}) =&amp;gt; &quot;2 ladies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*rand-nth* 从集合中返回rand-nths值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|rand-nth}}&quot; {:foo [1 2 3]}) =&amp;gt; &quot;2&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove* 从字符串中去除特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|remove:\&quot;aeiou\&quot;}}&quot; {:foo &quot;abcdefghijklmnop&quot;}) =&amp;gt; &quot;bcdfghjklmnp&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove-tags* 去除html标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|remove-tags:b:span }}&quot; {:value &quot;&amp;lt;b&amp;gt;&amp;lt;span&amp;gt;foobar&amp;lt;/span&amp;gt;&amp;lt;/b&amp;gt;&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*safe* 默认情况下Selmer会编码所有的内容，此过滤器时Selmer不去编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;amp;lt;foo&amp;amp;gt;&quot;

(render &quot;{ {data|safe}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;lt;foo&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort }}&quot; {:value [1 4 2 3 5]}) =&amp;gt; &quot;(1 2 3 4 5)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-by*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort-by:name }}&quot; {:value [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]})
                     =&amp;gt; &quot;({:name &amp;amp;quot;Jane&amp;amp;quot;} {:name &amp;amp;quot;John&amp;amp;quot;})&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-reversed* 反序排列&lt;/p&gt;

&lt;p&gt;*sort-by-reversed* 和sort-by功能相同，反序&lt;/p&gt;

&lt;p&gt;upper&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {shout|upper}}&quot; {:shout &quot;hello&quot;}) =&amp;gt; &quot;HELLO&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Filters&lt;/h2&gt;

&lt;p&gt;你可以使用selmer.filters/add-filter!函数来方便的添加自定义的Filter.此
函数以元素作为参数，并返回替换后的值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.filters)

(add-filter! :embiginate #(.toUpperCase %))
 (render &quot;{ {shout|embiginate}}&quot; {:shout &quot;hello&quot;})

(add-filter! :count count)
(render &quot;{ {foo|count}}&quot; {:foo (range 3)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filters可以链式使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ {foo|upper|empty?}}&quot; {:foo &quot;Hello&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Tags&lt;/h2&gt;

&lt;p&gt;Selmer提供了两种类型的Tag。一种是类似extends和include这样的内联tag。这
种tag不需要结束tag。另一种形式的tag是块tag。这种tag有开始和结束tag，以
及代码块。比如if ... endif块。 让我们先来看看默认的tag:&lt;/p&gt;

&lt;p&gt;*include* 将引用的模板内容替换其自身&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % include &quot;path/to/comments.html&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以提供默认的参数，如果tag有匹配上上的参数，则会获取它的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{ % include &quot;templates/inheritance/child.html&quot; with name=&quot;Jane Doe&quot; greeting=&quot;Hello!&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block*
定义一个块，可以使用模板继承的方式来覆盖，类似Java中的父类方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block foo %}This text can be overridden later{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*cycle* 循环提供的参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % for i in items %}&amp;lt;li class={ % cycle \&quot;blue\&quot; \&quot;white\&quot;%}&amp;gt;{ {i}}&amp;lt;/li&amp;gt;{ % endfor %}&quot; {:items (range 5)})
                        =&amp;gt; &quot;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;0&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;white\&quot;&amp;gt;1&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;2&amp;lt;/li&amp;gt;
                            &amp;lt;li class=\&quot;white\&quot;&amp;gt;3&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;4&amp;lt;/li&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*extends* 引用父模板。父模板中的块会被子模板中相应的块覆盖。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Note: 子模板只能包含块。任何块以外的tag或文本都被忽略&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;例如有一个叫base.html的父模板和一个叫child.html的子模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    { % block foo %}This text can be overridden later{ % endblock %}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % extends &quot;base.html&quot; %}
    { % block foo %}
      &amp;lt;p&amp;gt;This text will override the text in the parent&amp;lt;/p&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*if*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % if condition %}yes!{ % endif %}

{ % if condition %}yes!{ % else %}no!{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合filter使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ % if files|empty? %}no files{ % else %}files{ % endif %}&quot;
  {:files []})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*ifequal* 之用当两个参数相等时才执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % ifequal foo bar %}yes!{ % endifequal %}

{ % ifequal foo bar %}yes!{ % else %}no!{ % endifequal %}

{ % ifequal foo &quot;this also works&quot; %}yes!{ % endifequal %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*for* 遍历集合中的元素。同时可以使用如下参数。
-   forloop.first
-   forloop.last
-   forloop.counter
-   forloop.counter0
-   forloop.revcounter
-   forloop.revcounter0
-   forloop.length&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for x in some-list %}element: { {x}} first? { {forloop.first}} last? { {forloop.last}}{ % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以直接访问结构化的数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for item in items %} &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{ {item.name}}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{ {item.age}}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; { % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*now* 当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render (str &quot;{ % now \&quot;&quot; date-format &quot;\&quot;%}&quot;) {}) =&amp;gt; &quot;\&quot;01 08 2013\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*comment* 注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;foo bar { % comment %} baz test { {x}} { % endcomment %} blah&quot; {}) =&amp;gt; &quot;foo bar baz test blah&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*firstof* 取得第一个不是false的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % firstof var1 var2 var3 %}&quot; {:var2 &quot;x&quot; :var3 &quot;not me&quot;}) =&amp;gt; &quot;x&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*script*
生成一个html的script标签，并以servlet-context键提供的值类作为文件的前
置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % script \&quot;/js/site.js\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;script src=\&quot;/myapp/js/site.js\&quot; type=\&quot;text/javascript\&quot;&amp;gt;&amp;lt;/script&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*style*&lt;/p&gt;

&lt;p&gt;生成一个html的style标签，并以servlet-context键提供的值类作为文件的前置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % style \&quot;/css/screen.css\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;link href=\&quot;/myapp/css/screen.css\&quot; rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; /&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*verbatim* 阻止内容中的parseeither解析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % verbatim %}{ {if dying}}Still alive.{ {/if}}{ % endverbatim %}&quot; {}) =&amp;gt; &quot;{ {if dying}}Still alive.{ {/if}}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*with* 向上下文map中新增一个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % with total=business.employees|count %}{ { total }}{ % endwith %}&quot;
         {:business {:employees (range 5)}})
=&amp;gt; &quot;5 employees&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Tags&lt;/h2&gt;

&lt;p&gt;除了上面已经提供的tag。你也可以自定义tag。使用add-tag!宏就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.parser)

(add-tag! :foo
  (fn [args context-map]
    (str &quot;foo &quot; (first args))))

(render &quot;{ % foo quux %} { % foo baz %}&quot; {})

(add-tag! :bar
  (fn [args context-map content]
    (str content))
  :baz :endbar)

(render &quot;{ % bar %} some text { % baz %} some more text { % endbar %}&quot; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，我们定义的tag提供了一个关键字作为tag的名称后面是tag体,结尾的
tag不是必须的。
当没有结尾的tag时,tag不包含任何内容。这种tag获取参数类进行处理。
当有结尾tag时，每个块内的内容都会被作为开头那个tag所对应的map的键.开头
tag对应的map包含:args和:content键，content的内容就对应到了:content.&lt;/p&gt;

&lt;h2&gt;Template inheritance&lt;/h2&gt;

&lt;p&gt;Selmer模板可以使用块tag来引用其他的模板。有两种方法可以引用模板，一个
是extends一个是include.&lt;/p&gt;

&lt;h3&gt;Extending Templates&lt;/h3&gt;

&lt;p&gt;当我们使用extends这个tag时，当前的模板将会将引用的模板作为父模板。
任何在base模板中的块，会被子模板中相同名字的块给覆盖.
子模板中的内容需要在块tag中。不在块中的内容将会被忽略。
我们来看个例子,我们创建一个叫base.html的父模板.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % block content %}{ % endblock %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们创建一个home.html模板来继承base.html。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % extends &quot;base.html&quot; %}

    { % block content %}
        { % for entry in entries %}
            &amp;lt;h2&amp;gt;{ { entry.title }}&amp;lt;/h2&amp;gt;
            &amp;lt;p&amp;gt;{ { entry.body }}&amp;lt;/p&amp;gt;
        { % endfor %}
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染home.html时entries的内容将会被打印出来。而在home.html中，我们没
有定义title块，在渲染时会获取base.html中的title块的定义。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注意，你可以多层级的继承模板。引擎会渲染最后的那个块.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Including Templates&lt;/h3&gt;

&lt;p&gt;include这个tag允许你包含一个模板。
我们还是来看一个例子，我们有一个base.html这个模板，它包含了一个叫做
register.html的模板和一个home.html的模板：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % if user %}
        { % include &quot;templates_path/home.html&quot; %}
        { % else %}
        { % include &quot;templates_path/register.html&quot; %}
        { % endif %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们能定义register.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block register %}
      &amp;lt;form action=&quot;/register&quot; method=&quot;POST&quot;&amp;gt;
          &amp;lt;label for=&quot;id&quot;&amp;gt;user id&amp;lt;/label&amp;gt;
          &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input pass=&quot;pass&quot; name=&quot;pass&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input type=&quot;submit&quot; value=&quot;register&quot;&amp;gt;
      &amp;lt;/form&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和home.html:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block home %}
    &amp;lt;h1&amp;gt;Hello { {user}}&amp;lt;/h1&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染base.html时，将会引入register.html和home.html。
更多信息请见&lt;a href=&quot;https://github.com/yogthos/Selmer&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Hiccup&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weavejester/hiccup&quot;&gt;Hiccup&lt;/a&gt;
是另一个Clojure的HTML模板引擎。它的优势是我们可以使用纯正的
Clojure代码来生成页面。也就是说我们不需要学习第三方的语法了。
Hiccup主要使用Clojure的vector来渲染页面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:tag-name {:attribute-key &quot;attribute value&quot;} tag-body]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，如果我们想创建一个包含内容的div，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div {:id &quot;hello&quot;, :class &quot;content&quot;} [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将生成如下的html代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;        &amp;lt;div id=&quot;hello&quot; class=&quot;content&quot;&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup提供了简化设置id和class的方法，简写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div#hello.content [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup还提供了一些帮助类函数来创建元素，比如: forms, links, images, 等
等.所有这些函数只是简单的返回类似上面格式的vector。也就是说，如果一个
函数无法达到你的要求，你可以手写相应代码或者获取函数的返回值进行修改。
每个函数可以使用一个map作为其第一个参数，来描绘属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(image {:align &quot;left&quot;} &quot;foo.png&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成html代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;&amp;lt;img align=\&quot;left\&quot; src=\&quot;foo.png\&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是最佳实践还是将其保存到独立的CSS文件中。&lt;/p&gt;

&lt;h2&gt;Forms and Input&lt;/h2&gt;

&lt;p&gt;Hiccup还提供了form助手函数，看例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(form-to [:post &quot;/login&quot;]
  (text-field {:placeholder &quot;screen name&quot;} &quot;id&quot;)
  (password-field {:placeholder &quot;password&quot;} &quot;pass&quot;)
  (submit-button &quot;login&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数第一个参数是一个vector，以HTTP请求类型为关键字，紧接着是请求
url。其余的参数必须是HTML元素。生成的HTML代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
  &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; placeholder=&quot;screen name&quot; type=&quot;text&quot; /&amp;gt;
  &amp;lt;input id=&quot;pass&quot; name=&quot;pass&quot; placeholder=&quot;password&quot; type=&quot;password&quot; /&amp;gt;
  &amp;lt;input type=&quot;submit&quot; value=&quot;login&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后LUminus模板在你的应用下面提供了一辅助函数。叫做md-&gt;html,这个函数能
渲染载resources/public/目录下的markdown文件并返回一个HTML字符串。这个
可以和Hiccup函数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [&amp;lt;yourapp&amp;gt;.util :as util])
...
(html [:div.contenr [:p (util/md-&amp;gt;html &quot;/md/paragraph.md&quot;)]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown生成由markdown-clj来处理，具体信息请见其&lt;a href=&quot;https://github.com/yogthos/markdown-clj&quot;&gt;Github&lt;/a&gt;
页。&lt;/p&gt;

&lt;h1&gt;Content caching&lt;/h1&gt;

&lt;p&gt;lib-noir通过cache!宏提供了基本的内存式缓存，相应的宏在noir.util.cache
下。如果想缓存一个页面，你是需要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.util.cache :as cache])

(defn slow-loading-page []
  (cache/cache!
   :slow-page
   (common/layout
    [:div &quot;I load slowly&quot;]
     (parse-lots-of-files))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用invalidate!来取消缓存,需要提供需要取消的缓存的key。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/invalidate! :slow-page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用clear!来清除当前所有的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/clear!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用set-timeout!来设置缓存时间(单位：秒)，超时后会重新加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-timeout! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你可以通过set-size!来设置缓存的大小。当缓存超出了限定的大小，最先
使用的数据将被被替换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-size! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意，缓存会在操作成功后才重新加载。也就是说，比如程序去获取一个远程
文件，但是失败了，那么缓存是不会被重新加载的。&lt;/li&gt;
&lt;/ul&gt;

</content>
        <summary type="html">&lt;h1&gt;Templating Options&lt;/h1&gt;

&lt;p&gt;Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。
Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成
HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。
你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢
的模板框架，比如Enlive或者Stencil。&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Selmer&lt;/h1&gt;

&lt;p&gt;Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语
言，那么你会感觉很熟悉.&lt;/p&gt;

&lt;h2&gt;Creating Templates&lt;/h2&gt;

&lt;p&gt;Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的
HTML文件。来看下面的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;My First Template&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;Hello { {name}}&amp;lt;/h2&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们
需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为
name的变量的值。
有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来
渲染模板。而render-file接收一个字符串作为路径来渲染模板。
如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example.routes.home
  (:use [selmer.parser :only [render-file]]))

(defn index [request]
  (render-file &quot;example/views/templates/index.html&quot;
               {:name &quot;John&quot;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;render-file函数将src目录作为根路径，使用相对路径来查找模板。
上面，我们传递了一个字符串作为变量name的值。实际上，我们可以传递任何类
型的值。比如，我们传递一个集合，在模板里我们可以使用tag来遍历这个集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;ul&amp;gt;
        { % for item in items %}
        &amp;lt;li&amp;gt; { {item}} &amp;lt;/li&amp;gt;
        { % endfor %}
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render-file &quot;/example/views/templates/items.html {:items (range 10)}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果传递的是个map，我们可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;&amp;lt;p&amp;gt;Hello { {user.first}} { {user.last}}&amp;lt;/p&amp;gt;&quot;
        {:user {:first &quot;John&quot; :last &quot;Doe&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有指定的展示方式，那么默认调用toString方法。
默认情况下，Selmer会缓存编译后的模板。只有当文件发生变化时，才会触发
Selmer重新编译模板。你也可以选择Selmer是开启缓存还是关闭缓存。只需要调
用(selmer.parser/cache-on!)或(selmer.parser/cache-off!).&lt;/p&gt;

&lt;h2&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filter允许我们在渲染变量之前对其做一些处理。比如将其值变为大写，计算一
个hash或者是计算长度。Filter的使用方法很简单，只需要在变量名后面跟一个
&quot;|&quot;接着是Filter即可。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { {name|upper}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是内置的filter:&lt;/p&gt;

&lt;p&gt;*add*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {add_me|add:2:3:4}}&quot; {:add_me 2}) =&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*addslashes* 为了保留字符串中的转义符&quot;&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|addslashes}}&quot; {:name &quot;\&quot;Russian tea is best tea\&quot;&quot;}) =&amp;gt; &quot;\&quot;Russian tea is best tea\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block.super* 在代码块中插入上级代码块中的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;        { % block foo %} { {block.super}} some content{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*capitalize*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|capitalize}}&quot; {:name &quot;russian tea is best tea&quot;}) =&amp;gt; &quot;Russian tea is best tea&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*center*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|center:20}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot; bitemyapp &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*count*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|count}}&quot; {:name &quot;Yogthos&quot;}) =&amp;gt; &quot;7&quot;

(render &quot;{ {items|count}}&quot; {:items [1 2 3 4]}) =&amp;gt; &quot;4&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*date*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {creation-time|date:\&quot;yyyy-MM-dd_HH:mm:ss\&quot;}}&quot; {:created-at (java.util.Date.)}) =&amp;gt; &quot;2013-07-28_20:51:48&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;[]&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default-if-empty*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*double-format*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|double-format:2}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.00

(render &quot;{ {tis-a-number|double-format}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*first*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {seq-of-some-sort|first}}&quot; {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]}) =&amp;gt; :dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*get-digit* 从右边返回相应位数的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|get-digit:1}}&quot; {:tis-a-number 12.34567}) =&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*hash* 有效的hash方式: md5, sha, sha256, sha384, sha512&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {domain|hash:\&quot;md5\&quot;}}&quot; {:domain &quot;example.org&quot;}) =&amp;gt; &quot;1bdf72e04d6b50c82a48c7e4dd38cc69&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*join*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|join}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; &quot;1234&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*json* 生成json格式，默认情况下特殊字符会被编码.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data|json}}&quot; {:data [1 2 {:foo 27 :dan &quot;awesome&quot;}]})
               =&amp;gt; &quot;[1,2,{&amp;amp;quot;foo&amp;amp;quot;:27,&amp;amp;quot;dan&amp;amp;quot;:&amp;amp;quot;awesome&amp;amp;quot;}]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不希望被编码则使用safe过滤器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {f|json|safe}}&quot; {:f {:foo 27 :dan &quot;awesome&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*last*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|last}}&quot; {:sequence 12.34567}) =&amp;gt; 7

(render &quot;{ {sequence|last}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length-is*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length-is:4}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks* 普通换行替换为html换行,结果在\&amp;lt;p&gt;标签内&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;&amp;lt;p&amp;gt;&amp;lt;br /&amp;gt;bar&amp;lt;br /&amp;gt;baz&amp;lt;/p&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks-br* 和linebreaks功能相同，但是没有\&amp;lt;p&gt;标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks-br|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;bar&amp;lt;br /&amp;gt;baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linenumbers* 显示行号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linenumbers&quot; {:foo &quot;foo\n\bar\nbaz&quot;}) =&amp;gt; &quot;1. foo\n2. \bar\n3. baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*lower*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|lower}}&quot; {:foo &quot;FOOBaR&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*pluralize* 返回单词的复数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items []}) =&amp;gt; &quot;0 items&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1]}) =&amp;gt; &quot;1 item&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1 2]}) =&amp;gt; &quot;2 items&quot;

(render &quot;{ {fruit|count}} tomato{ {fruit|pluralize:\&quot;es\&quot;}}&quot; {:fruit []}) =&amp;gt; &quot;0 tomatoes&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1]}) =&amp;gt; &quot;1 lady&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1 2]}) =&amp;gt; &quot;2 ladies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*rand-nth* 从集合中返回rand-nths值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|rand-nth}}&quot; {:foo [1 2 3]}) =&amp;gt; &quot;2&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove* 从字符串中去除特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|remove:\&quot;aeiou\&quot;}}&quot; {:foo &quot;abcdefghijklmnop&quot;}) =&amp;gt; &quot;bcdfghjklmnp&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove-tags* 去除html标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|remove-tags:b:span }}&quot; {:value &quot;&amp;lt;b&amp;gt;&amp;lt;span&amp;gt;foobar&amp;lt;/span&amp;gt;&amp;lt;/b&amp;gt;&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*safe* 默认情况下Selmer会编码所有的内容，此过滤器时Selmer不去编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;amp;lt;foo&amp;amp;gt;&quot;

(render &quot;{ {data|safe}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;lt;foo&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort }}&quot; {:value [1 4 2 3 5]}) =&amp;gt; &quot;(1 2 3 4 5)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-by*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort-by:name }}&quot; {:value [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]})
                     =&amp;gt; &quot;({:name &amp;amp;quot;Jane&amp;amp;quot;} {:name &amp;amp;quot;John&amp;amp;quot;})&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-reversed* 反序排列&lt;/p&gt;

&lt;p&gt;*sort-by-reversed* 和sort-by功能相同，反序&lt;/p&gt;

&lt;p&gt;upper&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {shout|upper}}&quot; {:shout &quot;hello&quot;}) =&amp;gt; &quot;HELLO&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Filters&lt;/h2&gt;

&lt;p&gt;你可以使用selmer.filters/add-filter!函数来方便的添加自定义的Filter.此
函数以元素作为参数，并返回替换后的值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.filters)

(add-filter! :embiginate #(.toUpperCase %))
 (render &quot;{ {shout|embiginate}}&quot; {:shout &quot;hello&quot;})

(add-filter! :count count)
(render &quot;{ {foo|count}}&quot; {:foo (range 3)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filters可以链式使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ {foo|upper|empty?}}&quot; {:foo &quot;Hello&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Tags&lt;/h2&gt;

&lt;p&gt;Selmer提供了两种类型的Tag。一种是类似extends和include这样的内联tag。这
种tag不需要结束tag。另一种形式的tag是块tag。这种tag有开始和结束tag，以
及代码块。比如if ... endif块。 让我们先来看看默认的tag:&lt;/p&gt;

&lt;p&gt;*include* 将引用的模板内容替换其自身&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % include &quot;path/to/comments.html&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以提供默认的参数，如果tag有匹配上上的参数，则会获取它的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{ % include &quot;templates/inheritance/child.html&quot; with name=&quot;Jane Doe&quot; greeting=&quot;Hello!&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block*
定义一个块，可以使用模板继承的方式来覆盖，类似Java中的父类方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block foo %}This text can be overridden later{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*cycle* 循环提供的参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % for i in items %}&amp;lt;li class={ % cycle \&quot;blue\&quot; \&quot;white\&quot;%}&amp;gt;{ {i}}&amp;lt;/li&amp;gt;{ % endfor %}&quot; {:items (range 5)})
                        =&amp;gt; &quot;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;0&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;white\&quot;&amp;gt;1&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;2&amp;lt;/li&amp;gt;
                            &amp;lt;li class=\&quot;white\&quot;&amp;gt;3&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;4&amp;lt;/li&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*extends* 引用父模板。父模板中的块会被子模板中相应的块覆盖。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Note: 子模板只能包含块。任何块以外的tag或文本都被忽略&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;例如有一个叫base.html的父模板和一个叫child.html的子模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    { % block foo %}This text can be overridden later{ % endblock %}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % extends &quot;base.html&quot; %}
    { % block foo %}
      &amp;lt;p&amp;gt;This text will override the text in the parent&amp;lt;/p&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*if*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % if condition %}yes!{ % endif %}

{ % if condition %}yes!{ % else %}no!{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合filter使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ % if files|empty? %}no files{ % else %}files{ % endif %}&quot;
  {:files []})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*ifequal* 之用当两个参数相等时才执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % ifequal foo bar %}yes!{ % endifequal %}

{ % ifequal foo bar %}yes!{ % else %}no!{ % endifequal %}

{ % ifequal foo &quot;this also works&quot; %}yes!{ % endifequal %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*for* 遍历集合中的元素。同时可以使用如下参数。
-   forloop.first
-   forloop.last
-   forloop.counter
-   forloop.counter0
-   forloop.revcounter
-   forloop.revcounter0
-   forloop.length&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for x in some-list %}element: { {x}} first? { {forloop.first}} last? { {forloop.last}}{ % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以直接访问结构化的数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for item in items %} &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{ {item.name}}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{ {item.age}}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; { % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*now* 当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render (str &quot;{ % now \&quot;&quot; date-format &quot;\&quot;%}&quot;) {}) =&amp;gt; &quot;\&quot;01 08 2013\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*comment* 注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;foo bar { % comment %} baz test { {x}} { % endcomment %} blah&quot; {}) =&amp;gt; &quot;foo bar baz test blah&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*firstof* 取得第一个不是false的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % firstof var1 var2 var3 %}&quot; {:var2 &quot;x&quot; :var3 &quot;not me&quot;}) =&amp;gt; &quot;x&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*script*
生成一个html的script标签，并以servlet-context键提供的值类作为文件的前
置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % script \&quot;/js/site.js\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;script src=\&quot;/myapp/js/site.js\&quot; type=\&quot;text/javascript\&quot;&amp;gt;&amp;lt;/script&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*style*&lt;/p&gt;

&lt;p&gt;生成一个html的style标签，并以servlet-context键提供的值类作为文件的前置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % style \&quot;/css/screen.css\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;link href=\&quot;/myapp/css/screen.css\&quot; rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; /&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*verbatim* 阻止内容中的parseeither解析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % verbatim %}{ {if dying}}Still alive.{ {/if}}{ % endverbatim %}&quot; {}) =&amp;gt; &quot;{ {if dying}}Still alive.{ {/if}}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*with* 向上下文map中新增一个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % with total=business.employees|count %}{ { total }}{ % endwith %}&quot;
         {:business {:employees (range 5)}})
=&amp;gt; &quot;5 employees&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Tags&lt;/h2&gt;

&lt;p&gt;除了上面已经提供的tag。你也可以自定义tag。使用add-tag!宏就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.parser)

(add-tag! :foo
  (fn [args context-map]
    (str &quot;foo &quot; (first args))))

(render &quot;{ % foo quux %} { % foo baz %}&quot; {})

(add-tag! :bar
  (fn [args context-map content]
    (str content))
  :baz :endbar)

(render &quot;{ % bar %} some text { % baz %} some more text { % endbar %}&quot; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，我们定义的tag提供了一个关键字作为tag的名称后面是tag体,结尾的
tag不是必须的。
当没有结尾的tag时,tag不包含任何内容。这种tag获取参数类进行处理。
当有结尾tag时，每个块内的内容都会被作为开头那个tag所对应的map的键.开头
tag对应的map包含:args和:content键，content的内容就对应到了:content.&lt;/p&gt;

&lt;h2&gt;Template inheritance&lt;/h2&gt;

&lt;p&gt;Selmer模板可以使用块tag来引用其他的模板。有两种方法可以引用模板，一个
是extends一个是include.&lt;/p&gt;

&lt;h3&gt;Extending Templates&lt;/h3&gt;

&lt;p&gt;当我们使用extends这个tag时，当前的模板将会将引用的模板作为父模板。
任何在base模板中的块，会被子模板中相同名字的块给覆盖.
子模板中的内容需要在块tag中。不在块中的内容将会被忽略。
我们来看个例子,我们创建一个叫base.html的父模板.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % block content %}{ % endblock %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们创建一个home.html模板来继承base.html。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % extends &quot;base.html&quot; %}

    { % block content %}
        { % for entry in entries %}
            &amp;lt;h2&amp;gt;{ { entry.title }}&amp;lt;/h2&amp;gt;
            &amp;lt;p&amp;gt;{ { entry.body }}&amp;lt;/p&amp;gt;
        { % endfor %}
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染home.html时entries的内容将会被打印出来。而在home.html中，我们没
有定义title块，在渲染时会获取base.html中的title块的定义。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注意，你可以多层级的继承模板。引擎会渲染最后的那个块.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Including Templates&lt;/h3&gt;

&lt;p&gt;include这个tag允许你包含一个模板。
我们还是来看一个例子，我们有一个base.html这个模板，它包含了一个叫做
register.html的模板和一个home.html的模板：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % if user %}
        { % include &quot;templates_path/home.html&quot; %}
        { % else %}
        { % include &quot;templates_path/register.html&quot; %}
        { % endif %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们能定义register.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block register %}
      &amp;lt;form action=&quot;/register&quot; method=&quot;POST&quot;&amp;gt;
          &amp;lt;label for=&quot;id&quot;&amp;gt;user id&amp;lt;/label&amp;gt;
          &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input pass=&quot;pass&quot; name=&quot;pass&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input type=&quot;submit&quot; value=&quot;register&quot;&amp;gt;
      &amp;lt;/form&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和home.html:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block home %}
    &amp;lt;h1&amp;gt;Hello { {user}}&amp;lt;/h1&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染base.html时，将会引入register.html和home.html。
更多信息请见&lt;a href=&quot;https://github.com/yogthos/Selmer&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Hiccup&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weavejester/hiccup&quot;&gt;Hiccup&lt;/a&gt;
是另一个Clojure的HTML模板引擎。它的优势是我们可以使用纯正的
Clojure代码来生成页面。也就是说我们不需要学习第三方的语法了。
Hiccup主要使用Clojure的vector来渲染页面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:tag-name {:attribute-key &quot;attribute value&quot;} tag-body]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，如果我们想创建一个包含内容的div，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div {:id &quot;hello&quot;, :class &quot;content&quot;} [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将生成如下的html代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;        &amp;lt;div id=&quot;hello&quot; class=&quot;content&quot;&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup提供了简化设置id和class的方法，简写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div#hello.content [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup还提供了一些帮助类函数来创建元素，比如: forms, links, images, 等
等.所有这些函数只是简单的返回类似上面格式的vector。也就是说，如果一个
函数无法达到你的要求，你可以手写相应代码或者获取函数的返回值进行修改。
每个函数可以使用一个map作为其第一个参数，来描绘属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(image {:align &quot;left&quot;} &quot;foo.png&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成html代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;&amp;lt;img align=\&quot;left\&quot; src=\&quot;foo.png\&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是最佳实践还是将其保存到独立的CSS文件中。&lt;/p&gt;

&lt;h2&gt;Forms and Input&lt;/h2&gt;

&lt;p&gt;Hiccup还提供了form助手函数，看例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(form-to [:post &quot;/login&quot;]
  (text-field {:placeholder &quot;screen name&quot;} &quot;id&quot;)
  (password-field {:placeholder &quot;password&quot;} &quot;pass&quot;)
  (submit-button &quot;login&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数第一个参数是一个vector，以HTTP请求类型为关键字，紧接着是请求
url。其余的参数必须是HTML元素。生成的HTML代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
  &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; placeholder=&quot;screen name&quot; type=&quot;text&quot; /&amp;gt;
  &amp;lt;input id=&quot;pass&quot; name=&quot;pass&quot; placeholder=&quot;password&quot; type=&quot;password&quot; /&amp;gt;
  &amp;lt;input type=&quot;submit&quot; value=&quot;login&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后LUminus模板在你的应用下面提供了一辅助函数。叫做md-&gt;html,这个函数能
渲染载resources/public/目录下的markdown文件并返回一个HTML字符串。这个
可以和Hiccup函数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [&amp;lt;yourapp&amp;gt;.util :as util])
...
(html [:div.contenr [:p (util/md-&amp;gt;html &quot;/md/paragraph.md&quot;)]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown生成由markdown-clj来处理，具体信息请见其&lt;a href=&quot;https://github.com/yogthos/markdown-clj&quot;&gt;Github&lt;/a&gt;
页。&lt;/p&gt;

&lt;h1&gt;Content caching&lt;/h1&gt;

&lt;p&gt;lib-noir通过cache!宏提供了基本的内存式缓存，相应的宏在noir.util.cache
下。如果想缓存一个页面，你是需要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.util.cache :as cache])

(defn slow-loading-page []
  (cache/cache!
   :slow-page
   (common/layout
    [:div &quot;I load slowly&quot;]
     (parse-lots-of-files))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用invalidate!来取消缓存,需要提供需要取消的缓存的key。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/invalidate! :slow-page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用clear!来清除当前所有的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/clear!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用set-timeout!来设置缓存时间(单位：秒)，超时后会重新加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-timeout! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你可以通过set-size!来设置缓存的大小。当缓存超出了限定的大小，最先
使用的数据将被被替换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-size! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意，缓存会在操作成功后才重新加载。也就是说，比如程序去获取一个远程
文件，但是失败了，那么缓存是不会被重新加载的。&lt;/li&gt;
&lt;/ul&gt;

</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-应用配置</title>
        <link href="http://ivanpig.github.io/2013/09/15/application_profile.html"/>
        <updated>2013-09-15T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/15/application_profile</id>
        <content type="html">&lt;h1&gt;Profiles&lt;/h1&gt;

&lt;p&gt;使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。&lt;/p&gt;

&lt;p&gt;下面就是各个配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+cljs - 添加ClojureScript支持&lt;/li&gt;
&lt;li&gt;+cucumber - 提供通过clj-webdriver配置cucumber&lt;/li&gt;
&lt;li&gt;+h2 - 添加models.db并提供H2数据库依赖&lt;/li&gt;
&lt;li&gt;+postgres - 添加models.db并提供PostreSQL数据库依赖&lt;/li&gt;
&lt;li&gt;+mysql - 添加models.db并提供mysql依赖&lt;/li&gt;
&lt;li&gt;+mongodb - 添加db.core并提供MongoDB依赖&lt;/li&gt;
&lt;li&gt;+site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2&lt;/li&gt;
&lt;li&gt;+dailycred -
添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架&lt;/li&gt;
&lt;li&gt;+http-kit - 添加HTTP Kit支持&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;要添加配置，只需要简单的添加到你的应用的名字后面，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +cljs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以多个参数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +site +postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生
成的文件。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;HTTP Kit notes&lt;/h1&gt;

&lt;p&gt;HTTP Kit是一个嵌入式的服务器。与Jetty不同的是，HTTP Kit并不被lein-ring
支持。所以你需要这样来运行HTTP Kit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能热部署，你需要使用-dev选项，并且可以自定义端口号。默认端口号是8080
要打包一个可运行的HTTP Kit的jar不包，使用如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein uberjar
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Profiles&lt;/h1&gt;

&lt;p&gt;使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。&lt;/p&gt;

&lt;p&gt;下面就是各个配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+cljs - 添加ClojureScript支持&lt;/li&gt;
&lt;li&gt;+cucumber - 提供通过clj-webdriver配置cucumber&lt;/li&gt;
&lt;li&gt;+h2 - 添加models.db并提供H2数据库依赖&lt;/li&gt;
&lt;li&gt;+postgres - 添加models.db并提供PostreSQL数据库依赖&lt;/li&gt;
&lt;li&gt;+mysql - 添加models.db并提供mysql依赖&lt;/li&gt;
&lt;li&gt;+mongodb - 添加db.core并提供MongoDB依赖&lt;/li&gt;
&lt;li&gt;+site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2&lt;/li&gt;
&lt;li&gt;+dailycred -
添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架&lt;/li&gt;
&lt;li&gt;+http-kit - 添加HTTP Kit支持&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;要添加配置，只需要简单的添加到你的应用的名字后面，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +cljs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以多个参数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +site +postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生
成的文件。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;HTTP Kit notes&lt;/h1&gt;

&lt;p&gt;HTTP Kit是一个嵌入式的服务器。与Jetty不同的是，HTTP Kit并不被lein-ring
支持。所以你需要这样来运行HTTP Kit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能热部署，你需要使用-dev选项，并且可以自定义端口号。默认端口号是8080
要打包一个可运行的HTTP Kit的jar不包，使用如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein uberjar
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-第一个应用</title>
        <link href="http://ivanpig.github.io/2013/09/14/your_first_application.html"/>
        <updated>2013-09-14T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/14/your_first_application</id>
        <content type="html">&lt;h1&gt;Guestbook应用&lt;/h1&gt;

&lt;p&gt;此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构.&lt;/p&gt;

&lt;h1&gt;安装Leiningen&lt;/h1&gt;

&lt;p&gt;首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载脚本&lt;/li&gt;
&lt;li&gt;将其设置为可执行权限(chmod +x lein)&lt;/li&gt;
&lt;li&gt;将脚本放到你的PATH下面&lt;/li&gt;
&lt;li&gt;运行lein self-install ，然后等待安装结束&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod +x lein
mv lein ~/bin
lein self-install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建一个新应用&lt;/h1&gt;

&lt;p&gt;安装完Leiningen后，你就可以在命令行中输入如下的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein new luminus guestbook +h2
cd guestbook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。现在我们就可以运行这个项目了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server
guestbook started successfully...
2013-03-01 19:05:30.389:INFO:oejs.Server:jetty-7.6.1.v20120215
Started server on port 3000
2013-03-01 19:05:30.459:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器会自动打开，你将能看到运行的应用。如果你不想浏览器自动打开，你可以用下面的命令来启动项目.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以自定义端口号，命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless 8000
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;剖析Luminus应用&lt;/h1&gt;

&lt;p&gt;新创建的项目的目录结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;example&quot;&gt;Procfile
README.md
project.clj
src
  └ log4j.xml
    guestbook
       └ handler.clj
         util.clj
         repl.clj
         models
           └ db.clj
             schema.clj
          routes
           └ home.clj
          views
           └ layout.clj
           └ templates
              └ about.html
                base.html
                home.html
test
  └ guestbook
       └ test
           └ handler.clj
resources
  └ public
       └ css
           └ screen.css
             img
             js
             md
              └ docs.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来看一看根目录下的文件的作用:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Procfile - 部署相关信息&lt;/li&gt;
&lt;li&gt;README.md - 项目相关的文档&lt;/li&gt;
&lt;li&gt;project.clj - 用于管理项目的配置以及Leiningen依赖关系&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;源代码目录&lt;/h1&gt;

&lt;p&gt;所有的代码都在src目录下。我们的应用名称叫guestbook，这个名字同时也是源代码的根命名空间。让我们来看一下源代码目录下所有的命名空间。&lt;/p&gt;

&lt;h2&gt;guestbook&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;handler.clj - 定义了应用最基本的路由。这是应用的入口。我们自定义的所有的页面都需要在这里添加各自的路由定义。&lt;/li&gt;
&lt;li&gt;layout.clj - 页面布局帮助命名空间&lt;/li&gt;
&lt;li&gt;middleware.clj - 中间件命名空间&lt;/li&gt;
&lt;li&gt;repl.clj - 提供了从REPL启动和停止应用的函数&lt;/li&gt;
&lt;li&gt;util.clj - 提供了常用的帮助类函数，比较常用的是md-&gt;html的帮助函数&lt;/li&gt;
&lt;li&gt;log4j.xml - Korma的日志配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.db&lt;/h2&gt;

&lt;p&gt;db命名空间下定义的是应用所使用的model以及持久化相关操作.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;core.clj - 包含一组可以和数据库交互的函数&lt;/li&gt;
&lt;li&gt;schema.clj - 用来定义数据库连接参数以及数据表&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.routes&lt;/h2&gt;

&lt;p&gt;routes命名空间是存放路由以及controller的地方。当你要添加路由的时候，比如安全验证，特殊流程等等，你需要在这里创建他们。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;home.clj - 一个定义了home和about页面的命名空间&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;测试目录&lt;/h1&gt;

&lt;p&gt;这里是放置测试代码的地方。该目录下已经有样例测试代码。&lt;/p&gt;

&lt;h1&gt;资源目录&lt;/h1&gt;

&lt;p&gt;这里是存放静态资源的地方。包括css,javascript,images和markdown.&lt;/p&gt;

&lt;h2&gt;HTML模板&lt;/h2&gt;

&lt;p&gt;这个命名空间存放的是Selmer模板文件，用于应用页面的展示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;about.html - about页面&lt;/li&gt;
&lt;li&gt;base.html - base页面&lt;/li&gt;
&lt;li&gt;home.html - home页面&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;添加依赖&lt;/h1&gt;

&lt;p&gt;上面已经说过了，项目所有的依赖关系都是由project.clj来管理的。这个文件看起来像这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defproject
  guestbook &quot;0.1.0-SNAPSHOT&quot;

  :url &quot;http://example.com/FIXME&quot;
  :description &quot;FIXME: write description&quot;

  :dependencies
  [[com.h2database/h2 &quot;1.4.178&quot;]
   [ring-server &quot;0.3.1&quot;]
   [environ &quot;1.0.0&quot;]
   [com.taoensso/timbre &quot;3.2.1&quot;]
   [markdown-clj &quot;0.9.55&quot;]
   [korma &quot;0.4.0&quot;]
   [com.taoensso/tower &quot;2.0.2&quot;]
   [selmer &quot;0.7.2&quot;]
   [org.clojure/clojure &quot;1.6.0&quot;]
   [log4j
    &quot;1.2.17&quot;
    :exclusions
    [javax.mail/mail
     javax.jms/jms
     com.sun.jdmk/jmxtools
     com.sun.jmx/jmxri]]
   [compojure &quot;1.2.1&quot;]
   [lib-noir &quot;0.9.4&quot;]]

  :plugins
  [[lein-ring &quot;0.8.13&quot;] [lein-environ &quot;1.0.0&quot;]]

  :ring
  {:handler guestbook.handler/app,
   :init guestbook.handler/init,
   :destroy guestbook.handler/destroy}

  :profiles
  {:uberjar {:aot :all}
   :production
   {:ring
    {:open-browser? false, :stacktraces? false, :auto-reload? false}},
   :dev
   {:dependencies [[ring-mock &quot;0.1.5&quot;] [ring/ring-devel &quot;1.2.2&quot;]],
    :env {:dev true}}}

  :min-lein-version &quot;2.0.0&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;project.clj就是个简单的Clojure的list，这个list中包含了键值对，描述了应用的方方面面。如果你要添加自定义依赖，只需要简单的将需要的依赖添加到:dependencies这个vector内。&lt;/p&gt;

&lt;h1&gt;访问数据库&lt;/h1&gt;

&lt;p&gt;首先，我们来创建一个model。我们需要编辑位于src/guestbook/db目录下的schema.clj文件。
这这个文件中，已经定义了数据库连接。定义的方式就是使用了一个包含了jdbc驱动，协议，用户名和密码的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.schema
  (:require [clojure.java.jdbc :as sql]
            [clojure.java.io :refer [file]]
            [noir.io :as io]))

(def db-store (str (.getName (file &quot;.&quot;)) &quot;/site.db&quot;))

(def db-spec {:classname &quot;org.h2.Driver&quot;
              :subprotocol &quot;h2&quot;
              :subname db-store
              :user &quot;sa&quot;
              :password &quot;&quot;
              :make-pool? true
              :naming {:keys clojure.string/lower-case
                       :fields clojure.string/upper-case}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;紧接着是一个叫做create-users-table的函数。这是用来定义名字叫做users的
数据表的。我们替换掉这个函数，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-guestbook-table []
  (sql/db-do-commands
    db-spec
    (sql/create-table-ddl
      :guestbook
      [:id &quot;INTEGER PRIMARY KEY AUTO_INCREMENT&quot;]
      [:timestamp :timestamp]
      [:name &quot;varchar(30)&quot;]
      [:message &quot;varchar(200)&quot;]))
  (sql/db-do-prepared db-spec
      &quot;CREATE INDEX timestamp_index ON guestbook (timestamp)&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数定义了guestbook数据表结构。同时我们修改create-tables函数来调用它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-tables
  &quot;creates the database tables used by the application&quot;
  []
  (create-guestbook-table))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据表创建完成后，我们就可以来读写留言信息了。让我们打开core.clj文件。同样的，文件里已经有了一些代码，我们需要替换它们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.core
  (:use korma.core
        [korma.db :only (defdb)])
  (:require [guestbook.db.schema :as schema]))

(defdb db schema/db-spec)

(defentity guestbook)

(defn save-message
  [name message]
  (insert guestbook
          (values {:name name
                   :message message
                   :timestamp (new java.util.Date)})))

(defn get-messages []
  (select guestbook))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们创建了一个实体来映射guestbook数据表。然后创建了save-message和get-message来操作它.&lt;/p&gt;

&lt;h1&gt;启动时运行&lt;/h1&gt;

&lt;p&gt;hander命名空间中包含了一个叫做init的函数。这个函数只会在应用启动的时候调用一次。让我们来添加一些代码来验证数据库是否在应用启动前初始化成功。
为了能够使用initialized?和create-tables函数，我们需要一个指向schema命名空间的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.handler
  (:use ...)
  (:require ...
            [guestbook.db.schema :as schema]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们修改init函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;init will be called once when
   app is deployed as a servlet on
   an app server such as Tomcat
   put any initialization code here&quot;
  []
  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/appender-fn})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;guestbook.log&quot; :max-size (* 512 1024) :backlog 10})

  (if (env :selmer-dev) (parser/cache-off!))

  ;;initialize the database if needed
  (when-not (schema/initialized?)
    (schema/create-tables))

  (timbre/info &quot;guestbook started successfully&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们修改了init函数，我们就需要重启应用。使用CTRL+c来停止应用，再输入lein ring server来启动应用。&lt;/p&gt;

&lt;h1&gt;创建表单页面&lt;/h1&gt;

&lt;p&gt;应用的路由是定义在guestbook.routes.home命名空间下的。我们来打开它，并添加一些逻辑。首先，需要添加db命名空间.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.routes.home
  (:use ...)
  (:require ...
            [guestbook.db.core :as db]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后呢，我们会修改home-page这个controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn home-page [&amp;amp; [name message error]]
  (layout/render &quot;home.html&quot;
                 {:error    error
                  :name     name
                  :message  message
                  :messages (db/get-messages)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们所做的就是多传递了几个参数给模板，其中一个是从数据库中查询到的信息.&lt;/p&gt;

&lt;p&gt;我们提供了用户可以发布新留言的功能，所以我们需要在controller中来处理这
个请求:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn save-message [name message]
  (cond

    (empty? name)
    (home-page name message &quot;Somebody forgot to leave a name&quot;)

    (empty? message)
    (home-page name message &quot;Don't you have something to say?&quot;)

    :else
    (do
      (db/save-message name message)
      (home-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后呢，在home-routes定义里面添加这个controller的路由定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes home-routes
  (GET &quot;/&quot; [] (home-page))
  (POST &quot;/&quot; [name message] (save-message name message))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;controller已经编写OK。我们打开处于resources/templates下的home.html模板,目前只是简单的显示内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Time to start building your site!&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;http://luminusweb.net&quot;&amp;gt;Learn more &amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
    { {content|safe}}
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们改为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
      &amp;lt;ul&amp;gt;
      { % for item in messages %}
        &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
        &amp;lt;/li&amp;gt;
      { % endfor %}
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了迭代器来遍历信息。而每个迭代结果都是一个包含了信息的map。我们能通过名字来访问它们。同时，我们使用了一个日期过滤器来生成一个适于人类阅读的时间. 接着我们来添加错误信息的展示.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只是简单的检查了一下是否有错误信息，如果有就展示。最后我们创建一个form来接受用户提交留言.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，home.html看起来像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;guestbook/views/templates/base.html&quot; %}

{ % block content %}
    &amp;lt;ul&amp;gt;
    { % for item in messages %}
      &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
      &amp;lt;/li&amp;gt;
    { % endfor %}
    &amp;lt;/ul&amp;gt;

{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}

&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以修改位于resources/public/css目录下的screen.css来使得页面更好看一些.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.css}&quot;&gt;body {
    height: 100%;
    padding-top: 70px;
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #eaeaea;
    color: #4d4d4d;
    width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-font-smoothing: antialiased;
    -ms-font-smoothing: antialiased;
    -o-font-smoothing: antialiased;
    font-smoothing: antialiased;
}

input[type=submit] {
    margin: 0;
    padding: 0;
    border: 0;
  line-height: 1.4em;
    background: none;
    vertical-align: baseline;
}

input[type=submit], textarea {
    font-size: 24px;
    font-family: inherit;
    border: 0;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -o-box-sizing: border-box;
    box-sizing: border-box;
}

input[type=submit]:hover {
    background: rgba(0, 0, 0, 0.15);
    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.3);
}

textarea {
    position: relative;
    line-height: 1em;
    width: 100%;
}

.error {
  font-weight: bold;
    color: red;
}

.jumbotron {
    position: relative;
    background: white;
    z-index: 2;
    border-top: 1px dotted #adadad;
}

h1 {
    width: 100%;
    font-size: 70px;
    font-weight: bold;
    text-align: center;
}

ul {
    margin: 0;
    padding: 0;
    list-style: none;
}

li {
    position: relative;
    font-size: 16px;
    padding: 5px;
    border-bottom: 1px dotted #ccc;
  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

li:last-child {
    border-bottom: none;
}

li time {
    font-size: 12px;
    padding-bottom: 20px;
}

form:before, .error:before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    height: 15px;
    border-bottom: 1px solid #6c615c;
    background: #8d7d77;
}

form, .error {
    width: 520px;
    padding: 30px;
    margin-bottom: 50px;
    background: #fff;
    border: 1px solid #ccc;
    position: relative;
    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

form input {
    width: 50%;
    clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在刷新页面就可以看到我们修改的内容了。试试留个言！&lt;/p&gt;

&lt;h1&gt;打包应用&lt;/h1&gt;

&lt;p&gt;要打包程序，可输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会创建一个可运行的jar。通过下面的命令来运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;java -jar target/guestbook-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想把应用部署到tomcat这样的服务器上，你可以运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会打包一个war包。&lt;/p&gt;

&lt;p&gt;完整的源代码可以到&lt;a href=&quot;https://github.com/yogthos/guestbook&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Guestbook应用&lt;/h1&gt;

&lt;p&gt;此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构.&lt;/p&gt;

&lt;h1&gt;安装Leiningen&lt;/h1&gt;

&lt;p&gt;首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载脚本&lt;/li&gt;
&lt;li&gt;将其设置为可执行权限(chmod +x lein)&lt;/li&gt;
&lt;li&gt;将脚本放到你的PATH下面&lt;/li&gt;
&lt;li&gt;运行lein self-install ，然后等待安装结束&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod +x lein
mv lein ~/bin
lein self-install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建一个新应用&lt;/h1&gt;

&lt;p&gt;安装完Leiningen后，你就可以在命令行中输入如下的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein new luminus guestbook +h2
cd guestbook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。现在我们就可以运行这个项目了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server
guestbook started successfully...
2013-03-01 19:05:30.389:INFO:oejs.Server:jetty-7.6.1.v20120215
Started server on port 3000
2013-03-01 19:05:30.459:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器会自动打开，你将能看到运行的应用。如果你不想浏览器自动打开，你可以用下面的命令来启动项目.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以自定义端口号，命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless 8000
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;剖析Luminus应用&lt;/h1&gt;

&lt;p&gt;新创建的项目的目录结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;example&quot;&gt;Procfile
README.md
project.clj
src
  └ log4j.xml
    guestbook
       └ handler.clj
         util.clj
         repl.clj
         models
           └ db.clj
             schema.clj
          routes
           └ home.clj
          views
           └ layout.clj
           └ templates
              └ about.html
                base.html
                home.html
test
  └ guestbook
       └ test
           └ handler.clj
resources
  └ public
       └ css
           └ screen.css
             img
             js
             md
              └ docs.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来看一看根目录下的文件的作用:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Procfile - 部署相关信息&lt;/li&gt;
&lt;li&gt;README.md - 项目相关的文档&lt;/li&gt;
&lt;li&gt;project.clj - 用于管理项目的配置以及Leiningen依赖关系&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;源代码目录&lt;/h1&gt;

&lt;p&gt;所有的代码都在src目录下。我们的应用名称叫guestbook，这个名字同时也是源代码的根命名空间。让我们来看一下源代码目录下所有的命名空间。&lt;/p&gt;

&lt;h2&gt;guestbook&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;handler.clj - 定义了应用最基本的路由。这是应用的入口。我们自定义的所有的页面都需要在这里添加各自的路由定义。&lt;/li&gt;
&lt;li&gt;layout.clj - 页面布局帮助命名空间&lt;/li&gt;
&lt;li&gt;middleware.clj - 中间件命名空间&lt;/li&gt;
&lt;li&gt;repl.clj - 提供了从REPL启动和停止应用的函数&lt;/li&gt;
&lt;li&gt;util.clj - 提供了常用的帮助类函数，比较常用的是md-&gt;html的帮助函数&lt;/li&gt;
&lt;li&gt;log4j.xml - Korma的日志配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.db&lt;/h2&gt;

&lt;p&gt;db命名空间下定义的是应用所使用的model以及持久化相关操作.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;core.clj - 包含一组可以和数据库交互的函数&lt;/li&gt;
&lt;li&gt;schema.clj - 用来定义数据库连接参数以及数据表&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.routes&lt;/h2&gt;

&lt;p&gt;routes命名空间是存放路由以及controller的地方。当你要添加路由的时候，比如安全验证，特殊流程等等，你需要在这里创建他们。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;home.clj - 一个定义了home和about页面的命名空间&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;测试目录&lt;/h1&gt;

&lt;p&gt;这里是放置测试代码的地方。该目录下已经有样例测试代码。&lt;/p&gt;

&lt;h1&gt;资源目录&lt;/h1&gt;

&lt;p&gt;这里是存放静态资源的地方。包括css,javascript,images和markdown.&lt;/p&gt;

&lt;h2&gt;HTML模板&lt;/h2&gt;

&lt;p&gt;这个命名空间存放的是Selmer模板文件，用于应用页面的展示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;about.html - about页面&lt;/li&gt;
&lt;li&gt;base.html - base页面&lt;/li&gt;
&lt;li&gt;home.html - home页面&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;添加依赖&lt;/h1&gt;

&lt;p&gt;上面已经说过了，项目所有的依赖关系都是由project.clj来管理的。这个文件看起来像这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defproject
  guestbook &quot;0.1.0-SNAPSHOT&quot;

  :url &quot;http://example.com/FIXME&quot;
  :description &quot;FIXME: write description&quot;

  :dependencies
  [[com.h2database/h2 &quot;1.4.178&quot;]
   [ring-server &quot;0.3.1&quot;]
   [environ &quot;1.0.0&quot;]
   [com.taoensso/timbre &quot;3.2.1&quot;]
   [markdown-clj &quot;0.9.55&quot;]
   [korma &quot;0.4.0&quot;]
   [com.taoensso/tower &quot;2.0.2&quot;]
   [selmer &quot;0.7.2&quot;]
   [org.clojure/clojure &quot;1.6.0&quot;]
   [log4j
    &quot;1.2.17&quot;
    :exclusions
    [javax.mail/mail
     javax.jms/jms
     com.sun.jdmk/jmxtools
     com.sun.jmx/jmxri]]
   [compojure &quot;1.2.1&quot;]
   [lib-noir &quot;0.9.4&quot;]]

  :plugins
  [[lein-ring &quot;0.8.13&quot;] [lein-environ &quot;1.0.0&quot;]]

  :ring
  {:handler guestbook.handler/app,
   :init guestbook.handler/init,
   :destroy guestbook.handler/destroy}

  :profiles
  {:uberjar {:aot :all}
   :production
   {:ring
    {:open-browser? false, :stacktraces? false, :auto-reload? false}},
   :dev
   {:dependencies [[ring-mock &quot;0.1.5&quot;] [ring/ring-devel &quot;1.2.2&quot;]],
    :env {:dev true}}}

  :min-lein-version &quot;2.0.0&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;project.clj就是个简单的Clojure的list，这个list中包含了键值对，描述了应用的方方面面。如果你要添加自定义依赖，只需要简单的将需要的依赖添加到:dependencies这个vector内。&lt;/p&gt;

&lt;h1&gt;访问数据库&lt;/h1&gt;

&lt;p&gt;首先，我们来创建一个model。我们需要编辑位于src/guestbook/db目录下的schema.clj文件。
这这个文件中，已经定义了数据库连接。定义的方式就是使用了一个包含了jdbc驱动，协议，用户名和密码的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.schema
  (:require [clojure.java.jdbc :as sql]
            [clojure.java.io :refer [file]]
            [noir.io :as io]))

(def db-store (str (.getName (file &quot;.&quot;)) &quot;/site.db&quot;))

(def db-spec {:classname &quot;org.h2.Driver&quot;
              :subprotocol &quot;h2&quot;
              :subname db-store
              :user &quot;sa&quot;
              :password &quot;&quot;
              :make-pool? true
              :naming {:keys clojure.string/lower-case
                       :fields clojure.string/upper-case}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;紧接着是一个叫做create-users-table的函数。这是用来定义名字叫做users的
数据表的。我们替换掉这个函数，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-guestbook-table []
  (sql/db-do-commands
    db-spec
    (sql/create-table-ddl
      :guestbook
      [:id &quot;INTEGER PRIMARY KEY AUTO_INCREMENT&quot;]
      [:timestamp :timestamp]
      [:name &quot;varchar(30)&quot;]
      [:message &quot;varchar(200)&quot;]))
  (sql/db-do-prepared db-spec
      &quot;CREATE INDEX timestamp_index ON guestbook (timestamp)&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数定义了guestbook数据表结构。同时我们修改create-tables函数来调用它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-tables
  &quot;creates the database tables used by the application&quot;
  []
  (create-guestbook-table))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据表创建完成后，我们就可以来读写留言信息了。让我们打开core.clj文件。同样的，文件里已经有了一些代码，我们需要替换它们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.core
  (:use korma.core
        [korma.db :only (defdb)])
  (:require [guestbook.db.schema :as schema]))

(defdb db schema/db-spec)

(defentity guestbook)

(defn save-message
  [name message]
  (insert guestbook
          (values {:name name
                   :message message
                   :timestamp (new java.util.Date)})))

(defn get-messages []
  (select guestbook))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们创建了一个实体来映射guestbook数据表。然后创建了save-message和get-message来操作它.&lt;/p&gt;

&lt;h1&gt;启动时运行&lt;/h1&gt;

&lt;p&gt;hander命名空间中包含了一个叫做init的函数。这个函数只会在应用启动的时候调用一次。让我们来添加一些代码来验证数据库是否在应用启动前初始化成功。
为了能够使用initialized?和create-tables函数，我们需要一个指向schema命名空间的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.handler
  (:use ...)
  (:require ...
            [guestbook.db.schema :as schema]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们修改init函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;init will be called once when
   app is deployed as a servlet on
   an app server such as Tomcat
   put any initialization code here&quot;
  []
  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/appender-fn})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;guestbook.log&quot; :max-size (* 512 1024) :backlog 10})

  (if (env :selmer-dev) (parser/cache-off!))

  ;;initialize the database if needed
  (when-not (schema/initialized?)
    (schema/create-tables))

  (timbre/info &quot;guestbook started successfully&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们修改了init函数，我们就需要重启应用。使用CTRL+c来停止应用，再输入lein ring server来启动应用。&lt;/p&gt;

&lt;h1&gt;创建表单页面&lt;/h1&gt;

&lt;p&gt;应用的路由是定义在guestbook.routes.home命名空间下的。我们来打开它，并添加一些逻辑。首先，需要添加db命名空间.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.routes.home
  (:use ...)
  (:require ...
            [guestbook.db.core :as db]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后呢，我们会修改home-page这个controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn home-page [&amp;amp; [name message error]]
  (layout/render &quot;home.html&quot;
                 {:error    error
                  :name     name
                  :message  message
                  :messages (db/get-messages)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们所做的就是多传递了几个参数给模板，其中一个是从数据库中查询到的信息.&lt;/p&gt;

&lt;p&gt;我们提供了用户可以发布新留言的功能，所以我们需要在controller中来处理这
个请求:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn save-message [name message]
  (cond

    (empty? name)
    (home-page name message &quot;Somebody forgot to leave a name&quot;)

    (empty? message)
    (home-page name message &quot;Don't you have something to say?&quot;)

    :else
    (do
      (db/save-message name message)
      (home-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后呢，在home-routes定义里面添加这个controller的路由定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes home-routes
  (GET &quot;/&quot; [] (home-page))
  (POST &quot;/&quot; [name message] (save-message name message))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;controller已经编写OK。我们打开处于resources/templates下的home.html模板,目前只是简单的显示内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Time to start building your site!&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;http://luminusweb.net&quot;&amp;gt;Learn more &amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
    { {content|safe}}
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们改为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
      &amp;lt;ul&amp;gt;
      { % for item in messages %}
        &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
        &amp;lt;/li&amp;gt;
      { % endfor %}
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了迭代器来遍历信息。而每个迭代结果都是一个包含了信息的map。我们能通过名字来访问它们。同时，我们使用了一个日期过滤器来生成一个适于人类阅读的时间. 接着我们来添加错误信息的展示.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只是简单的检查了一下是否有错误信息，如果有就展示。最后我们创建一个form来接受用户提交留言.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，home.html看起来像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;guestbook/views/templates/base.html&quot; %}

{ % block content %}
    &amp;lt;ul&amp;gt;
    { % for item in messages %}
      &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
      &amp;lt;/li&amp;gt;
    { % endfor %}
    &amp;lt;/ul&amp;gt;

{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}

&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以修改位于resources/public/css目录下的screen.css来使得页面更好看一些.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.css}&quot;&gt;body {
    height: 100%;
    padding-top: 70px;
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #eaeaea;
    color: #4d4d4d;
    width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-font-smoothing: antialiased;
    -ms-font-smoothing: antialiased;
    -o-font-smoothing: antialiased;
    font-smoothing: antialiased;
}

input[type=submit] {
    margin: 0;
    padding: 0;
    border: 0;
  line-height: 1.4em;
    background: none;
    vertical-align: baseline;
}

input[type=submit], textarea {
    font-size: 24px;
    font-family: inherit;
    border: 0;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -o-box-sizing: border-box;
    box-sizing: border-box;
}

input[type=submit]:hover {
    background: rgba(0, 0, 0, 0.15);
    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.3);
}

textarea {
    position: relative;
    line-height: 1em;
    width: 100%;
}

.error {
  font-weight: bold;
    color: red;
}

.jumbotron {
    position: relative;
    background: white;
    z-index: 2;
    border-top: 1px dotted #adadad;
}

h1 {
    width: 100%;
    font-size: 70px;
    font-weight: bold;
    text-align: center;
}

ul {
    margin: 0;
    padding: 0;
    list-style: none;
}

li {
    position: relative;
    font-size: 16px;
    padding: 5px;
    border-bottom: 1px dotted #ccc;
  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

li:last-child {
    border-bottom: none;
}

li time {
    font-size: 12px;
    padding-bottom: 20px;
}

form:before, .error:before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    height: 15px;
    border-bottom: 1px solid #6c615c;
    background: #8d7d77;
}

form, .error {
    width: 520px;
    padding: 30px;
    margin-bottom: 50px;
    background: #fff;
    border: 1px solid #ccc;
    position: relative;
    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

form input {
    width: 50%;
    clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在刷新页面就可以看到我们修改的内容了。试试留个言！&lt;/p&gt;

&lt;h1&gt;打包应用&lt;/h1&gt;

&lt;p&gt;要打包程序，可输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会创建一个可运行的jar。通过下面的命令来运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;java -jar target/guestbook-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想把应用部署到tomcat这样的服务器上，你可以运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会打包一个war包。&lt;/p&gt;

&lt;p&gt;完整的源代码可以到&lt;a href=&quot;https://github.com/yogthos/guestbook&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第十五章 注解</title>
        <link href="http://ivanpig.github.io/2013/03/17/scala_exercises_15.html"/>
        <updated>2013-03-17T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/17/scala_exercises_15</id>
        <content type="html">&lt;h1&gt;注解&lt;/h1&gt;

&lt;h2&gt;编写四个JUnit测试用例，分别使用带或不带某个参数的@Test注解。用JUnit执行这些测试&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import org.junit.Test

class ScalaTest {

  @Test
  def test1(){
    print(&quot;test1&quot;)
  }

  @Test(timeout = 1L)
  def test2(){
    print(&quot;test2&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;@deprecated
class Test{

  @deprecated
  val t = _;

  @deprecated(message = &quot;unuse&quot;)
  def hello(){
    println(&quot;hello&quot;)
  }
}

@deprecated
object Test extends App{
  val t = new Test()
  t.hello()
  t.t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;Scala类库中的哪些注解用到了元注解@param,@field,@getter,@setter,@beanGetter或@beanSetter?&lt;/h2&gt;

&lt;p&gt;看Scala注解的源码就OK了&lt;/p&gt;

&lt;h2&gt;编写一个Scala方法sum,带有可变长度的整型参数，返回所有参数之和。从Java调用该方法。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import annotation.varargs

class Test{

  @varargs
  def sum(n : Int*)={
    n.sum
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Hello {

    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.sum(1,2,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

class Test{

  def read()={
    Source.fromFile(&quot;test.txt&quot;).mkString
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Hello {
    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.read());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true，打印消息，然后退出。而另一个线程不停的检查该字段是否为true。如果是，它将打印一个消息并退出。如果不是，则它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？&lt;/h2&gt;

&lt;p&gt;这里只有一个线程修改Boolean字段，所以字段是否为volatile应该是没有区别的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.actors.Actor

class T1(obj:Obj) extends Actor{
  def act() {
    println(&quot;T1 is waiting&quot;)
    Thread.sleep(5000)
    obj.flag = true
    println(&quot;T1 set flag = true&quot;)
  }
}

class T2(obj:Obj) extends Actor{
  def act() {
    var f = true
    while (f){
      if(obj.flag){
        println(&quot;T2 is end&quot;)
        f = false
      }else{
        println(&quot;T2 is waiting&quot;)
        Thread.sleep(1000)
      }
    }
  }
}

class Obj{
//  @volatile
  var flag : Boolean = false
}

object Test{
  def main(args: Array[String]) {
    val obj = new Obj()
    val t1 = new T1(obj)
    val t2 = new T2(obj)
    t1.start()
    t2.start()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;给出一个示例，展示如果方法可被重写，则尾递归优化为非法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import annotation.tailrec

class Test{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译报错,修改如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import annotation.tailrec

object Test extends App{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }

  println(sum2(1 to 1000000,0))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;将allDifferent方法添加到对象，编译并检查字节码。@specialized注解产生了哪些方法?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test{
  def allDifferent[@specialized T](x:T,y:T,z:T) = x != y &amp;amp;&amp;amp; x!= z &amp;amp;&amp;amp; y != z
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;javap Test$得到&lt;/p&gt;

&lt;h1&gt;+begin_src java&lt;/h1&gt;

&lt;p&gt;public final class Test$ extends java.lang.Object{ public static final
Test\$ MODULE\$; public static {}; public boolean
allDifferent(java.lang.Object, java.lang.Object, java.lang.Ob ject);
public boolean allDifferent\$mZc\$sp(boolean, boolean, boolean); public
boolean allDifferent\$mBc\$sp(byte, byte, byte); public boolean
allDifferent\$mCc\$sp(char, char, char); public boolean
allDifferent\$mDc\$sp(double, double, double); public boolean
allDifferent\$mFc\$sp(float, float, float); public boolean
allDifferent\$mIc\$sp(int, int, int); public boolean
allDifferent\$mJc\$sp(long, long, long); public boolean
allDifferent\$mSc\$sp(short, short, short); public boolean
allDifferent\$mVc\$sp(scala.runtime.BoxedUnit, scala.runtime.Bo xedUnit,
scala.runtime.BoxedUnit); }&lt;/p&gt;

&lt;p&gt;#+end~src~&lt;/p&gt;

&lt;h2&gt;Range.foreach方法被注解为@specialized(Unit)。为什么？通过以下命令检查字节码:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;javap -classpath /path/to/scala/lib/scala-library.jar scala.collection.immutable.Range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并考虑Function1上的@specialized注解。点击Scaladoc中的Function1.scala链接进行查看
首先来看Function1的源码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;......
trait Function1[@specialized(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/) -T1, @specialized(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/) +R] extends AnyRef { self =&amp;gt;
  /** Apply the body of this function to the argument.
   *  @return   the result of function application.
   */
  def apply(v1: T1): R
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double
再来看Range.foreach的源码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;......
@inline final override def foreach[@specialized(Unit) U](f: Int =&amp;gt; U) {
    if (validateRangeBoundaries(f)) {
      var i = start
      val terminal = terminalElement
      val step = this.step
      while (i != terminal) {
        f(i)
        i += step
      }
    }
  }
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double
如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值&lt;/p&gt;

&lt;h2&gt;添加assert(n &gt;= 0)到factorial方法。在启用断言的情况下编译并校验factorial(-1)会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test {
  def factorial(n: Int): Int = {
    assert(n &amp;gt; 0)
    n
  }

  def main(args: Array[String]) {
    factorial(-1)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译报错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;Exception in thread &quot;main&quot; java.lang.AssertionError: assertion failed
    at scala.Predef$.assert(Predef.scala:165)
    at Test$.factorial(Test.scala:6)
    at Test$.main(Test.scala:11)
    at Test.main(Test.scala)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;禁用assert&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;-Xelide-below 2011
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反编译此类javap -c Test\$ 得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;......
public int factorial(int);
  Code:
   0:   getstatic       #19; //Field scala/Predef$.MODULE$:Lscala/Predef$;
   3:   iload_1
   4:   iconst_0
   5:   if_icmple       12
   8:   iconst_1
   9:   goto    13
   12:  iconst_0
   13:  invokevirtual   #23; //Method scala/Predef$.assert:(Z)V
   16:  iload_1
   17:  ireturn
......
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;注解&lt;/h1&gt;

&lt;h2&gt;编写四个JUnit测试用例，分别使用带或不带某个参数的@Test注解。用JUnit执行这些测试&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import org.junit.Test

class ScalaTest {

  @Test
  def test1(){
    print(&quot;test1&quot;)
  }

  @Test(timeout = 1L)
  def test2(){
    print(&quot;test2&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;@deprecated
class Test{

  @deprecated
  val t = _;

  @deprecated(message = &quot;unuse&quot;)
  def hello(){
    println(&quot;hello&quot;)
  }
}

@deprecated
object Test extends App{
  val t = new Test()
  t.hello()
  t.t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;Scala类库中的哪些注解用到了元注解@param,@field,@getter,@setter,@beanGetter或@beanSetter?&lt;/h2&gt;

&lt;p&gt;看Scala注解的源码就OK了&lt;/p&gt;

&lt;h2&gt;编写一个Scala方法sum,带有可变长度的整型参数，返回所有参数之和。从Java调用该方法。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import annotation.varargs

class Test{

  @varargs
  def sum(n : Int*)={
    n.sum
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Hello {

    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.sum(1,2,3));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

class Test{

  def read()={
    Source.fromFile(&quot;test.txt&quot;).mkString
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;public class Hello {
    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.read());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true，打印消息，然后退出。而另一个线程不停的检查该字段是否为true。如果是，它将打印一个消息并退出。如果不是，则它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？&lt;/h2&gt;

&lt;p&gt;这里只有一个线程修改Boolean字段，所以字段是否为volatile应该是没有区别的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.actors.Actor

class T1(obj:Obj) extends Actor{
  def act() {
    println(&quot;T1 is waiting&quot;)
    Thread.sleep(5000)
    obj.flag = true
    println(&quot;T1 set flag = true&quot;)
  }
}

class T2(obj:Obj) extends Actor{
  def act() {
    var f = true
    while (f){
      if(obj.flag){
        println(&quot;T2 is end&quot;)
        f = false
      }else{
        println(&quot;T2 is waiting&quot;)
        Thread.sleep(1000)
      }
    }
  }
}

class Obj{
//  @volatile
  var flag : Boolean = false
}

object Test{
  def main(args: Array[String]) {
    val obj = new Obj()
    val t1 = new T1(obj)
    val t2 = new T2(obj)
    t1.start()
    t2.start()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;给出一个示例，展示如果方法可被重写，则尾递归优化为非法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import annotation.tailrec

class Test{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译报错,修改如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import annotation.tailrec

object Test extends App{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }

  println(sum2(1 to 1000000,0))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;将allDifferent方法添加到对象，编译并检查字节码。@specialized注解产生了哪些方法?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test{
  def allDifferent[@specialized T](x:T,y:T,z:T) = x != y &amp;amp;&amp;amp; x!= z &amp;amp;&amp;amp; y != z
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;javap Test$得到&lt;/p&gt;

&lt;h1&gt;+begin_src java&lt;/h1&gt;

&lt;p&gt;public final class Test$ extends java.lang.Object{ public static final
Test\$ MODULE\$; public static {}; public boolean
allDifferent(java.lang.Object, java.lang.Object, java.lang.Ob ject);
public boolean allDifferent\$mZc\$sp(boolean, boolean, boolean); public
boolean allDifferent\$mBc\$sp(byte, byte, byte); public boolean
allDifferent\$mCc\$sp(char, char, char); public boolean
allDifferent\$mDc\$sp(double, double, double); public boolean
allDifferent\$mFc\$sp(float, float, float); public boolean
allDifferent\$mIc\$sp(int, int, int); public boolean
allDifferent\$mJc\$sp(long, long, long); public boolean
allDifferent\$mSc\$sp(short, short, short); public boolean
allDifferent\$mVc\$sp(scala.runtime.BoxedUnit, scala.runtime.Bo xedUnit,
scala.runtime.BoxedUnit); }&lt;/p&gt;

&lt;p&gt;#+end~src~&lt;/p&gt;

&lt;h2&gt;Range.foreach方法被注解为@specialized(Unit)。为什么？通过以下命令检查字节码:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;javap -classpath /path/to/scala/lib/scala-library.jar scala.collection.immutable.Range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并考虑Function1上的@specialized注解。点击Scaladoc中的Function1.scala链接进行查看
首先来看Function1的源码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;......
trait Function1[@specialized(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/) -T1, @specialized(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/) +R] extends AnyRef { self =&amp;gt;
  /** Apply the body of this function to the argument.
   *  @return   the result of function application.
   */
  def apply(v1: T1): R
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double
再来看Range.foreach的源码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;......
@inline final override def foreach[@specialized(Unit) U](f: Int =&amp;gt; U) {
    if (validateRangeBoundaries(f)) {
      var i = start
      val terminal = terminalElement
      val step = this.step
      while (i != terminal) {
        f(i)
        i += step
      }
    }
  }
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double
如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值&lt;/p&gt;

&lt;h2&gt;添加assert(n &gt;= 0)到factorial方法。在启用断言的情况下编译并校验factorial(-1)会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test {
  def factorial(n: Int): Int = {
    assert(n &amp;gt; 0)
    n
  }

  def main(args: Array[String]) {
    factorial(-1)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译报错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;Exception in thread &quot;main&quot; java.lang.AssertionError: assertion failed
    at scala.Predef$.assert(Predef.scala:165)
    at Test$.factorial(Test.scala:6)
    at Test$.main(Test.scala:11)
    at Test.main(Test.scala)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;禁用assert&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;-Xelide-below 2011
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反编译此类javap -c Test\$ 得到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;......
public int factorial(int);
  Code:
   0:   getstatic       #19; //Field scala/Predef$.MODULE$:Lscala/Predef$;
   3:   iload_1
   4:   iconst_0
   5:   if_icmple       12
   8:   iconst_1
   9:   goto    13
   12:  iconst_0
   13:  invokevirtual   #23; //Method scala/Predef$.assert:(Z)V
   16:  iload_1
   17:  ireturn
......
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第十四章 模式匹配和样例类</title>
        <link href="http://ivanpig.github.io/2013/03/16/scala_exercises_14.html"/>
        <updated>2013-03-16T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/16/scala_exercises_14</id>
        <content type="html">&lt;h1&gt;模式匹配和样例类&lt;/h1&gt;

&lt;h2&gt;JDK发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签(用正则表达式case [^:]+:)。然后查找以//开头并包含[Ff]alls?thr的注释，捕获类似// Falls through或// just fall thru这样的注释。假定JDK的程序员们遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？&lt;/h2&gt;

&lt;p&gt;没读懂题意。。。。&lt;/p&gt;

&lt;h2&gt;利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def swap[S,T](tup: (S,T)) = {
    tup match {
        case (a ,b) =&amp;gt; (b,a)
    }
}

println(swap[String,Int]((&quot;1&quot;,2)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;利用模式匹配，编写一个swap函数，交换数组中的前两个元素的位置，前提条件是数组长度至少为2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def swap(arr: Array[String]) = {
  arr match {
    case Array(a,b, ar @ _*) =&amp;gt; Array(b,a) ++ ar
    case _ =&amp;gt; arr
  }
}

println(swap(Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)).mkString)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;添加一个样例类Multiple，作为Item的子类。举例来说，Multiple(10,Article(&quot;Blackwell Toster&quot;,29.95))描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item，无论是Bundle还是另一个Multiple。扩展price函数以应对新的样例。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;abstract class Item

case class Multiple(num : Int,item : Item) extends Item

case class Article(description : String , price : Double) extends Item
case class Bundle(description : String , discount : Double , item : Item*) extends Item

object Test extends App{

  def price(it : Item) : Double = it match {
      case Article(_,p) =&amp;gt; p
      case Bundle(_,disc,its @ _*) =&amp;gt; its.map(price _).sum - disc
      case Multiple(n,it) =&amp;gt; n * price(it)
  }

  val p = price(Multiple(10,Article(&quot;Blackwell Toster&quot;,29.95)))
  println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5))描述的是如下这样一棵树:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;      *
    / | \
   *  2  *
 /  \    |
3   8    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val l: List[Any] = List(List(3, 8), 2, List(5))

def leafSum(list: List[Any]): Int = {

  var total = 0

  list.foreach {
    lst =&amp;gt;
      lst match {
        case l: List[Any] =&amp;gt; total += leafSum(l)
        case i: Int =&amp;gt; total += i
      }
  }
  total
}

println(leafSum(l))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value : Int) extends BinaryTree
case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写一个函数计算所有叶子节点中的元素之和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value : Int) extends BinaryTree
case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree

val r = Node(Leaf(3),Node(Leaf(3),Leaf(9)))

def leafSum(tree: BinaryTree): Int = {

      tree match {
        case Node(a,b) =&amp;gt; leafSum(a) + leafSum(b)
        case Leaf(v) =&amp;gt; v
      }

}

println(leafSum(r))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展前一个练习中的树，使得每个节点可以有任意多的后代，并重新实现leafSum函数。第五题中的树应该能够通过下述代码表示：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;Node(Node(Leaf(3),Leaf(8)),Leaf(2),Node(Leaf(5)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value: Int) extends BinaryTree
case class Node(tr: BinaryTree*) extends BinaryTree

object Test extends App {

  val r = Node(Node(Leaf(3), Leaf(8)), Leaf(2), Node(Leaf(5)))

  def leafSum(tree: BinaryTree): Int = {
    tree match {
      case Node(r @ _*) =&amp;gt; r.map(leafSum).sum
      case Leaf(v) =&amp;gt; v
    }
  }

  println(leafSum(r))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;      +
    / | \
   *  2  -
 /  \    |
3   8    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这棵树的值为(3 * 8) + 2 + (-5) = 21&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value: Int) extends BinaryTree
case class Node(ch : Char , tr: BinaryTree*) extends BinaryTree

object Test extends App {

  val r = Node('+' , Node('*',Leaf(3), Leaf(8)), Leaf(2), Node('-' , Leaf(5)))


  def eval(tree: BinaryTree): Int = {
    tree match {
      case Node(c : Char , r @ _*) =&amp;gt; if( c == '+') r.map(eval).sum else if (c == '*') r.map(eval).reduceLeft(_ * _) else r.map(eval).foldLeft(0)(_ - _)
      case Leaf(v) =&amp;gt; v
    }
  }

println(eval(r))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数，计算List[Option[Int]]中所有非None值之和。不得使用match语句。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val l : List[Option[Int]] = List(Option(-1),None,Option(2))
println(l.map(_.getOrElse(0)).sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数，将两个类型为Double=&gt;Option[Double]的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def f(x : Double) = if ( x &amp;gt;= 0) Some(sqrt(x)) else None
def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None
val h = compose(f,g)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;h(2)将得到Some(1)，而h(1)和h(0)将得到None&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.sqrt

def f(x : Double) = if ( x &amp;gt;= 0) Some(sqrt(x)) else None
def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None
val h = compose(f,g)

def compose(f : (Double =&amp;gt; Option[Double]), g : (Double =&amp;gt; Option[Double])):(Double =&amp;gt; Option[Double])={
  (x : Double) =&amp;gt;
    if (f(x) == None || g(x) == None) None
    else g(x)
}

println(h(2))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;模式匹配和样例类&lt;/h1&gt;

&lt;h2&gt;JDK发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签(用正则表达式case [^:]+:)。然后查找以//开头并包含[Ff]alls?thr的注释，捕获类似// Falls through或// just fall thru这样的注释。假定JDK的程序员们遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？&lt;/h2&gt;

&lt;p&gt;没读懂题意。。。。&lt;/p&gt;

&lt;h2&gt;利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def swap[S,T](tup: (S,T)) = {
    tup match {
        case (a ,b) =&amp;gt; (b,a)
    }
}

println(swap[String,Int]((&quot;1&quot;,2)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;利用模式匹配，编写一个swap函数，交换数组中的前两个元素的位置，前提条件是数组长度至少为2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def swap(arr: Array[String]) = {
  arr match {
    case Array(a,b, ar @ _*) =&amp;gt; Array(b,a) ++ ar
    case _ =&amp;gt; arr
  }
}

println(swap(Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)).mkString)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;添加一个样例类Multiple，作为Item的子类。举例来说，Multiple(10,Article(&quot;Blackwell Toster&quot;,29.95))描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item，无论是Bundle还是另一个Multiple。扩展price函数以应对新的样例。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;abstract class Item

case class Multiple(num : Int,item : Item) extends Item

case class Article(description : String , price : Double) extends Item
case class Bundle(description : String , discount : Double , item : Item*) extends Item

object Test extends App{

  def price(it : Item) : Double = it match {
      case Article(_,p) =&amp;gt; p
      case Bundle(_,disc,its @ _*) =&amp;gt; its.map(price _).sum - disc
      case Multiple(n,it) =&amp;gt; n * price(it)
  }

  val p = price(Multiple(10,Article(&quot;Blackwell Toster&quot;,29.95)))
  println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5))描述的是如下这样一棵树:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;      *
    / | \
   *  2  *
 /  \    |
3   8    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val l: List[Any] = List(List(3, 8), 2, List(5))

def leafSum(list: List[Any]): Int = {

  var total = 0

  list.foreach {
    lst =&amp;gt;
      lst match {
        case l: List[Any] =&amp;gt; total += leafSum(l)
        case i: Int =&amp;gt; total += i
      }
  }
  total
}

println(leafSum(l))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value : Int) extends BinaryTree
case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写一个函数计算所有叶子节点中的元素之和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value : Int) extends BinaryTree
case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree

val r = Node(Leaf(3),Node(Leaf(3),Leaf(9)))

def leafSum(tree: BinaryTree): Int = {

      tree match {
        case Node(a,b) =&amp;gt; leafSum(a) + leafSum(b)
        case Leaf(v) =&amp;gt; v
      }

}

println(leafSum(r))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展前一个练习中的树，使得每个节点可以有任意多的后代，并重新实现leafSum函数。第五题中的树应该能够通过下述代码表示：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;Node(Node(Leaf(3),Leaf(8)),Leaf(2),Node(Leaf(5)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value: Int) extends BinaryTree
case class Node(tr: BinaryTree*) extends BinaryTree

object Test extends App {

  val r = Node(Node(Leaf(3), Leaf(8)), Leaf(2), Node(Leaf(5)))

  def leafSum(tree: BinaryTree): Int = {
    tree match {
      case Node(r @ _*) =&amp;gt; r.map(leafSum).sum
      case Leaf(v) =&amp;gt; v
    }
  }

  println(leafSum(r))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;      +
    / | \
   *  2  -
 /  \    |
3   8    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这棵树的值为(3 * 8) + 2 + (-5) = 21&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;sealed abstract class BinaryTree
case class Leaf(value: Int) extends BinaryTree
case class Node(ch : Char , tr: BinaryTree*) extends BinaryTree

object Test extends App {

  val r = Node('+' , Node('*',Leaf(3), Leaf(8)), Leaf(2), Node('-' , Leaf(5)))


  def eval(tree: BinaryTree): Int = {
    tree match {
      case Node(c : Char , r @ _*) =&amp;gt; if( c == '+') r.map(eval).sum else if (c == '*') r.map(eval).reduceLeft(_ * _) else r.map(eval).foldLeft(0)(_ - _)
      case Leaf(v) =&amp;gt; v
    }
  }

println(eval(r))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数，计算List[Option[Int]]中所有非None值之和。不得使用match语句。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val l : List[Option[Int]] = List(Option(-1),None,Option(2))
println(l.map(_.getOrElse(0)).sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数，将两个类型为Double=&gt;Option[Double]的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def f(x : Double) = if ( x &amp;gt;= 0) Some(sqrt(x)) else None
def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None
val h = compose(f,g)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;h(2)将得到Some(1)，而h(1)和h(0)将得到None&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.sqrt

def f(x : Double) = if ( x &amp;gt;= 0) Some(sqrt(x)) else None
def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None
val h = compose(f,g)

def compose(f : (Double =&amp;gt; Option[Double]), g : (Double =&amp;gt; Option[Double])):(Double =&amp;gt; Option[Double])={
  (x : Double) =&amp;gt;
    if (f(x) == None || g(x) == None) None
    else g(x)
}

println(h(2))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第十三章 集合</title>
        <link href="http://ivanpig.github.io/2013/03/15/scala_exercises_13.html"/>
        <updated>2013-03-15T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/15/scala_exercises_13</id>
        <content type="html">&lt;h1&gt;集合&lt;/h1&gt;

&lt;h2&gt;编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说：indexes(&quot;Mississippi&quot;)应返回一个映射，让'M'对应集{0}，'i'对应集{1,4,7,10}，依此类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？&lt;/h2&gt;

&lt;p&gt;更新scala到版本2.10.0。有可变的可排序的Set，实际上还是TreeSet&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.{Map,HashMap,SortedSet}

def indexs(str:String):Map[Char,SortedSet[Int]]={
  var map = new HashMap[Char, SortedSet[Int]]();
  var i = 0;
  str.foreach{
    c=&amp;gt;
      map.get(c) match{
        case Some(result) =&amp;gt; map(c) = result + i
        case None =&amp;gt; map += (c-&amp;gt; SortedSet{i})
      }
      i += 1
  }
  map
}

println(indexs(&quot;Mississippi&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重复前一个练习，这次用字符到列表的不可变映射。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.immutable.HashMap
import collection.mutable.ListBuffer

def indexs(str:String):Map[Char,ListBuffer[Int]]={
  var map = new HashMap[Char, ListBuffer[Int]]()
  var i = 0
  str.foreach{
    c=&amp;gt;
      map.get(c) match{
        case Some(result) =&amp;gt; result += i
        case None =&amp;gt; map += (c-&amp;gt; ListBuffer{i})
      }
      i += 1
  }
  map
}

println(indexs(&quot;Mississippi&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写一个函数，从一个整型链表中去除所有的零值。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def removeZero(nums : List[Int]):List[Int]={
  nums.filter(_ != 0)
}

println(removeZero(List(3,5,0,2,7,0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。返回整型的集合，其值为能和集合中某个字符串相对应的映射的值。举例来说，给定Array(&quot;Tom&quot;,&quot;Fred&quot;,&quot;Harry&quot;)和Map(&quot;Tom&quot;-&gt;3,&quot;Dick&quot;-&gt;4,&quot;Harry&quot;-&gt;5)，返回Array(3,5)。提示：用flatMap将get返回的Option值组合在一起&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def strMap(strArr : Array[String],map : Map[String,Int]) : Array[Int] = {
  strArr.flatMap(map.get(_))
}

val a = Array(&quot;Tom&quot;,&quot;Fred&quot;,&quot;Harry&quot;)
val m = Map(&quot;Tom&quot;-&amp;gt;3,&quot;Dick&quot;-&amp;gt;4,&quot;Harry&quot;-&amp;gt;5)
println(strMap(a,m).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个函数，作用与mkString相同，使用reduceLeft。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable

trait MyMkString{
  this:mutable.Iterable[String]=&amp;gt;
  def myMkString = if( this != Nil) this.reduceLeft(_ + _)
}

var a = new mutable.HashSet[String] with MyMkString

a += &quot;1&quot;
a += &quot;2&quot;
a += &quot;3&quot;

println(a.myMkString)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;给定整型列表lst,(lst : List&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;)(_ :: _ )得到什么?(List&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt; /: lst)(_ :+ _)又得到什么？如何修改它们中的一个，以对原列表进行反向排序？&lt;/h2&gt;

&lt;p&gt;得到的结果和lst相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val lst = List(1,2,3,4,5)

println((lst :\ List[Int]())(_ :: _))

println((List[Int]() /: lst)((a,b) =&amp;gt; b :: a))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在13.11节中，表达式(prices zip quantities) map { p =&gt; p._1 * p._2}有些不够优雅。我们不能用(prices zip quantities) map { _ * _}，因为 _ * _ 是一个带两个参数的函数，而我们需要的是一个带单个类型为元组的参数的函数，Function对象的tupled方法可以将带两个参数的函数改为以元俎为参数的函数。将tupled应用于乘法函数，以使我们可以用它来映射由对偶组成的列表。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val prices = List(5.0,20.0,9.95)
val quantities = List(10,2,1)

println((prices zip quantities) map { Function.tupled(_ * _) })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数。将Double数组转换成二维数组。传入列数作为参数。举例来说，Array(1,2,3,4,5,6)和三列，返回Array(Array(1,2,3),Array(4,5,6))。用grouped方法。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def divArr(arr:Array[Double],i:Int)={
  arr.grouped(i).toArray
}

val arr = Array(1.0,2,3,4,5,6)

divArr(arr,3).foreach(a =&amp;gt; println(a.mkString(&quot;,&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Harry Hacker写了一个从命令行接受一系列文件名的程序。对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val frequencies = new scala.collection.multable.HashMap[Char,Int]
                  with scala.collection.mutable.SynchronizedMap[Char,Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当读到字母c时，他调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;frequencies(c) = frequencies.getOrElse(c,0) + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么这样做得不到正确答案？如果他用如下方式实现呢：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.collection.JavaConversions.asScalaConcurrentMap
val frequencies:scala.collection.mutable.ConcurrentMap[Char,Int] =
               new java.util.concurrent.ConcurrentHashMap[Char,Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并发问题，并发修改集合不安全.修改后的代码和修改前的代码没有什么太大的区别.&lt;/p&gt;

&lt;h2&gt;Harry Hacker把文件读取到字符串中，然后想对字符串的不同部分用并行集合来并发地更新字母出现频率映射。他用了如下代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val frequencies = new scala.collection.mutable.HashMap[Char,Int]
for(c &amp;lt;- str.par) frequencies(c) = frequencies.getOrElse(c,0) + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate）
并行修改共享变量，结果无法估计。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;
import scala.collection.immutable.HashMap

val str = &quot;abcabcac&quot;

val frequencies = str.par.aggregate(HashMap[Char,Int]())(
    {
        (a,b) =&amp;gt;
        a + (b -&amp;gt; (a.getOrElse(b,0) + 1))
    }
    ,
    {
    (map1,map2) =&amp;gt;
    (map1.keySet ++ map2.keySet).foldLeft( HashMap[Char,Int]() ) {
         (result,k) =&amp;gt;
           result + ( k -&amp;gt; ( map1.getOrElse(k,0 ) + map2.getOrElse(k,0) ) )
       }
    }
)

println(frequencies)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;集合&lt;/h1&gt;

&lt;h2&gt;编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说：indexes(&quot;Mississippi&quot;)应返回一个映射，让'M'对应集{0}，'i'对应集{1,4,7,10}，依此类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？&lt;/h2&gt;

&lt;p&gt;更新scala到版本2.10.0。有可变的可排序的Set，实际上还是TreeSet&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.{Map,HashMap,SortedSet}

def indexs(str:String):Map[Char,SortedSet[Int]]={
  var map = new HashMap[Char, SortedSet[Int]]();
  var i = 0;
  str.foreach{
    c=&amp;gt;
      map.get(c) match{
        case Some(result) =&amp;gt; map(c) = result + i
        case None =&amp;gt; map += (c-&amp;gt; SortedSet{i})
      }
      i += 1
  }
  map
}

println(indexs(&quot;Mississippi&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重复前一个练习，这次用字符到列表的不可变映射。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.immutable.HashMap
import collection.mutable.ListBuffer

def indexs(str:String):Map[Char,ListBuffer[Int]]={
  var map = new HashMap[Char, ListBuffer[Int]]()
  var i = 0
  str.foreach{
    c=&amp;gt;
      map.get(c) match{
        case Some(result) =&amp;gt; result += i
        case None =&amp;gt; map += (c-&amp;gt; ListBuffer{i})
      }
      i += 1
  }
  map
}

println(indexs(&quot;Mississippi&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写一个函数，从一个整型链表中去除所有的零值。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def removeZero(nums : List[Int]):List[Int]={
  nums.filter(_ != 0)
}

println(removeZero(List(3,5,0,2,7,0)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。返回整型的集合，其值为能和集合中某个字符串相对应的映射的值。举例来说，给定Array(&quot;Tom&quot;,&quot;Fred&quot;,&quot;Harry&quot;)和Map(&quot;Tom&quot;-&gt;3,&quot;Dick&quot;-&gt;4,&quot;Harry&quot;-&gt;5)，返回Array(3,5)。提示：用flatMap将get返回的Option值组合在一起&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def strMap(strArr : Array[String],map : Map[String,Int]) : Array[Int] = {
  strArr.flatMap(map.get(_))
}

val a = Array(&quot;Tom&quot;,&quot;Fred&quot;,&quot;Harry&quot;)
val m = Map(&quot;Tom&quot;-&amp;gt;3,&quot;Dick&quot;-&amp;gt;4,&quot;Harry&quot;-&amp;gt;5)
println(strMap(a,m).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个函数，作用与mkString相同，使用reduceLeft。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable

trait MyMkString{
  this:mutable.Iterable[String]=&amp;gt;
  def myMkString = if( this != Nil) this.reduceLeft(_ + _)
}

var a = new mutable.HashSet[String] with MyMkString

a += &quot;1&quot;
a += &quot;2&quot;
a += &quot;3&quot;

println(a.myMkString)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;给定整型列表lst,(lst : List&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt;)(_ :: _ )得到什么?(List&lt;a href=&quot;&quot;&gt;Int&lt;/a&gt; /: lst)(_ :+ _)又得到什么？如何修改它们中的一个，以对原列表进行反向排序？&lt;/h2&gt;

&lt;p&gt;得到的结果和lst相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val lst = List(1,2,3,4,5)

println((lst :\ List[Int]())(_ :: _))

println((List[Int]() /: lst)((a,b) =&amp;gt; b :: a))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在13.11节中，表达式(prices zip quantities) map { p =&gt; p._1 * p._2}有些不够优雅。我们不能用(prices zip quantities) map { _ * _}，因为 _ * _ 是一个带两个参数的函数，而我们需要的是一个带单个类型为元组的参数的函数，Function对象的tupled方法可以将带两个参数的函数改为以元俎为参数的函数。将tupled应用于乘法函数，以使我们可以用它来映射由对偶组成的列表。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val prices = List(5.0,20.0,9.95)
val quantities = List(10,2,1)

println((prices zip quantities) map { Function.tupled(_ * _) })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数。将Double数组转换成二维数组。传入列数作为参数。举例来说，Array(1,2,3,4,5,6)和三列，返回Array(Array(1,2,3),Array(4,5,6))。用grouped方法。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def divArr(arr:Array[Double],i:Int)={
  arr.grouped(i).toArray
}

val arr = Array(1.0,2,3,4,5,6)

divArr(arr,3).foreach(a =&amp;gt; println(a.mkString(&quot;,&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Harry Hacker写了一个从命令行接受一系列文件名的程序。对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val frequencies = new scala.collection.multable.HashMap[Char,Int]
                  with scala.collection.mutable.SynchronizedMap[Char,Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当读到字母c时，他调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;frequencies(c) = frequencies.getOrElse(c,0) + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么这样做得不到正确答案？如果他用如下方式实现呢：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.collection.JavaConversions.asScalaConcurrentMap
val frequencies:scala.collection.mutable.ConcurrentMap[Char,Int] =
               new java.util.concurrent.ConcurrentHashMap[Char,Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并发问题，并发修改集合不安全.修改后的代码和修改前的代码没有什么太大的区别.&lt;/p&gt;

&lt;h2&gt;Harry Hacker把文件读取到字符串中，然后想对字符串的不同部分用并行集合来并发地更新字母出现频率映射。他用了如下代码：&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val frequencies = new scala.collection.mutable.HashMap[Char,Int]
for(c &amp;lt;- str.par) frequencies(c) = frequencies.getOrElse(c,0) + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate）
并行修改共享变量，结果无法估计。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;
import scala.collection.immutable.HashMap

val str = &quot;abcabcac&quot;

val frequencies = str.par.aggregate(HashMap[Char,Int]())(
    {
        (a,b) =&amp;gt;
        a + (b -&amp;gt; (a.getOrElse(b,0) + 1))
    }
    ,
    {
    (map1,map2) =&amp;gt;
    (map1.keySet ++ map2.keySet).foldLeft( HashMap[Char,Int]() ) {
         (result,k) =&amp;gt;
           result + ( k -&amp;gt; ( map1.getOrElse(k,0 ) + map2.getOrElse(k,0) ) )
       }
    }
)

println(frequencies)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第十二章 高阶函数</title>
        <link href="http://ivanpig.github.io/2013/03/14/scala_exercises_12.html"/>
        <updated>2013-03-14T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/14/scala_exercises_12</id>
        <content type="html">&lt;h1&gt;高阶函数&lt;/h1&gt;

&lt;h2&gt;编写函数values(fun:(Int)=&gt;Int,low:Int,high:Int),该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=&gt;x*x,-5,5)应该产出一个对偶的集合(-5,25),(-4,16),(-3,9),...,(5,25)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {
  def values(fun: (Int) =&amp;gt; Int, low: Int, high: Int) = {
    var arr = List[(Int,Int)]()
    low to high foreach {
      num =&amp;gt;
      arr = (num, fun(num)) :: arr
    }
    arr
  }

  println(values(x =&amp;gt; x * x, -5, 5).mkString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何用reduceLeft得到数组中的最大元素?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {
  val arr = Array(3,2,6,8,4,6,9,3,6,7,1,2)
  print(arr.reduceLeft((a,b)=&amp;gt;if (a&amp;gt;b) a else b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;用to和reduceLeft实现阶乘函数,不得使用循环或递归&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;println(1 to 10 reduceLeft(_ * _))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;前一个实现需要处理一个特殊情况，即n\&amp;lt;1的情况。展示如何用foldLeft来避免这个需要。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;println((1 to -10).foldLeft(1)(_ * _))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写函数largest(fun:(Int)=&gt;Int,inputs:Seq[Int]),输出在给定输入序列中给定函数的最大值。举例来说，largest(x=&gt;10*x-x*x,1 to 10)应该返回25.不得使用循环或递归&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  def largest(fun:(Int)=&amp;gt;Int,inputs:Seq[Int])={
    val s = inputs.reduceLeft((a,b)=&amp;gt;if (fun(a) &amp;gt; fun(b)) a else b)
    fun(s)
  }

  println(largest(x=&amp;gt;10*x-x*x,1 to 10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;修改前一个函数，返回最大的输出对应的输入。举例来说,largestAt(fun:(Int)=&gt;Int,inputs:Seq[Int])应该返回5。不得使用循环或递归&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  def largest(fun:(Int)=&amp;gt;Int,inputs:Seq[Int])={
    inputs.reduceLeft((a,b)=&amp;gt;if (fun(a) &amp;gt; fun(b)) a else b)
  }

  println(largest(x=&amp;gt;10*x-x*x,1 to 10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;要得到一个序列的对偶很容易，比如:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val pairs = (1 to 10) zip (11 to 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定你想要对这个序列做某中操作---比如，给对偶中的值求和，但是你不能直接使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;pairs.map(_ + _)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数_ + _
接受两个Int作为参数，而不是(Int,Int)对偶。编写函数adjustToPair,该函数接受一个类型为(Int,Int)=&gt;Int的函数作为参数，并返回一个等效的,
可以以对偶作为参数的函数。举例来说就是:adjustToPair(_ *
_)((6,7))应得到42。然后用这个函数通过map计算出各个对偶的元素之和&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  var list = List[Int]()

  def adjustToPair(fun:(Int,Int)=&amp;gt;Int)(tup:(Int, Int))={
     list = fun(tup._1,tup._2) :: list
     this
  }

  def map(fun:(Int,Int)=&amp;gt;Int):Int={
    list.reduceLeft(fun)
  }

  val pairs = (1 to 10) zip (11 to 20)
  for ((a,b) &amp;lt;- pairs){
    adjustToPair(_ * _)((a,b))
  }
  println(map(_ + _))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个对该方法的调用，让它帮我们判断某个字符串数组里的所有元素的长度是否和某个给定的整数数组相对应&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  val a = Array(&quot;asd&quot;,&quot;df&quot;,&quot;aadc&quot;)
  val b = Array(3,2,4)
  val c = Array(3,2,1)

  println(a.corresponds(b)(_.length == _))
  println(a.corresponds(c)(_.length == _))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;不使用柯里化实现corresponds。然后尝试从前一个练习的代码来调用。你遇到了什么问题？&lt;/h2&gt;

&lt;p&gt;没有柯里化则不能使用前一个练习里的代码方式来调用&lt;/p&gt;

&lt;h2&gt;实现一个unless控制抽象，工作机制类似if,但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  def unless(condition: =&amp;gt;Boolean)(block: =&amp;gt;Unit){
    if (!condition){
      block
    }
  }

  var x = 10
  unless(x == 0){
    x -= 1
    println(x)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要换名和柯里化&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;高阶函数&lt;/h1&gt;

&lt;h2&gt;编写函数values(fun:(Int)=&gt;Int,low:Int,high:Int),该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=&gt;x*x,-5,5)应该产出一个对偶的集合(-5,25),(-4,16),(-3,9),...,(5,25)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {
  def values(fun: (Int) =&amp;gt; Int, low: Int, high: Int) = {
    var arr = List[(Int,Int)]()
    low to high foreach {
      num =&amp;gt;
      arr = (num, fun(num)) :: arr
    }
    arr
  }

  println(values(x =&amp;gt; x * x, -5, 5).mkString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何用reduceLeft得到数组中的最大元素?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {
  val arr = Array(3,2,6,8,4,6,9,3,6,7,1,2)
  print(arr.reduceLeft((a,b)=&amp;gt;if (a&amp;gt;b) a else b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;用to和reduceLeft实现阶乘函数,不得使用循环或递归&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;println(1 to 10 reduceLeft(_ * _))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;前一个实现需要处理一个特殊情况，即n\&amp;lt;1的情况。展示如何用foldLeft来避免这个需要。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;println((1 to -10).foldLeft(1)(_ * _))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写函数largest(fun:(Int)=&gt;Int,inputs:Seq[Int]),输出在给定输入序列中给定函数的最大值。举例来说，largest(x=&gt;10*x-x*x,1 to 10)应该返回25.不得使用循环或递归&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  def largest(fun:(Int)=&amp;gt;Int,inputs:Seq[Int])={
    val s = inputs.reduceLeft((a,b)=&amp;gt;if (fun(a) &amp;gt; fun(b)) a else b)
    fun(s)
  }

  println(largest(x=&amp;gt;10*x-x*x,1 to 10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;修改前一个函数，返回最大的输出对应的输入。举例来说,largestAt(fun:(Int)=&gt;Int,inputs:Seq[Int])应该返回5。不得使用循环或递归&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  def largest(fun:(Int)=&amp;gt;Int,inputs:Seq[Int])={
    inputs.reduceLeft((a,b)=&amp;gt;if (fun(a) &amp;gt; fun(b)) a else b)
  }

  println(largest(x=&amp;gt;10*x-x*x,1 to 10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;要得到一个序列的对偶很容易，比如:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val pairs = (1 to 10) zip (11 to 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定你想要对这个序列做某中操作---比如，给对偶中的值求和，但是你不能直接使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;pairs.map(_ + _)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数_ + _
接受两个Int作为参数，而不是(Int,Int)对偶。编写函数adjustToPair,该函数接受一个类型为(Int,Int)=&gt;Int的函数作为参数，并返回一个等效的,
可以以对偶作为参数的函数。举例来说就是:adjustToPair(_ *
_)((6,7))应得到42。然后用这个函数通过map计算出各个对偶的元素之和&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  var list = List[Int]()

  def adjustToPair(fun:(Int,Int)=&amp;gt;Int)(tup:(Int, Int))={
     list = fun(tup._1,tup._2) :: list
     this
  }

  def map(fun:(Int,Int)=&amp;gt;Int):Int={
    list.reduceLeft(fun)
  }

  val pairs = (1 to 10) zip (11 to 20)
  for ((a,b) &amp;lt;- pairs){
    adjustToPair(_ * _)((a,b))
  }
  println(map(_ + _))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个对该方法的调用，让它帮我们判断某个字符串数组里的所有元素的长度是否和某个给定的整数数组相对应&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  val a = Array(&quot;asd&quot;,&quot;df&quot;,&quot;aadc&quot;)
  val b = Array(3,2,4)
  val c = Array(3,2,1)

  println(a.corresponds(b)(_.length == _))
  println(a.corresponds(c)(_.length == _))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;不使用柯里化实现corresponds。然后尝试从前一个练习的代码来调用。你遇到了什么问题？&lt;/h2&gt;

&lt;p&gt;没有柯里化则不能使用前一个练习里的代码方式来调用&lt;/p&gt;

&lt;h2&gt;实现一个unless控制抽象，工作机制类似if,但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App {

  def unless(condition: =&amp;gt;Boolean)(block: =&amp;gt;Unit){
    if (!condition){
      block
    }
  }

  var x = 10
  unless(x == 0){
    x -= 1
    println(x)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要换名和柯里化&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第十一章 操作符</title>
        <link href="http://ivanpig.github.io/2013/03/13/scala_exercises_11.html"/>
        <updated>2013-03-13T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/13/scala_exercises_11</id>
        <content type="html">&lt;h1&gt;操作符&lt;/h1&gt;

&lt;h2&gt;根据优先级规则,3 + 4 -&gt; 5和3 -&gt; 4 + 5是如何被求值的？&lt;/h2&gt;

&lt;p&gt;在REPL中执行即可得到结果。都是从左至右执行&lt;/p&gt;

&lt;h2&gt;BigInt类有一个pow方法,但没有用操作符字符。Scala类库的设计者为什么没有选用**(像Fortran那样)或者^(像Pascal那样)作为乘方操作符呢？&lt;/h2&gt;

&lt;p&gt;Scala中的操作符就是方法，其优先级是根据首字母来判断的，优先级如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;最高优先级:除以下字符外的操作符字符
 * / %
+ -
:
= !
&amp;lt; &amp;gt;
&amp;amp;
ˆ
|
非操作符
最低优先级:赋值操作符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般乘方的操作符是优于乘法操作的，如果使用**作为乘方的话，那么其优先级则与*相同，而如果使用^&lt;em&gt;的&lt;/em&gt;话，则优先级低于*操作。优先级都是有问题的。故没有使用这两种操作符&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;实现Fraction类，支持+~*~/操作。支持约分，例如将15/-6变为-5/2。除以最大公约数,像这样:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Fraction(n:Int,d:Int){
    private val num:Int = if(d==0) 1 else n * sign(d)/gcd(n,d);
    private val den:Int = if(d==0) 0 else d * sign(d)/gcd(n,d);
    override def toString = num + &quot;/&quot; + den
    def sign(a:Int) = if(a &amp;gt; 0) 1 else if (a &amp;lt; 0) -1 else 0
    def gcd(a:Int,b:Int):Int = if(b==0) abs(a) else gcd(b,a%b)
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.abs

class Fraction(n: Int, d: Int) {
  private val num: Int = if (d == 0) 1 else n * sign(d) / gcd(n, d);
  private val den: Int = if (d == 0) 0 else d * sign(d) / gcd(n, d);

  override def toString = num + &quot;/&quot; + den

  def sign(a: Int) = if (a &amp;gt; 0) 1 else if (a &amp;lt; 0) -1 else 0

  def gcd(a: Int, b: Int): Int = if (b == 0) abs(a) else gcd(b, a % b)

  def +(other:Fraction):Fraction={
    newFrac((this.num * other.den) + (other.num * this.den),this.den * other.den)
  }

  def -(other:Fraction):Fraction={
    newFrac((this.num * other.den) - (other.num * this.den),this.den * other.den)
  }

  def *(other:Fraction):Fraction={
    newFrac(this.num * other.num,this.den * other.den)
  }

  def /(other:Fraction):Fraction={
    newFrac(this.num * other.den,this.den * other.num)
  }

  private def newFrac(a:Int,b:Int):Fraction={
    val x:Int = if (b == 0) 1 else a * sign(b) / gcd(a, b);
    val y:Int = if (b == 0) 0 else b * sign(b) / gcd(a, b);
    new Fraction(x,y)
  }
}

object Test extends App{
  val f = new Fraction(15,-6)
  val p = new Fraction(20,60)
  println(f)
  println(p)
  println(f + p)
  println(f - p)
  println(f * p)
  println(f / p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个Money类,加入美元和美分字段。提供+,-操作符以及比较操作符==和\&amp;lt;。举例来说，Money(1,75)+Money(0,50)==Money(2,25)应为true。你应该同时提供*和/操作符吗？为什么？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;
class Money(val dollar:BigInt,val cent:BigInt){

  def +(other:Money):Money={
    val (a,b) = (this.cent + other.cent) /% 100
    new Money(this.dollar + other.dollar + a,b)
  }

  def -(other:Money):Money={
    val (d,c) = (this.toCent() - other.toCent()) /% 100
    new Money(d,c)
  }

  private def toCent()={
    this.dollar * 100 + this.cent
  }

  def ==(other:Money):Boolean = this.dollar == other.dollar &amp;amp;&amp;amp; this.cent == other.cent

  def &amp;lt;(other:Money):Boolean = this.dollar &amp;lt; other.dollar || (this.dollar == other.dollar &amp;amp;&amp;amp; this.cent &amp;lt; other.cent)

  override def toString = &quot;dollar = &quot; + dollar + &quot; cent = &quot; + cent
}

object Money{
  def apply(dollar:Int,cent:Int):Money={
    new Money(dollar,cent)
  }

  def main(args:Array[String]){

    val m1 = Money(1,200)
    val m2 = Money(2,2)
    println(m1 + m2)
    println(m1 - m2)
    println(m1 == m2)
    println(m1 &amp;lt; m2)
    println(Money(1,75)+Money(0,50))
    println(Money(1,75)+Money(0,50)==Money(2,25))

  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需要提供*和/操作。对于金额来说没有乘除操作&lt;/p&gt;

&lt;h2&gt;提供操作符用于构造HTML表格。例如:Table() | &quot;Java&quot; | &quot;Scala&quot; || &quot;Gosling&quot; | &quot;Odersky&quot; || &quot;JVM&quot; | &quot;JVM,.NET&quot;应产出:\&amp;lt;table&gt;\&amp;lt;tr&gt;\&amp;lt;td&gt;Java\&amp;lt;/td&gt;\&amp;lt;/tr&gt;\&amp;lt;td&gt;Scala\&amp;lt;/td&gt;\&amp;lt;/tr&gt;\&amp;lt;tr&gt;\&amp;lt;td&gt;Gosling...&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Table{

  var s:String = &quot;&quot;

  def |(str:String):Table={
    val t = Table()
    t.s = this.s + &quot;&amp;lt;td&amp;gt;&quot; + str + &quot;&amp;lt;/td&amp;gt;&quot;
    t
  }

  def ||(str:String):Table={
    val t = Table()
    t.s = this.s + &quot;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot; + str + &quot;&amp;lt;/td&amp;gt;&quot;
    t
  }

  override def toString():String={
    &quot;&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&quot; + this.s + &quot;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;&quot;
  }
}

object Table{

  def apply():Table={
    new Table()
  }

  def main(args: Array[String]) {
    println(Table() | &quot;Java&quot; | &quot;Scala&quot; || &quot;Gosling&quot; | &quot;Odersky&quot; || &quot;JVM&quot; | &quot;JVM,.NET&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提供一个ASCIIArt类，其对象包含类似这样的图形:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt; /\_/\
( ' ' )
(  -  )
 | | |
(__|__)
提供将两个ASCIIArt图形横向或纵向结合的操作符。选用适当优先级的操作符命名。纵向结合的实例
 /\_/\     -----
( ' ' )  / Hello \
(  -  ) &amp;lt;  Scala |
 | | |   \ Coder /
(__|__)    -----
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.ArrayBuffer

class ASCIIArt(str:String){
  val arr:ArrayBuffer[ArrayBuffer[String]] = new ArrayBuffer[ArrayBuffer[String]]()

  if (str != null &amp;amp;&amp;amp; !str.trim.eq(&quot;&quot;)){
    str.split(&quot;[\r\n]+&quot;).foreach{
      line =&amp;gt;
      val s = new ArrayBuffer[String]()
      s += line
      arr += s
    }
  }

  def this(){
    this(&quot;&quot;)
  }

  def +(other:ASCIIArt):ASCIIArt={
    val art = new ASCIIArt()
    val length = if (this.arr.length &amp;gt;= other.arr.length) this.arr.length else other.arr.length
    for(i &amp;lt;- 0 until length){
      val s = new ArrayBuffer[String]()
      val thisArr:ArrayBuffer[String] = if (i &amp;lt; this.arr.length) this.arr(i) else new ArrayBuffer[String]()
      val otherArr:ArrayBuffer[String] = if (i &amp;lt; other.arr.length) other.arr(i) else new ArrayBuffer[String]()
      thisArr.foreach(s += _)
      otherArr.foreach(s += _)
      art.arr += s
    }
    art
  }

  def *(other:ASCIIArt):ASCIIArt={
    val art = new ASCIIArt()
    this.arr.foreach(art.arr += _)
    other.arr.foreach(art.arr += _)
    art
  }

  override def toString()={
    var ss:String = &quot;&quot;
    arr.foreach{
      ss += _.mkString(&quot; &quot;) + &quot;\n&quot;
    }
    ss
  }
}

object Test extends App{
  val a = new ASCIIArt(&quot;&quot;&quot; /\_/\
                         |( ' ' )
                         |(  -  )
                         | | | |
                         |(__|__)
                         |&quot;&quot;&quot;.stripMargin)
  val b = new ASCIIArt( &quot;&quot;&quot;    -----
                          |  / Hello \
                          | &amp;lt;  Scala |
                          |  \ Coder /
                          |    -----
                          |&quot;&quot;&quot;.stripMargin)
  println(a + b * b)
  println((a + b) * b)
  println(a * b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个BigSequence类,将64个bit的序列打包在一个Long值中。提供apply和update操作来获取和设置某个具体的bit&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class BigSequence{
  var num = new Array[Int](64)

  for (i &amp;lt;- 0 until num.length){
    num(i) = -1
  }

  def pack():Long={
    num.filter(_ &amp;gt;= 0).mkString.toLong
  }
}

object BigSequence{

  def apply(num:Int):BigSequence={
    val b = new BigSequence
    var i = 0
    num.toString.foreach{
      n=&amp;gt;
      b.num(i) = n.getNumericValue
      i+=1
    }
    b
  }

  def main(args: Array[String]) {
    val b = BigSequence(10100)
    println(b.pack())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提供一个Matrix类---你可以选择需要的是一个2*2的矩阵，任意大小的正方形矩阵，或m*n的矩阵。支持+和*操作。*操作应同样适用于单值，例如mat*2。单个元素可以通过mat(row,col)得到&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Matrix(val x:Int,val y:Int){

  def +(other:Matrix):Matrix={
    Matrix(this.x + other.x,this.y + other.y)
  }

  def +(other:Int):Matrix={
    Matrix(this.x + other,this.y + other)
  }

  def *(other:Matrix):Matrix={
    Matrix(this.x * other.x,this.y * other.y)
  }

  def *(other:Int):Matrix={
    Matrix(this.x * other,this.y * other)
  }

  override def toString()={
    var str = &quot;&quot;
    for(i &amp;lt;- 1 to x){
      for(j &amp;lt;- 1 to y){
        str += &quot;*&quot;
      }
      str += &quot;\n&quot;
    }
    str
  }
}

object Matrix{
  def apply(x:Int,y:Int):Matrix= new Matrix(x,y)

  def main(args: Array[String]) {
    val m = Matrix(2,2)
    val n = Matrix(3,4)
    println(m)
    println(n)
    println(m + n)
    println()
    println(m * n)
    println()
    println(m + 2)
    println()
    println(n * 2)
    println()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为RichFile类定义unapply操作，提取文件路径，名称和扩展名。举例来说，文件/home/cay/readme.txt的路径为/home/cay,名称为readme,扩展名为txt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class RichFile(val path:String){}

object RichFile{
  def apply(path:String):RichFile={
    new RichFile(path)
  }

  def unapply(richFile:RichFile) = {
    if(richFile.path == null){
      None
    } else {
      val reg = &quot;([/\\w+]+)/(\\w+)\\.(\\w+)&quot;.r
      val reg(r1,r2,r3) = richFile.path
      Some((r1,r2,r3))
    }
  }

  def main(args: Array[String]) {
    val richFile = RichFile(&quot;/home/cay/readme.txt&quot;)
    val RichFile(r1,r2,r3) = richFile
    println(r1)
    println(r2)
    println(r3)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为RichFile类定义一个unapplySeq，提取所有路径段。举例来说，对于/home/cay/readme.txt，你应该产出三个路径段的序列:home,cay和readme.txt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class RichFile(val path:String){}

object RichFile{
  def apply(path:String):RichFile={
    new RichFile(path)
  }

  def unapplySeq(richFile:RichFile):Option[Seq[String]]={
    if(richFile.path == null){
      None
    } else {
      Some(richFile.path.split(&quot;/&quot;))
    }
  }

  def main(args: Array[String]) {
    val richFile = RichFile(&quot;/home/cay/readme.txt&quot;)
    val RichFile(r @ _*) = richFile
    println(r)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;操作符&lt;/h1&gt;

&lt;h2&gt;根据优先级规则,3 + 4 -&gt; 5和3 -&gt; 4 + 5是如何被求值的？&lt;/h2&gt;

&lt;p&gt;在REPL中执行即可得到结果。都是从左至右执行&lt;/p&gt;

&lt;h2&gt;BigInt类有一个pow方法,但没有用操作符字符。Scala类库的设计者为什么没有选用**(像Fortran那样)或者^(像Pascal那样)作为乘方操作符呢？&lt;/h2&gt;

&lt;p&gt;Scala中的操作符就是方法，其优先级是根据首字母来判断的，优先级如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;最高优先级:除以下字符外的操作符字符
 * / %
+ -
:
= !
&amp;lt; &amp;gt;
&amp;amp;
ˆ
|
非操作符
最低优先级:赋值操作符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般乘方的操作符是优于乘法操作的，如果使用**作为乘方的话，那么其优先级则与*相同，而如果使用^&lt;em&gt;的&lt;/em&gt;话，则优先级低于*操作。优先级都是有问题的。故没有使用这两种操作符&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;实现Fraction类，支持+~*~/操作。支持约分，例如将15/-6变为-5/2。除以最大公约数,像这样:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Fraction(n:Int,d:Int){
    private val num:Int = if(d==0) 1 else n * sign(d)/gcd(n,d);
    private val den:Int = if(d==0) 0 else d * sign(d)/gcd(n,d);
    override def toString = num + &quot;/&quot; + den
    def sign(a:Int) = if(a &amp;gt; 0) 1 else if (a &amp;lt; 0) -1 else 0
    def gcd(a:Int,b:Int):Int = if(b==0) abs(a) else gcd(b,a%b)
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.abs

class Fraction(n: Int, d: Int) {
  private val num: Int = if (d == 0) 1 else n * sign(d) / gcd(n, d);
  private val den: Int = if (d == 0) 0 else d * sign(d) / gcd(n, d);

  override def toString = num + &quot;/&quot; + den

  def sign(a: Int) = if (a &amp;gt; 0) 1 else if (a &amp;lt; 0) -1 else 0

  def gcd(a: Int, b: Int): Int = if (b == 0) abs(a) else gcd(b, a % b)

  def +(other:Fraction):Fraction={
    newFrac((this.num * other.den) + (other.num * this.den),this.den * other.den)
  }

  def -(other:Fraction):Fraction={
    newFrac((this.num * other.den) - (other.num * this.den),this.den * other.den)
  }

  def *(other:Fraction):Fraction={
    newFrac(this.num * other.num,this.den * other.den)
  }

  def /(other:Fraction):Fraction={
    newFrac(this.num * other.den,this.den * other.num)
  }

  private def newFrac(a:Int,b:Int):Fraction={
    val x:Int = if (b == 0) 1 else a * sign(b) / gcd(a, b);
    val y:Int = if (b == 0) 0 else b * sign(b) / gcd(a, b);
    new Fraction(x,y)
  }
}

object Test extends App{
  val f = new Fraction(15,-6)
  val p = new Fraction(20,60)
  println(f)
  println(p)
  println(f + p)
  println(f - p)
  println(f * p)
  println(f / p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个Money类,加入美元和美分字段。提供+,-操作符以及比较操作符==和\&amp;lt;。举例来说，Money(1,75)+Money(0,50)==Money(2,25)应为true。你应该同时提供*和/操作符吗？为什么？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;
class Money(val dollar:BigInt,val cent:BigInt){

  def +(other:Money):Money={
    val (a,b) = (this.cent + other.cent) /% 100
    new Money(this.dollar + other.dollar + a,b)
  }

  def -(other:Money):Money={
    val (d,c) = (this.toCent() - other.toCent()) /% 100
    new Money(d,c)
  }

  private def toCent()={
    this.dollar * 100 + this.cent
  }

  def ==(other:Money):Boolean = this.dollar == other.dollar &amp;amp;&amp;amp; this.cent == other.cent

  def &amp;lt;(other:Money):Boolean = this.dollar &amp;lt; other.dollar || (this.dollar == other.dollar &amp;amp;&amp;amp; this.cent &amp;lt; other.cent)

  override def toString = &quot;dollar = &quot; + dollar + &quot; cent = &quot; + cent
}

object Money{
  def apply(dollar:Int,cent:Int):Money={
    new Money(dollar,cent)
  }

  def main(args:Array[String]){

    val m1 = Money(1,200)
    val m2 = Money(2,2)
    println(m1 + m2)
    println(m1 - m2)
    println(m1 == m2)
    println(m1 &amp;lt; m2)
    println(Money(1,75)+Money(0,50))
    println(Money(1,75)+Money(0,50)==Money(2,25))

  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不需要提供*和/操作。对于金额来说没有乘除操作&lt;/p&gt;

&lt;h2&gt;提供操作符用于构造HTML表格。例如:Table() | &quot;Java&quot; | &quot;Scala&quot; || &quot;Gosling&quot; | &quot;Odersky&quot; || &quot;JVM&quot; | &quot;JVM,.NET&quot;应产出:\&amp;lt;table&gt;\&amp;lt;tr&gt;\&amp;lt;td&gt;Java\&amp;lt;/td&gt;\&amp;lt;/tr&gt;\&amp;lt;td&gt;Scala\&amp;lt;/td&gt;\&amp;lt;/tr&gt;\&amp;lt;tr&gt;\&amp;lt;td&gt;Gosling...&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Table{

  var s:String = &quot;&quot;

  def |(str:String):Table={
    val t = Table()
    t.s = this.s + &quot;&amp;lt;td&amp;gt;&quot; + str + &quot;&amp;lt;/td&amp;gt;&quot;
    t
  }

  def ||(str:String):Table={
    val t = Table()
    t.s = this.s + &quot;&amp;lt;/tr&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot; + str + &quot;&amp;lt;/td&amp;gt;&quot;
    t
  }

  override def toString():String={
    &quot;&amp;lt;table&amp;gt;&amp;lt;tr&amp;gt;&quot; + this.s + &quot;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;&quot;
  }
}

object Table{

  def apply():Table={
    new Table()
  }

  def main(args: Array[String]) {
    println(Table() | &quot;Java&quot; | &quot;Scala&quot; || &quot;Gosling&quot; | &quot;Odersky&quot; || &quot;JVM&quot; | &quot;JVM,.NET&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提供一个ASCIIArt类，其对象包含类似这样的图形:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt; /\_/\
( ' ' )
(  -  )
 | | |
(__|__)
提供将两个ASCIIArt图形横向或纵向结合的操作符。选用适当优先级的操作符命名。纵向结合的实例
 /\_/\     -----
( ' ' )  / Hello \
(  -  ) &amp;lt;  Scala |
 | | |   \ Coder /
(__|__)    -----
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.ArrayBuffer

class ASCIIArt(str:String){
  val arr:ArrayBuffer[ArrayBuffer[String]] = new ArrayBuffer[ArrayBuffer[String]]()

  if (str != null &amp;amp;&amp;amp; !str.trim.eq(&quot;&quot;)){
    str.split(&quot;[\r\n]+&quot;).foreach{
      line =&amp;gt;
      val s = new ArrayBuffer[String]()
      s += line
      arr += s
    }
  }

  def this(){
    this(&quot;&quot;)
  }

  def +(other:ASCIIArt):ASCIIArt={
    val art = new ASCIIArt()
    val length = if (this.arr.length &amp;gt;= other.arr.length) this.arr.length else other.arr.length
    for(i &amp;lt;- 0 until length){
      val s = new ArrayBuffer[String]()
      val thisArr:ArrayBuffer[String] = if (i &amp;lt; this.arr.length) this.arr(i) else new ArrayBuffer[String]()
      val otherArr:ArrayBuffer[String] = if (i &amp;lt; other.arr.length) other.arr(i) else new ArrayBuffer[String]()
      thisArr.foreach(s += _)
      otherArr.foreach(s += _)
      art.arr += s
    }
    art
  }

  def *(other:ASCIIArt):ASCIIArt={
    val art = new ASCIIArt()
    this.arr.foreach(art.arr += _)
    other.arr.foreach(art.arr += _)
    art
  }

  override def toString()={
    var ss:String = &quot;&quot;
    arr.foreach{
      ss += _.mkString(&quot; &quot;) + &quot;\n&quot;
    }
    ss
  }
}

object Test extends App{
  val a = new ASCIIArt(&quot;&quot;&quot; /\_/\
                         |( ' ' )
                         |(  -  )
                         | | | |
                         |(__|__)
                         |&quot;&quot;&quot;.stripMargin)
  val b = new ASCIIArt( &quot;&quot;&quot;    -----
                          |  / Hello \
                          | &amp;lt;  Scala |
                          |  \ Coder /
                          |    -----
                          |&quot;&quot;&quot;.stripMargin)
  println(a + b * b)
  println((a + b) * b)
  println(a * b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个BigSequence类,将64个bit的序列打包在一个Long值中。提供apply和update操作来获取和设置某个具体的bit&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class BigSequence{
  var num = new Array[Int](64)

  for (i &amp;lt;- 0 until num.length){
    num(i) = -1
  }

  def pack():Long={
    num.filter(_ &amp;gt;= 0).mkString.toLong
  }
}

object BigSequence{

  def apply(num:Int):BigSequence={
    val b = new BigSequence
    var i = 0
    num.toString.foreach{
      n=&amp;gt;
      b.num(i) = n.getNumericValue
      i+=1
    }
    b
  }

  def main(args: Array[String]) {
    val b = BigSequence(10100)
    println(b.pack())
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提供一个Matrix类---你可以选择需要的是一个2*2的矩阵，任意大小的正方形矩阵，或m*n的矩阵。支持+和*操作。*操作应同样适用于单值，例如mat*2。单个元素可以通过mat(row,col)得到&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Matrix(val x:Int,val y:Int){

  def +(other:Matrix):Matrix={
    Matrix(this.x + other.x,this.y + other.y)
  }

  def +(other:Int):Matrix={
    Matrix(this.x + other,this.y + other)
  }

  def *(other:Matrix):Matrix={
    Matrix(this.x * other.x,this.y * other.y)
  }

  def *(other:Int):Matrix={
    Matrix(this.x * other,this.y * other)
  }

  override def toString()={
    var str = &quot;&quot;
    for(i &amp;lt;- 1 to x){
      for(j &amp;lt;- 1 to y){
        str += &quot;*&quot;
      }
      str += &quot;\n&quot;
    }
    str
  }
}

object Matrix{
  def apply(x:Int,y:Int):Matrix= new Matrix(x,y)

  def main(args: Array[String]) {
    val m = Matrix(2,2)
    val n = Matrix(3,4)
    println(m)
    println(n)
    println(m + n)
    println()
    println(m * n)
    println()
    println(m + 2)
    println()
    println(n * 2)
    println()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为RichFile类定义unapply操作，提取文件路径，名称和扩展名。举例来说，文件/home/cay/readme.txt的路径为/home/cay,名称为readme,扩展名为txt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class RichFile(val path:String){}

object RichFile{
  def apply(path:String):RichFile={
    new RichFile(path)
  }

  def unapply(richFile:RichFile) = {
    if(richFile.path == null){
      None
    } else {
      val reg = &quot;([/\\w+]+)/(\\w+)\\.(\\w+)&quot;.r
      val reg(r1,r2,r3) = richFile.path
      Some((r1,r2,r3))
    }
  }

  def main(args: Array[String]) {
    val richFile = RichFile(&quot;/home/cay/readme.txt&quot;)
    val RichFile(r1,r2,r3) = richFile
    println(r1)
    println(r2)
    println(r3)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为RichFile类定义一个unapplySeq，提取所有路径段。举例来说，对于/home/cay/readme.txt，你应该产出三个路径段的序列:home,cay和readme.txt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class RichFile(val path:String){}

object RichFile{
  def apply(path:String):RichFile={
    new RichFile(path)
  }

  def unapplySeq(richFile:RichFile):Option[Seq[String]]={
    if(richFile.path == null){
      None
    } else {
      Some(richFile.path.split(&quot;/&quot;))
    }
  }

  def main(args: Array[String]) {
    val richFile = RichFile(&quot;/home/cay/readme.txt&quot;)
    val RichFile(r @ _*) = richFile
    println(r)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第十章 特质</title>
        <link href="http://ivanpig.github.io/2013/03/12/scala_exercises_10.html"/>
        <updated>2013-03-12T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/12/scala_exercises_10</id>
        <content type="html">&lt;h1&gt;特质&lt;/h1&gt;

&lt;h2&gt;java.awt.Rectangle类有两个很有用的方法translate和grow,但可惜的是像java.awt.geom.Ellipse2D这样的类没有。在Scala中，你可以解决掉这个问题。定义一个RenctangleLike特质,加入具体的translate和grow方法。提供任何你需要用来实现的抽象方法,以便你可以像如下代码这样混入该特质:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val egg = new java.awt.geom.Ellipse2D.Double(5,10,20,30) with RectangleLike
egg.translate(10,-10)
egg.grow(10,20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用自身类型使得trait可以操作x,y&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.geom.Ellipse2D


trait RectangleLike{
  this:Ellipse2D.Double=&amp;gt;
  def translate(x:Double,y:Double){
    this.x = x
    this.y = y
  }
  def grow(x:Double,y:Double){
    this.x += x
    this.y += y
  }
}

object Test extends App{
  val egg = new Ellipse2D.Double(5,10,20,30) with RectangleLike
  println(&quot;x = &quot; + egg.getX + &quot; y = &quot; + egg.getY)
  egg.translate(10,-10)
  println(&quot;x = &quot; + egg.getX + &quot; y = &quot; + egg.getY)
  egg.grow(10,20)
  println(&quot;x = &quot; + egg.getX + &quot; y = &quot; + egg.getY)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;通过把scala.math.Ordered[Point]混入java.awt.Point的方式，定义OrderedPoint类。按辞典编辑方式排序，也就是说，如果x\&amp;lt;x'或者x=x'且y\&amp;lt;y'则(x,y)\&amp;lt;(x',y')&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.Point

class OrderedPoint extends Point with Ordered[Point]{
  def compare(that: Point): Int = if (this.x &amp;lt;= that.x &amp;amp;&amp;amp; this.y &amp;lt; that.y) -1
                                   else if(this.x == that.x &amp;amp;&amp;amp; this.y == that.y) 0
                                   else 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看BitSet类,将它的所有超类和特质绘制成一张图。忽略类型参数([...]中的所有内容)。然后给出该特质的线性化规格说明&lt;/h2&gt;

&lt;p&gt;这个略&lt;/p&gt;

&lt;h2&gt;提供一个CryptoLogger类，将日志消息以凯撒密码加密。缺省情况下密匙为3，不过使用者也可以重写它。提供缺省密匙和-3作为密匙是的使用示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;trait Logger{
  def log(str:String,key:Int = 3):String
}

class CryptoLogger extends Logger{

  def log(str: String, key:Int): String = {
    for ( i &amp;lt;- str) yield if (key &amp;gt;= 0) (97 + ((i - 97 + key)%26)).toChar else (97 + ((i - 97 + 26 + key)%26)).toChar
  }
}

object Test extends App{
    val plain = &quot;chenzhen&quot;;
    println(&quot;明文为：&quot; + plain);
    println(&quot;加密后为：&quot; + new CryptoLogger().log(plain));
    println(&quot;加密后为：&quot; + new CryptoLogger().log(plain,-3));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;JavaBean规范里有一种提法叫做属性变更监听器(property change listener)，这是bean用来通知其属性变更的标准方式。PropertyChangeSupport类对于任何想要支持属性变更通知其属性变更监听器的bean而言是个便捷的超类。但可惜已有其他超类的类---比如JComponent---必须重新实现相应的方法。将PropertyChangeSupport重新实现为一个特质,然后将它混入到java.awt.Point类中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.Point
import java.beans.PropertyChangeSupport

trait PropertyChange extends PropertyChangeSupport

val p = new Point() with PropertyChange
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在Java AWT类库中,我们有一个Container类，一个可以用于各种组件的Component子类。举例来说,Button是一个Component,但Panel是Container。这是一个运转中的组合模式。Swing有JComponent和JContainer,但如果你仔细看的话，你会发现一些奇怪的细节。尽管把其他组件添加到比如JButton中毫无意义,JComponent依然扩展自Container。Swing的设计者们理想情况下应该会更倾向于图10-4中的设计。但在Java中那是不可能的。请解释这是为什么？Scala中如何用特质来设计出这样的效果?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;file:scala/01.jpg&quot; alt=&quot;&quot; /&gt;
Java只能单继承,JContainer不能同时继承自Container和JComponent。Scala可以通过特质解决这个问题.&lt;/p&gt;

&lt;h2&gt;市面上有不下数十种关于Scala特质的教程,用的都是些&quot;在叫的狗&quot;啦，&quot;讲哲学的青蛙&quot;啦之类的傻乎乎的例子。阅读和理解这些机巧的继承层级很乏味且对于理解问题没什么帮助,但自己设计一套继承层级就不同了,会很有启发。做一个你自己的关于特质的继承层级，要求体现出叠加在一起的特质,具体的和抽象的方法，以及具体的和抽象的字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;

trait Fly{
  def fly(){
    println(&quot;flying&quot;)
  }

  def flywithnowing()
}

trait Walk{
  def walk(){
    println(&quot;walk&quot;)
  }
}

class Bird{
  var name:String = _
}

class BlueBird extends Bird with Fly with Walk{
  def flywithnowing() {
    println(&quot;BlueBird flywithnowing&quot;)
  }
}

object Test extends App{
  val b = new BlueBird()
  b.walk()
  b.flywithnowing()
  b.fly()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在java.io类库中，你可以通过BufferedInputStream修饰器来给输入流增加缓冲机制。用特质来重新实现缓冲。简单起见，重写read方法&lt;/h2&gt;

&lt;p&gt;后续JavaIO详细讨论&lt;/p&gt;

&lt;h2&gt;使用本章的日志生成器特质,给前一个练习中的方案增加日志功能，要求体现缓冲的效果&lt;/h2&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h2&gt;实现一个IterableInputStream类，扩展java.io.InputStream并混入Iterable[Byte]特质&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.io.InputStream

class IterableInputStream extends InputStream with Iterable[Byte]{
  def read(): Int = 0

  def iterator: Iterator[Byte] = null
}
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;特质&lt;/h1&gt;

&lt;h2&gt;java.awt.Rectangle类有两个很有用的方法translate和grow,但可惜的是像java.awt.geom.Ellipse2D这样的类没有。在Scala中，你可以解决掉这个问题。定义一个RenctangleLike特质,加入具体的translate和grow方法。提供任何你需要用来实现的抽象方法,以便你可以像如下代码这样混入该特质:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val egg = new java.awt.geom.Ellipse2D.Double(5,10,20,30) with RectangleLike
egg.translate(10,-10)
egg.grow(10,20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用自身类型使得trait可以操作x,y&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.geom.Ellipse2D


trait RectangleLike{
  this:Ellipse2D.Double=&amp;gt;
  def translate(x:Double,y:Double){
    this.x = x
    this.y = y
  }
  def grow(x:Double,y:Double){
    this.x += x
    this.y += y
  }
}

object Test extends App{
  val egg = new Ellipse2D.Double(5,10,20,30) with RectangleLike
  println(&quot;x = &quot; + egg.getX + &quot; y = &quot; + egg.getY)
  egg.translate(10,-10)
  println(&quot;x = &quot; + egg.getX + &quot; y = &quot; + egg.getY)
  egg.grow(10,20)
  println(&quot;x = &quot; + egg.getX + &quot; y = &quot; + egg.getY)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;通过把scala.math.Ordered[Point]混入java.awt.Point的方式，定义OrderedPoint类。按辞典编辑方式排序，也就是说，如果x\&amp;lt;x'或者x=x'且y\&amp;lt;y'则(x,y)\&amp;lt;(x',y')&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.Point

class OrderedPoint extends Point with Ordered[Point]{
  def compare(that: Point): Int = if (this.x &amp;lt;= that.x &amp;amp;&amp;amp; this.y &amp;lt; that.y) -1
                                   else if(this.x == that.x &amp;amp;&amp;amp; this.y == that.y) 0
                                   else 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看BitSet类,将它的所有超类和特质绘制成一张图。忽略类型参数([...]中的所有内容)。然后给出该特质的线性化规格说明&lt;/h2&gt;

&lt;p&gt;这个略&lt;/p&gt;

&lt;h2&gt;提供一个CryptoLogger类，将日志消息以凯撒密码加密。缺省情况下密匙为3，不过使用者也可以重写它。提供缺省密匙和-3作为密匙是的使用示例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;trait Logger{
  def log(str:String,key:Int = 3):String
}

class CryptoLogger extends Logger{

  def log(str: String, key:Int): String = {
    for ( i &amp;lt;- str) yield if (key &amp;gt;= 0) (97 + ((i - 97 + key)%26)).toChar else (97 + ((i - 97 + 26 + key)%26)).toChar
  }
}

object Test extends App{
    val plain = &quot;chenzhen&quot;;
    println(&quot;明文为：&quot; + plain);
    println(&quot;加密后为：&quot; + new CryptoLogger().log(plain));
    println(&quot;加密后为：&quot; + new CryptoLogger().log(plain,-3));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;JavaBean规范里有一种提法叫做属性变更监听器(property change listener)，这是bean用来通知其属性变更的标准方式。PropertyChangeSupport类对于任何想要支持属性变更通知其属性变更监听器的bean而言是个便捷的超类。但可惜已有其他超类的类---比如JComponent---必须重新实现相应的方法。将PropertyChangeSupport重新实现为一个特质,然后将它混入到java.awt.Point类中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.Point
import java.beans.PropertyChangeSupport

trait PropertyChange extends PropertyChangeSupport

val p = new Point() with PropertyChange
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在Java AWT类库中,我们有一个Container类，一个可以用于各种组件的Component子类。举例来说,Button是一个Component,但Panel是Container。这是一个运转中的组合模式。Swing有JComponent和JContainer,但如果你仔细看的话，你会发现一些奇怪的细节。尽管把其他组件添加到比如JButton中毫无意义,JComponent依然扩展自Container。Swing的设计者们理想情况下应该会更倾向于图10-4中的设计。但在Java中那是不可能的。请解释这是为什么？Scala中如何用特质来设计出这样的效果?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;file:scala/01.jpg&quot; alt=&quot;&quot; /&gt;
Java只能单继承,JContainer不能同时继承自Container和JComponent。Scala可以通过特质解决这个问题.&lt;/p&gt;

&lt;h2&gt;市面上有不下数十种关于Scala特质的教程,用的都是些&quot;在叫的狗&quot;啦，&quot;讲哲学的青蛙&quot;啦之类的傻乎乎的例子。阅读和理解这些机巧的继承层级很乏味且对于理解问题没什么帮助,但自己设计一套继承层级就不同了,会很有启发。做一个你自己的关于特质的继承层级，要求体现出叠加在一起的特质,具体的和抽象的方法，以及具体的和抽象的字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;

trait Fly{
  def fly(){
    println(&quot;flying&quot;)
  }

  def flywithnowing()
}

trait Walk{
  def walk(){
    println(&quot;walk&quot;)
  }
}

class Bird{
  var name:String = _
}

class BlueBird extends Bird with Fly with Walk{
  def flywithnowing() {
    println(&quot;BlueBird flywithnowing&quot;)
  }
}

object Test extends App{
  val b = new BlueBird()
  b.walk()
  b.flywithnowing()
  b.fly()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在java.io类库中，你可以通过BufferedInputStream修饰器来给输入流增加缓冲机制。用特质来重新实现缓冲。简单起见，重写read方法&lt;/h2&gt;

&lt;p&gt;后续JavaIO详细讨论&lt;/p&gt;

&lt;h2&gt;使用本章的日志生成器特质,给前一个练习中的方案增加日志功能，要求体现缓冲的效果&lt;/h2&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h2&gt;实现一个IterableInputStream类，扩展java.io.InputStream并混入Iterable[Byte]特质&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.io.InputStream

class IterableInputStream extends InputStream with Iterable[Byte]{
  def read(): Int = 0

  def iterator: Iterator[Byte] = null
}
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第九章 文件和正则表达式</title>
        <link href="http://ivanpig.github.io/2013/03/11/scala_exercises_09.html"/>
        <updated>2013-03-11T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/11/scala_exercises_09</id>
        <content type="html">&lt;h1&gt;文件和正则表达式&lt;/h1&gt;

&lt;h2&gt;编写一小段Scala代码，将某个文件中的行倒转顺序(将最后一行作为第一行,依此类推)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source
import java.io.PrintWriter

val path = &quot;test.txt&quot;

val reader = Source.fromFile(path).getLines()

val result = reader.toArray.reverse

val pw = new PrintWriter(path)

result.foreach(line =&amp;gt; pw.write(line + &quot;\n&quot;))

pw.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序,从一个带有制表符的文件读取内容,将每个制表符替换成一组空格,使得制表符隔开的n列仍然保持纵向对齐,并将结果写入同一个文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source
import java.io.PrintWriter

val path = &quot;test.txt&quot;

val reader = Source.fromFile(path).getLines()

val result = for ( t &amp;lt;- reader) yield t.replaceAll(&quot;\\t&quot;,&quot;    &quot;)

val pw = new PrintWriter(path)

result.foreach(line =&amp;gt; pw.write(line + &quot;\n&quot;))

pw.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写一小段Scala代码,从一个文件读取内容并把所有字符数大于12的单词打印到控制台。如果你能用单行代码完成会有额外奖励&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

Source.fromFile(&quot;test.txt&quot;).mkString.split(&quot;\\s+&quot;).foreach(arg =&amp;gt; if(arg.length &amp;gt; 12) println(arg))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，从包含浮点数的文本文件读取内容，打印出文件中所有浮点数之和，平均值，最大值和最小值&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val nums = Source.fromFile(&quot;test.txt&quot;).mkString.split(&quot;\\s+&quot;)

var total = 0d

nums.foreach(total += _.toDouble)

println(total)
println(total/nums.length)
println(nums.max)
println(nums.min)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，向文件中写入2的n次方及其倒数，指数n从0到20。对齐各列:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;   1         1
   2         0.5
   4         0.25
 ...         ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.io.PrintWriter

val pw = new PrintWriter(&quot;test.txt&quot;)

for ( n &amp;lt;- 0 to 20){
  val t = BigDecimal(2).pow(n)
  pw.write(t.toString())
  pw.write(&quot;\t\t&quot;)
  pw.write((1/t).toString())
  pw.write(&quot;\n&quot;)
}

pw.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写正则表达式,匹配Java或C++程序代码中类似&quot;like this,maybe with &quot; or\&lt;/p&gt;

&lt;h2&gt;&quot;这样的带引号的字符串。编写Scala程序将某个源文件中所有类似的字符串打印出来&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val source = Source.fromFile(&quot;test.txt&quot;).mkString

val pattern = &quot;\\w+\\s+\&quot;&quot;.r

pattern.findAllIn(source).foreach(println)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，从文本文件读取内容，并打印出所有的非浮点数的词法单位。要求使用正则表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val source = Source.fromFile(&quot;test.txt&quot;).mkString

val pattern = &quot;&quot;&quot;[^((\d+\.){0,1}\d+)^\s+]+&quot;&quot;&quot;.r

pattern.findAllIn(source).foreach(println)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序打印出某个网页中所有img标签的src属性。使用正则表达式和分组&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val source = Source.fromFile(&quot;D:\\ProgramCodes\\ScalaTest\\src\\test.txt&quot;).mkString
val pattern = &quot;&quot;&quot;&amp;lt;img[^&amp;gt;]+(src\s*=\s*&quot;[^&amp;gt;^&quot;]+&quot;)[^&amp;gt;]*&amp;gt;&quot;&quot;&quot;.r

for (pattern(str) &amp;lt;- pattern.findAllIn(source)) println(str)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，盘点给定目录及其子目录中总共有多少以.class为扩展名的文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.io.File

val path = &quot;.&quot;

val dir = new File(path)


def subdirs(dir:File):Iterator[File]={
  val children = dir.listFiles().filter(_.getName.endsWith(&quot;class&quot;))
  children.toIterator ++ dir.listFiles().filter(_.isDirectory).toIterator.flatMap(subdirs _)
}

val n = subdirs(dir).length

println(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展那个可序列化的Person类，让它能以一个集合保存某个人的朋友信息。构造出一些Person对象，让他们中的一些人成为朋友，然后将Array[Person]保存到文件。将这个数组从文件中重新读出来，校验朋友关系是否完好&lt;/h2&gt;

&lt;p&gt;注意,请在main中执行。脚本执行无法序列化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.ArrayBuffer
import java.io.{ObjectInputStream, FileOutputStream, FileInputStream, ObjectOutputStream}

class Person(var name:String) extends Serializable{

  val friends = new ArrayBuffer[Person]()

  def addFriend(friend : Person){
    friends += friend
  }

  override def toString() = {
    var str = &quot;My name is &quot; + name + &quot; and my friends name is &quot;
    friends.foreach(str += _.name + &quot;,&quot;)
    str
  }
}


object Test extends App{
  val p1 = new Person(&quot;Ivan&quot;)
  val p2 = new Person(&quot;F2&quot;)
  val p3 = new Person(&quot;F3&quot;)

  p1.addFriend(p2)
  p1.addFriend(p3)
  println(p1)

  val out = new ObjectOutputStream(new FileOutputStream(&quot;test.txt&quot;))
  out.writeObject(p1)
  out.close()

  val in =  new ObjectInputStream(new FileInputStream(&quot;test.txt&quot;))
  val p = in.readObject().asInstanceOf[Person]
  println(p)
}
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;文件和正则表达式&lt;/h1&gt;

&lt;h2&gt;编写一小段Scala代码，将某个文件中的行倒转顺序(将最后一行作为第一行,依此类推)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source
import java.io.PrintWriter

val path = &quot;test.txt&quot;

val reader = Source.fromFile(path).getLines()

val result = reader.toArray.reverse

val pw = new PrintWriter(path)

result.foreach(line =&amp;gt; pw.write(line + &quot;\n&quot;))

pw.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序,从一个带有制表符的文件读取内容,将每个制表符替换成一组空格,使得制表符隔开的n列仍然保持纵向对齐,并将结果写入同一个文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source
import java.io.PrintWriter

val path = &quot;test.txt&quot;

val reader = Source.fromFile(path).getLines()

val result = for ( t &amp;lt;- reader) yield t.replaceAll(&quot;\\t&quot;,&quot;    &quot;)

val pw = new PrintWriter(path)

result.foreach(line =&amp;gt; pw.write(line + &quot;\n&quot;))

pw.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写一小段Scala代码,从一个文件读取内容并把所有字符数大于12的单词打印到控制台。如果你能用单行代码完成会有额外奖励&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

Source.fromFile(&quot;test.txt&quot;).mkString.split(&quot;\\s+&quot;).foreach(arg =&amp;gt; if(arg.length &amp;gt; 12) println(arg))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，从包含浮点数的文本文件读取内容，打印出文件中所有浮点数之和，平均值，最大值和最小值&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val nums = Source.fromFile(&quot;test.txt&quot;).mkString.split(&quot;\\s+&quot;)

var total = 0d

nums.foreach(total += _.toDouble)

println(total)
println(total/nums.length)
println(nums.max)
println(nums.min)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，向文件中写入2的n次方及其倒数，指数n从0到20。对齐各列:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;   1         1
   2         0.5
   4         0.25
 ...         ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.io.PrintWriter

val pw = new PrintWriter(&quot;test.txt&quot;)

for ( n &amp;lt;- 0 to 20){
  val t = BigDecimal(2).pow(n)
  pw.write(t.toString())
  pw.write(&quot;\t\t&quot;)
  pw.write((1/t).toString())
  pw.write(&quot;\n&quot;)
}

pw.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写正则表达式,匹配Java或C++程序代码中类似&quot;like this,maybe with &quot; or\&lt;/p&gt;

&lt;h2&gt;&quot;这样的带引号的字符串。编写Scala程序将某个源文件中所有类似的字符串打印出来&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val source = Source.fromFile(&quot;test.txt&quot;).mkString

val pattern = &quot;\\w+\\s+\&quot;&quot;.r

pattern.findAllIn(source).foreach(println)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，从文本文件读取内容，并打印出所有的非浮点数的词法单位。要求使用正则表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val source = Source.fromFile(&quot;test.txt&quot;).mkString

val pattern = &quot;&quot;&quot;[^((\d+\.){0,1}\d+)^\s+]+&quot;&quot;&quot;.r

pattern.findAllIn(source).foreach(println)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序打印出某个网页中所有img标签的src属性。使用正则表达式和分组&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import io.Source

val source = Source.fromFile(&quot;D:\\ProgramCodes\\ScalaTest\\src\\test.txt&quot;).mkString
val pattern = &quot;&quot;&quot;&amp;lt;img[^&amp;gt;]+(src\s*=\s*&quot;[^&amp;gt;^&quot;]+&quot;)[^&amp;gt;]*&amp;gt;&quot;&quot;&quot;.r

for (pattern(str) &amp;lt;- pattern.findAllIn(source)) println(str)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写Scala程序，盘点给定目录及其子目录中总共有多少以.class为扩展名的文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.io.File

val path = &quot;.&quot;

val dir = new File(path)


def subdirs(dir:File):Iterator[File]={
  val children = dir.listFiles().filter(_.getName.endsWith(&quot;class&quot;))
  children.toIterator ++ dir.listFiles().filter(_.isDirectory).toIterator.flatMap(subdirs _)
}

val n = subdirs(dir).length

println(n)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展那个可序列化的Person类，让它能以一个集合保存某个人的朋友信息。构造出一些Person对象，让他们中的一些人成为朋友，然后将Array[Person]保存到文件。将这个数组从文件中重新读出来，校验朋友关系是否完好&lt;/h2&gt;

&lt;p&gt;注意,请在main中执行。脚本执行无法序列化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.ArrayBuffer
import java.io.{ObjectInputStream, FileOutputStream, FileInputStream, ObjectOutputStream}

class Person(var name:String) extends Serializable{

  val friends = new ArrayBuffer[Person]()

  def addFriend(friend : Person){
    friends += friend
  }

  override def toString() = {
    var str = &quot;My name is &quot; + name + &quot; and my friends name is &quot;
    friends.foreach(str += _.name + &quot;,&quot;)
    str
  }
}


object Test extends App{
  val p1 = new Person(&quot;Ivan&quot;)
  val p2 = new Person(&quot;F2&quot;)
  val p3 = new Person(&quot;F3&quot;)

  p1.addFriend(p2)
  p1.addFriend(p3)
  println(p1)

  val out = new ObjectOutputStream(new FileOutputStream(&quot;test.txt&quot;))
  out.writeObject(p1)
  out.close()

  val in =  new ObjectInputStream(new FileInputStream(&quot;test.txt&quot;))
  val p = in.readObject().asInstanceOf[Person]
  println(p)
}
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第八章 继承</title>
        <link href="http://ivanpig.github.io/2013/03/10/scala_exercises_08.html"/>
        <updated>2013-03-10T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/10/scala_exercises_08</id>
        <content type="html">&lt;h1&gt;继承&lt;/h1&gt;

&lt;h2&gt;扩展如下的BankAccount类，新类CheckingAccount对每次存款和取款都收取1美元的手续费&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class BankAccount(initialBalance:Double){
    private var balance = initialBalance
    def deposit(amount:Double) = { balance += amount; balance}
    def withdraw(amount:Double) = {balance -= amount; balance}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继承语法的使用。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class CheckingAccount(initialBalance:Double) extends BankAccount(initialBalance){
  override def deposit(amount: Double): Double = super.deposit(amount - 1)

  override def withdraw(amount: Double): Double = super.withdraw(amount + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展前一个练习的BankAccount类，新类SavingsAccount每个月都有利息产生(earnMonthlyInterest方法被调用)，并且有每月三次免手续费的存款或取款。在earnMonthlyInterest方法中重置交易计数。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class SavingsAccount(initialBalance:Double) extends BankAccount(initialBalance){
  private var num:Int = _

  def earnMonthlyInterest()={
    num = 3
    super.deposit(1)
  }

  override def deposit(amount: Double): Double = {
    num -= 1
    if(num &amp;lt; 0) super.deposit(amount - 1) else super.deposit(amount)
  }

  override def withdraw(amount: Double): Double = {
    num -= 1
    if (num &amp;lt; 0) super.withdraw(amount + 1) else super.withdraw(amount)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;翻开你喜欢的Java或C++教科书，一定会找到用来讲解继承层级的实例，可能是员工，宠物，图形或类似的东西。用Scala来实现这个示例。&lt;/h2&gt;

&lt;p&gt;Thinking in Java中的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;class Art{
    Art(){System.out.println(&quot;Art constructor&quot;);}
}

class Drawing extends Art{
    Drawing() {System.out.println(&quot;Drawing constructor&quot;);}
}

public class Cartoon extends Drawing{
    public Cartoon() { System.out.println(&quot;Cartoon constructor&quot;);}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Scala改写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Art{
  println(&quot;Art constructor&quot;)
}

class Drawing extends Art{
  println(&quot;Drawing constructor&quot;)
}

class Cartoon extends Drawing{
  println(&quot;Cartoon constructor&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个抽象类Item,加入方法price和description。SimpleItem是一个在构造器中给出价格和描述的物件。利用val可以重写def这个事实。Bundle是一个可以包含其他物件的物件。其价格是打包中所有物件的价格之和。同时提供一个将物件添加到打包当中的机制，以及一个适合的description方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.ArrayBuffer


abstract class Item{
  def price():Double
  def description():String

  override def toString():String={
    &quot;description:&quot; + description() + &quot;  price:&quot; + price()
  }
}

class SimpleItem(val price:Double,val description:String) extends Item{

}

class Bundle extends Item{

  val items = new ArrayBuffer[Item]()

  def addItem(item:Item){
    items += item
  }

  def price(): Double = {
    var total = 0d
    items.foreach(total += _.price())
    total
  }

  def description(): String = {
    items.mkString(&quot; &quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;设计一个Point类，其x和y坐标可以通过构造器提供。提供一个子类LabeledPoint，其构造器接受一个标签值和x,y坐标,比如:new LabeledPoint(&quot;Black Thursday&quot;,1929,230.07)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Point(x:Int,y:Int){
}

class LabeledPoint(label:String,x:Int,y:Int) extends Point(x,y){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个抽象类Shape，一个抽象方法centerPoint，以及该抽象类的子类Rectangle和Circle。为子类提供合适的构造器，并重写centerPoint方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;abstract class Shape{
  def centerPoint()
}

class Rectangle(startX:Int,startY:Int,endX:Int,endY:Int) extends Shape{
  def centerPoint() {}
}

class Circle(x:Int,y:Int,radius:Double) extends Shape{
  def centerPoint() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提供一个Square类，扩展自java.awt.Rectangle并且是三个构造器：一个以给定的端点和宽度构造正方形，一个以(0,0)为端点和给定的宽度构造正方形，一个以(0,0)为端点,0为宽度构造正方形&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.{Point, Rectangle}


class Square(point:Point,width:Int) extends Rectangle(point.x,point.y,width,width){

  def this(){
    this(new Point(0,0),0)
  }

  def this(width:Int){
    this(new Point(0,0),width)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编译8.6节中的Person和SecretAgent类并使用javap分析类文件。总共有多少name的getter方法？它们分别取什么值？(提示：可以使用-c和-private选项)&lt;/h2&gt;

&lt;p&gt;总共两个。Person中取得的是传入的name,而SecretAgent中取得的是默认的&quot;secret&quot;&lt;/p&gt;

&lt;h2&gt;在8.10节的Creature类中，将val range替换成一个def。如果你在Ant子类中也用def的话会有什么效果？如果在子类中使用val又会有什么效果？为什么？&lt;/h2&gt;

&lt;p&gt;在Ant中使用def没有问题。但是如果使用val则无法编译。因为val只能重写不带参数的def。这里的def是带参数的&lt;/p&gt;

&lt;h2&gt;文件scala/collection/immutable/Stack.scala包含如下定义:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Stack[A] protected (protected val elems: List[A])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请解释protected关键字的含义。(提示：回顾我们在第5章中关于私有构造器的讨论)
此构造方法只能被其子类来调用,而不能被外界直接调用&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;继承&lt;/h1&gt;

&lt;h2&gt;扩展如下的BankAccount类，新类CheckingAccount对每次存款和取款都收取1美元的手续费&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class BankAccount(initialBalance:Double){
    private var balance = initialBalance
    def deposit(amount:Double) = { balance += amount; balance}
    def withdraw(amount:Double) = {balance -= amount; balance}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继承语法的使用。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class CheckingAccount(initialBalance:Double) extends BankAccount(initialBalance){
  override def deposit(amount: Double): Double = super.deposit(amount - 1)

  override def withdraw(amount: Double): Double = super.withdraw(amount + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展前一个练习的BankAccount类，新类SavingsAccount每个月都有利息产生(earnMonthlyInterest方法被调用)，并且有每月三次免手续费的存款或取款。在earnMonthlyInterest方法中重置交易计数。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class SavingsAccount(initialBalance:Double) extends BankAccount(initialBalance){
  private var num:Int = _

  def earnMonthlyInterest()={
    num = 3
    super.deposit(1)
  }

  override def deposit(amount: Double): Double = {
    num -= 1
    if(num &amp;lt; 0) super.deposit(amount - 1) else super.deposit(amount)
  }

  override def withdraw(amount: Double): Double = {
    num -= 1
    if (num &amp;lt; 0) super.withdraw(amount + 1) else super.withdraw(amount)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;翻开你喜欢的Java或C++教科书，一定会找到用来讲解继承层级的实例，可能是员工，宠物，图形或类似的东西。用Scala来实现这个示例。&lt;/h2&gt;

&lt;p&gt;Thinking in Java中的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.java}&quot;&gt;class Art{
    Art(){System.out.println(&quot;Art constructor&quot;);}
}

class Drawing extends Art{
    Drawing() {System.out.println(&quot;Drawing constructor&quot;);}
}

public class Cartoon extends Drawing{
    public Cartoon() { System.out.println(&quot;Cartoon constructor&quot;);}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Scala改写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Art{
  println(&quot;Art constructor&quot;)
}

class Drawing extends Art{
  println(&quot;Drawing constructor&quot;)
}

class Cartoon extends Drawing{
  println(&quot;Cartoon constructor&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个抽象类Item,加入方法price和description。SimpleItem是一个在构造器中给出价格和描述的物件。利用val可以重写def这个事实。Bundle是一个可以包含其他物件的物件。其价格是打包中所有物件的价格之和。同时提供一个将物件添加到打包当中的机制，以及一个适合的description方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import collection.mutable.ArrayBuffer


abstract class Item{
  def price():Double
  def description():String

  override def toString():String={
    &quot;description:&quot; + description() + &quot;  price:&quot; + price()
  }
}

class SimpleItem(val price:Double,val description:String) extends Item{

}

class Bundle extends Item{

  val items = new ArrayBuffer[Item]()

  def addItem(item:Item){
    items += item
  }

  def price(): Double = {
    var total = 0d
    items.foreach(total += _.price())
    total
  }

  def description(): String = {
    items.mkString(&quot; &quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;设计一个Point类，其x和y坐标可以通过构造器提供。提供一个子类LabeledPoint，其构造器接受一个标签值和x,y坐标,比如:new LabeledPoint(&quot;Black Thursday&quot;,1929,230.07)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Point(x:Int,y:Int){
}

class LabeledPoint(label:String,x:Int,y:Int) extends Point(x,y){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个抽象类Shape，一个抽象方法centerPoint，以及该抽象类的子类Rectangle和Circle。为子类提供合适的构造器，并重写centerPoint方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;abstract class Shape{
  def centerPoint()
}

class Rectangle(startX:Int,startY:Int,endX:Int,endY:Int) extends Shape{
  def centerPoint() {}
}

class Circle(x:Int,y:Int,radius:Double) extends Shape{
  def centerPoint() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提供一个Square类，扩展自java.awt.Rectangle并且是三个构造器：一个以给定的端点和宽度构造正方形，一个以(0,0)为端点和给定的宽度构造正方形，一个以(0,0)为端点,0为宽度构造正方形&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.awt.{Point, Rectangle}


class Square(point:Point,width:Int) extends Rectangle(point.x,point.y,width,width){

  def this(){
    this(new Point(0,0),0)
  }

  def this(width:Int){
    this(new Point(0,0),width)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编译8.6节中的Person和SecretAgent类并使用javap分析类文件。总共有多少name的getter方法？它们分别取什么值？(提示：可以使用-c和-private选项)&lt;/h2&gt;

&lt;p&gt;总共两个。Person中取得的是传入的name,而SecretAgent中取得的是默认的&quot;secret&quot;&lt;/p&gt;

&lt;h2&gt;在8.10节的Creature类中，将val range替换成一个def。如果你在Ant子类中也用def的话会有什么效果？如果在子类中使用val又会有什么效果？为什么？&lt;/h2&gt;

&lt;p&gt;在Ant中使用def没有问题。但是如果使用val则无法编译。因为val只能重写不带参数的def。这里的def是带参数的&lt;/p&gt;

&lt;h2&gt;文件scala/collection/immutable/Stack.scala包含如下定义:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Stack[A] protected (protected val elems: List[A])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请解释protected关键字的含义。(提示：回顾我们在第5章中关于私有构造器的讨论)
此构造方法只能被其子类来调用,而不能被外界直接调用&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第七章 包和引入</title>
        <link href="http://ivanpig.github.io/2013/03/09/scala_exercises_07.html"/>
        <updated>2013-03-09T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/09/scala_exercises_07</id>
        <content type="html">&lt;h1&gt;包和引入&lt;/h1&gt;

&lt;h2&gt;编写示例程序，展示为什么&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com.horstmann.impatient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com
package horstmann
package impatient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别使用package的效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com {
  class T1() {}

  package horstmann {
    class T2(t: T1) {}

    package impatient {
      class T3(t1: T1, t2: T2) {}
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子包里的类可以使用父包里的类。但是第一种方式不可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com.horstmann.impatient{
  class T4(t1:T1,t3:T3)      //无法找到T1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写一段让你的Scala朋友们感到困惑的代码，使用一个不在顶部的com包&lt;/h2&gt;

&lt;p&gt;这样可以吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com {
  class T1() {}

  package horstmann {
    class T2(t: T1) {}

    package impatient {
      class T3(t1: T1, t2: T2) {}
    }
  }
}

import com._

class TT(t1:T1){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个包random,加入函数nextInt():Int,nextDouble():Double,setSeed(seed:Int):Unit。生成随机数的算法采用线性同余生成器:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;后值 = (前值 * a + b)mod 2^n
其中,a = 1664525,b=1013904223,n = 32,前值的初始值为seed
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package random{
package object random{

  var seed:Int = _
  val a = BigDecimal(1664525)
  val b = BigDecimal(1013904223)
  val n = 32


  def nextInt():Int={
    val temp = (seed * a + b) % BigDecimal(2).pow(n)
    seed = temp.toInt
    seed
  }

  def nextDouble():Double={
    val temp = (seed * a + b) % BigDecimal(2).pow(n)
    seed = temp.toInt
    temp.toDouble
  }
}
}

package test {
import random.random

object Test extends App {
  random.seed = 4
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextInt())
  println(random.nextInt())
  println(random.nextInt())
  println(random.nextInt())
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在你看来Scala的设计者为什么要提供package object语法而不是简单的让你将函数和变量添加到包中呢？&lt;/h2&gt;

&lt;p&gt;JVM不支持。。。&lt;/p&gt;

&lt;h2&gt;private[com] def giveRaise(rate:Double)的含义是什么？有用吗？&lt;/h2&gt;

&lt;p&gt;除了com包可访问，其他包都不能访问。&lt;/p&gt;

&lt;h2&gt;编写一段程序,将Java哈希映射中的所有元素拷贝到Scala哈希映射。用引入语句重命名这两个类。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.util.{HashMap =&amp;gt; JavaHashMap}
import scala.collection.mutable.HashMap

object Test extends App{

  val map = new JavaHashMap[String,String]()
  map.put(&quot;1&quot;,&quot;a&quot;)
  map.put(&quot;2&quot;,&quot;b&quot;)
  map.put(&quot;3&quot;,&quot;c&quot;)

  val smap = new HashMap[String,String]()

  for(key &amp;lt;- map.keySet().toArray){
    smap += (key.toString -&amp;gt; map.get(key))
  }

  println(smap.mkString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在前一个练习中，将所有引入语句移动到尽可能小的作用域里&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App{

  import java.util.{HashMap =&amp;gt; JavaHashMap}

  val map = new JavaHashMap[String,String]()
  map.put(&quot;1&quot;,&quot;a&quot;)
  map.put(&quot;2&quot;,&quot;b&quot;)
  map.put(&quot;3&quot;,&quot;c&quot;)

  import scala.collection.mutable.HashMap

  val smap = new HashMap[String,String]()

  for(key &amp;lt;- map.keySet().toArray){
    smap += (key.toString -&amp;gt; map.get(key))
  }

  println(smap.mkString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;以下代码的作用是什么？这是个好主意吗？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java._
import javax._
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入java和javax下的所有类。而java和javax下是没有类的。所以此代码无用&lt;/p&gt;

&lt;h2&gt;编写一段程序，引入java.lang.System类，从user.name系统属性读取用户名，从Console对象读取一个密码,如果密码不是&quot;secret&quot;，则在标准错误流中打印一个消息；如果密码是&quot;secret&quot;，则在标准输出流中打印一个问候消息。不要使用任何其他引入，也不要使用任何限定词(带句点的那种)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.lang.System

object Test extends App{
  var password = Console.readLine()

  if (password equals &quot;secret&quot;) System.out.println(&quot;Hello &quot; + System.getProperty(&quot;user.name&quot;))
  else System.err.println(&quot;password error!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;除了StringBuilder,还有哪些java.lang的成员是被scala包覆盖的？&lt;/h2&gt;

&lt;p&gt;直接比对java.lang下的类和scala包下的类即可&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;包和引入&lt;/h1&gt;

&lt;h2&gt;编写示例程序，展示为什么&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com.horstmann.impatient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com
package horstmann
package impatient
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别使用package的效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com {
  class T1() {}

  package horstmann {
    class T2(t: T1) {}

    package impatient {
      class T3(t1: T1, t2: T2) {}
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子包里的类可以使用父包里的类。但是第一种方式不可以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com.horstmann.impatient{
  class T4(t1:T1,t3:T3)      //无法找到T1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;编写一段让你的Scala朋友们感到困惑的代码，使用一个不在顶部的com包&lt;/h2&gt;

&lt;p&gt;这样可以吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package com {
  class T1() {}

  package horstmann {
    class T2(t: T1) {}

    package impatient {
      class T3(t1: T1, t2: T2) {}
    }
  }
}

import com._

class TT(t1:T1){

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个包random,加入函数nextInt():Int,nextDouble():Double,setSeed(seed:Int):Unit。生成随机数的算法采用线性同余生成器:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;后值 = (前值 * a + b)mod 2^n
其中,a = 1664525,b=1013904223,n = 32,前值的初始值为seed
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;package random{
package object random{

  var seed:Int = _
  val a = BigDecimal(1664525)
  val b = BigDecimal(1013904223)
  val n = 32


  def nextInt():Int={
    val temp = (seed * a + b) % BigDecimal(2).pow(n)
    seed = temp.toInt
    seed
  }

  def nextDouble():Double={
    val temp = (seed * a + b) % BigDecimal(2).pow(n)
    seed = temp.toInt
    temp.toDouble
  }
}
}

package test {
import random.random

object Test extends App {
  random.seed = 4
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextInt())
  println(random.nextInt())
  println(random.nextInt())
  println(random.nextInt())
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在你看来Scala的设计者为什么要提供package object语法而不是简单的让你将函数和变量添加到包中呢？&lt;/h2&gt;

&lt;p&gt;JVM不支持。。。&lt;/p&gt;

&lt;h2&gt;private[com] def giveRaise(rate:Double)的含义是什么？有用吗？&lt;/h2&gt;

&lt;p&gt;除了com包可访问，其他包都不能访问。&lt;/p&gt;

&lt;h2&gt;编写一段程序,将Java哈希映射中的所有元素拷贝到Scala哈希映射。用引入语句重命名这两个类。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.util.{HashMap =&amp;gt; JavaHashMap}
import scala.collection.mutable.HashMap

object Test extends App{

  val map = new JavaHashMap[String,String]()
  map.put(&quot;1&quot;,&quot;a&quot;)
  map.put(&quot;2&quot;,&quot;b&quot;)
  map.put(&quot;3&quot;,&quot;c&quot;)

  val smap = new HashMap[String,String]()

  for(key &amp;lt;- map.keySet().toArray){
    smap += (key.toString -&amp;gt; map.get(key))
  }

  println(smap.mkString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在前一个练习中，将所有引入语句移动到尽可能小的作用域里&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Test extends App{

  import java.util.{HashMap =&amp;gt; JavaHashMap}

  val map = new JavaHashMap[String,String]()
  map.put(&quot;1&quot;,&quot;a&quot;)
  map.put(&quot;2&quot;,&quot;b&quot;)
  map.put(&quot;3&quot;,&quot;c&quot;)

  import scala.collection.mutable.HashMap

  val smap = new HashMap[String,String]()

  for(key &amp;lt;- map.keySet().toArray){
    smap += (key.toString -&amp;gt; map.get(key))
  }

  println(smap.mkString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;以下代码的作用是什么？这是个好主意吗？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java._
import javax._
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入java和javax下的所有类。而java和javax下是没有类的。所以此代码无用&lt;/p&gt;

&lt;h2&gt;编写一段程序，引入java.lang.System类，从user.name系统属性读取用户名，从Console对象读取一个密码,如果密码不是&quot;secret&quot;，则在标准错误流中打印一个消息；如果密码是&quot;secret&quot;，则在标准输出流中打印一个问候消息。不要使用任何其他引入，也不要使用任何限定词(带句点的那种)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import java.lang.System

object Test extends App{
  var password = Console.readLine()

  if (password equals &quot;secret&quot;) System.out.println(&quot;Hello &quot; + System.getProperty(&quot;user.name&quot;))
  else System.err.println(&quot;password error!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;除了StringBuilder,还有哪些java.lang的成员是被scala包覆盖的？&lt;/h2&gt;

&lt;p&gt;直接比对java.lang下的类和scala包下的类即可&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第六章 对象</title>
        <link href="http://ivanpig.github.io/2013/03/08/scala_exercises_06.html"/>
        <updated>2013-03-08T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/08/scala_exercises_06</id>
        <content type="html">&lt;h1&gt;对象&lt;/h1&gt;

&lt;h2&gt;编写一个Conversions对象，加入inchesToCentimeters,gallonsToLiters和milesToKilometers方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Conversions{
    def inchesToCentimeters(){}
    def gallonsToLiters(){}
    def milesToKilometers(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;前一个练习不是很面向对象。提供一个通用的超类UnitConversion并定义扩展该超类的InchesToCentimeters,GallonsToLiters和MilesToKilometers对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;abstract class UnitConversion{

  def inchesToCentimeters(){}
  def gallonsToLiters(){}
  def milesToKilometers(){}

}

object InchesToCentimeters extends UnitConversion{
  override def inchesToCentimeters() {}
}

object GallonsToLiters extends UnitConversion{
  override def gallonsToLiters() {}
}

object MilesToKilometers extends UnitConversion{
  override def milesToKilometers() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;定义一个扩展自java.awt.Point的Origin对象。为什么说这实际上不是个好主意？(仔细看Point类的方法)&lt;/h2&gt;

&lt;p&gt;Point中的getLocation方法返回的是Point对象，如果想返回Origin对象，需要Origin类才行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Origin extends Point with App{

  override def getLocation: Point = super.getLocation

  Origin.move(2,3)
  println(Origin.toString)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个Point类和一个伴生对象,使得我们可以不用new而直接用Point(3,4)来构造Point实例&lt;/h2&gt;

&lt;p&gt;apply方法的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Point(x:Int,y:Int){
  override def toString: String = &quot;x = &quot; + x + &quot; y = &quot; + y
}

object Point extends App{
  def apply(x:Int,y:Int)={
    new Point(x,y)
  }

  val p = Point(1,2)
  println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Scala应用程序,使用App特质,以反序打印命令行参数,用空格隔开。举例来说,scala Reverse Hello World应该打印World Hello&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Reverse extends App{
  args.reverse.foreach(arg =&amp;gt; print(arg  + &quot; &quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个扑克牌4种花色的枚举,让其toString方法分别返回♣,@\&lt;span style=&quot;color:red&quot;\&gt;♦@\&amp;lt;/span&gt;,@\&lt;span style=&quot;color:red&quot;\&gt;♥@\&amp;lt;/span&gt;,♠&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Card extends Enumeration with App{
  val M = Value(&quot;♣&quot;)
  val T = Value(&quot;♠&quot;)
  val H = Value(&quot;♥&quot;)
  val F = Value(&quot;♦&quot;)

  println(Card.M)
  println(Card.T)
  println(Card.H)
  println(Card.F)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个函数,检查某张牌的花色是否为红色&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Card extends Enumeration with App{
  val M = Value(&quot;♣&quot;)
  val T = Value(&quot;♠&quot;)
  val H = Value(&quot;♥&quot;)
  val F = Value(&quot;♦&quot;)

  def color(c:Card.Value){
    if(c == Card.M || c == Card.T) print(&quot;Black&quot;)
    else print(&quot;Red&quot;)
  }

  color(Card.H)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个枚举,描述RGB立方体的8个角。ID使用颜色值(例如:红色是0xff0000)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object RGB extends Enumeration with App{
  val RED = Value(0xff0000,&quot;Red&quot;)
  val BLACK = Value(0x000000,&quot;Black&quot;)
  val GREEN = Value(0x00ff00,&quot;Green&quot;)
  val CYAN = Value(0x00ffff,&quot;Cyan&quot;)
  val YELLOW = Value(0xffff00,&quot;Yellow&quot;)
  val WHITE = Value(0xffffff,&quot;White&quot;)
  val BLUE = Value(0x0000ff,&quot;Blue&quot;)
  val MAGENTA = Value(0xff00ff,&quot;Magenta&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;对象&lt;/h1&gt;

&lt;h2&gt;编写一个Conversions对象，加入inchesToCentimeters,gallonsToLiters和milesToKilometers方法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Conversions{
    def inchesToCentimeters(){}
    def gallonsToLiters(){}
    def milesToKilometers(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;前一个练习不是很面向对象。提供一个通用的超类UnitConversion并定义扩展该超类的InchesToCentimeters,GallonsToLiters和MilesToKilometers对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;abstract class UnitConversion{

  def inchesToCentimeters(){}
  def gallonsToLiters(){}
  def milesToKilometers(){}

}

object InchesToCentimeters extends UnitConversion{
  override def inchesToCentimeters() {}
}

object GallonsToLiters extends UnitConversion{
  override def gallonsToLiters() {}
}

object MilesToKilometers extends UnitConversion{
  override def milesToKilometers() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;定义一个扩展自java.awt.Point的Origin对象。为什么说这实际上不是个好主意？(仔细看Point类的方法)&lt;/h2&gt;

&lt;p&gt;Point中的getLocation方法返回的是Point对象，如果想返回Origin对象，需要Origin类才行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Origin extends Point with App{

  override def getLocation: Point = super.getLocation

  Origin.move(2,3)
  println(Origin.toString)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个Point类和一个伴生对象,使得我们可以不用new而直接用Point(3,4)来构造Point实例&lt;/h2&gt;

&lt;p&gt;apply方法的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Point(x:Int,y:Int){
  override def toString: String = &quot;x = &quot; + x + &quot; y = &quot; + y
}

object Point extends App{
  def apply(x:Int,y:Int)={
    new Point(x,y)
  }

  val p = Point(1,2)
  println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Scala应用程序,使用App特质,以反序打印命令行参数,用空格隔开。举例来说,scala Reverse Hello World应该打印World Hello&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Reverse extends App{
  args.reverse.foreach(arg =&amp;gt; print(arg  + &quot; &quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个扑克牌4种花色的枚举,让其toString方法分别返回♣,@\&lt;span style=&quot;color:red&quot;\&gt;♦@\&amp;lt;/span&gt;,@\&lt;span style=&quot;color:red&quot;\&gt;♥@\&amp;lt;/span&gt;,♠&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Card extends Enumeration with App{
  val M = Value(&quot;♣&quot;)
  val T = Value(&quot;♠&quot;)
  val H = Value(&quot;♥&quot;)
  val F = Value(&quot;♦&quot;)

  println(Card.M)
  println(Card.T)
  println(Card.H)
  println(Card.F)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现一个函数,检查某张牌的花色是否为红色&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object Card extends Enumeration with App{
  val M = Value(&quot;♣&quot;)
  val T = Value(&quot;♠&quot;)
  val H = Value(&quot;♥&quot;)
  val F = Value(&quot;♦&quot;)

  def color(c:Card.Value){
    if(c == Card.M || c == Card.T) print(&quot;Black&quot;)
    else print(&quot;Red&quot;)
  }

  color(Card.H)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个枚举,描述RGB立方体的8个角。ID使用颜色值(例如:红色是0xff0000)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;object RGB extends Enumeration with App{
  val RED = Value(0xff0000,&quot;Red&quot;)
  val BLACK = Value(0x000000,&quot;Black&quot;)
  val GREEN = Value(0x00ff00,&quot;Green&quot;)
  val CYAN = Value(0x00ffff,&quot;Cyan&quot;)
  val YELLOW = Value(0xffff00,&quot;Yellow&quot;)
  val WHITE = Value(0xffffff,&quot;White&quot;)
  val BLUE = Value(0x0000ff,&quot;Blue&quot;)
  val MAGENTA = Value(0xff00ff,&quot;Magenta&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第五章 类</title>
        <link href="http://ivanpig.github.io/2013/03/07/scala_exercises_05.html"/>
        <updated>2013-03-07T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/07/scala_exercises_05</id>
        <content type="html">&lt;h1&gt;类&lt;/h1&gt;

&lt;h2&gt;改进5.1节的Counter类,让它不要在Int.MaxValue时变成负数&lt;/h2&gt;

&lt;p&gt;加个判断就OK了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Count{
  private var value = Int.MaxValue
  def increment(){if(value &amp;lt; Int.MaxValue) value + 1 else value }
  def current = value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个BankAccount类，加入deposit和withdraw方法，和一个只读的balance属性&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class BankAccount(val balance:Int = 0){
  def deposit(){}
  def withdraw(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Time类，加入只读属性hours和minutes，和一个检查某一时刻是否早于另一时刻的方法before(other:Time):Boolean。Time对象应该以new Time(hrs,min)方式构建。其中hrs以军用时间格式呈现(介于0和23之间)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Time(val hours:Int,val minutes:Int){

   def before(other:Time):Boolean={
     hours &amp;lt; other.hours || (hours == other.hours &amp;amp;&amp;amp; minutes &amp;lt; other.minutes)
   }

   override def toString():String={
     hours + &quot; : &quot; + minutes
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;重新实现前一个类中的Time类，将内部呈现改成午夜起的分钟数(介于0到24*60-1之间)。不要改变公有接口。也就是说，客户端代码不应因你的修改而受影响&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; class Time(val hours:Int,val minutes:Int){

   def before(other:Time):Boolean={
     hours &amp;lt; other.hours || (hours == other.hours &amp;amp;&amp;amp; minutes &amp;lt; other.minutes)
   }

   override def toString():String={
      hours * 60 + minutes
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建一个Student类，加入可读写的JavaBeans属性name(类型为String)和id(类型为Long)。有哪些方法被生产？(用javap查看。)你可以在Scala中调用JavaBeans的getter和setter方法吗？应该这样做吗？&lt;/h2&gt;

&lt;p&gt;生成了name(),name_=(),id(),id_=(),setName(),getName(),setId(),getId()
编写代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.reflect.BeanProperty

class Student{

    @BeanProperty var name:String = _
    @BeanProperty var id:Long = _
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;javap -c Student 后显示如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;Compiled from &quot;Student.scala&quot;
public class Student extends java.lang.Object implements scala.ScalaObject{
public java.lang.String name();
  Code:
   0:   aload_0
   1:   getfield        #13; //Field name:Ljava/lang/String;
   4:   areturn

public void name_$eq(java.lang.String);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #13; //Field name:Ljava/lang/String;
   5:   return

public void setName(java.lang.String);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #13; //Field name:Ljava/lang/String;
   5:   return

public long id();
  Code:
   0:   aload_0
   1:   getfield        #19; //Field id:J
   4:   lreturn

public void id_$eq(long);
  Code:
   0:   aload_0
   1:   lload_1
   2:   putfield        #19; //Field id:J
   5:   return

public void setId(long);
  Code:
   0:   aload_0
   1:   lload_1
   2:   putfield        #19; //Field id:J
   5:   return

public long getId();
  Code:
   0:   aload_0
   1:   invokevirtual   #25; //Method id:()J
   4:   lreturn

public java.lang.String getName();
  Code:
   0:   aload_0
   1:   invokevirtual   #28; //Method name:()Ljava/lang/String;
   4:   areturn

public Student();
  Code:
   0:   aload_0
   1:   invokespecial   #34; //Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   4:   return

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在5.2节的Person类中提供一个主构造器,将负年龄转换为0&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Person(var age:Int){
  age = if(age &amp;lt; 0) 0 else age
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Person类，其主构造器接受一个字符串，该字符串包含名字，空格和姓，如new Person(&quot;Fred Smith&quot;)。提供只读属性firstName和lastName。主构造器参数应该是var,val还是普通参数？为什么？&lt;/h2&gt;

&lt;p&gt;必须为val。如果为var，则对应的此字符串有get和set方法，而Person中的firstName和lastName为只读的,所以不能重复赋值。如果为var则会重复赋值而报错&lt;/p&gt;

&lt;h2&gt;创建一个Car类，以只读属性对应制造商，型号名称，型号年份以及一个可读写的属性用于车牌。提供四组构造器。每个构造器fc都要求制造商和型号为必填。型号年份和车牌可选，如果未填，则型号年份为-1，车牌为空串。你会选择哪一个作为你的主构造器？为什么？&lt;/h2&gt;

&lt;p&gt;这个没太明白题意。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Car(val maker:String,val typeName:String,val year:Int = -1,var carLice:String = &quot;&quot;){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在Java,C#或C++重做前一个练习。Scala相比之下精简多少？&lt;/h2&gt;

&lt;p&gt;这个就不写了。&lt;/p&gt;

&lt;h2&gt;考虑如下的类&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Employ(val name:String,var salary:Double){
    def this(){this(&quot;John Q. Public&quot;,0.0)}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重写该类,使用显示的字段定义，和一个缺省主构造器。你更倾向于使用哪种形式？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Employ{
    val name:String = &quot;John Q. Public&quot;
    var salary:Double = 0.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;个人更喜欢第二种方式，简单明了。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;类&lt;/h1&gt;

&lt;h2&gt;改进5.1节的Counter类,让它不要在Int.MaxValue时变成负数&lt;/h2&gt;

&lt;p&gt;加个判断就OK了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Count{
  private var value = Int.MaxValue
  def increment(){if(value &amp;lt; Int.MaxValue) value + 1 else value }
  def current = value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个BankAccount类，加入deposit和withdraw方法，和一个只读的balance属性&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class BankAccount(val balance:Int = 0){
  def deposit(){}
  def withdraw(){}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Time类，加入只读属性hours和minutes，和一个检查某一时刻是否早于另一时刻的方法before(other:Time):Boolean。Time对象应该以new Time(hrs,min)方式构建。其中hrs以军用时间格式呈现(介于0和23之间)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Time(val hours:Int,val minutes:Int){

   def before(other:Time):Boolean={
     hours &amp;lt; other.hours || (hours == other.hours &amp;amp;&amp;amp; minutes &amp;lt; other.minutes)
   }

   override def toString():String={
     hours + &quot; : &quot; + minutes
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;重新实现前一个类中的Time类，将内部呈现改成午夜起的分钟数(介于0到24*60-1之间)。不要改变公有接口。也就是说，客户端代码不应因你的修改而受影响&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; class Time(val hours:Int,val minutes:Int){

   def before(other:Time):Boolean={
     hours &amp;lt; other.hours || (hours == other.hours &amp;amp;&amp;amp; minutes &amp;lt; other.minutes)
   }

   override def toString():String={
      hours * 60 + minutes
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建一个Student类，加入可读写的JavaBeans属性name(类型为String)和id(类型为Long)。有哪些方法被生产？(用javap查看。)你可以在Scala中调用JavaBeans的getter和setter方法吗？应该这样做吗？&lt;/h2&gt;

&lt;p&gt;生成了name(),name_=(),id(),id_=(),setName(),getName(),setId(),getId()
编写代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.reflect.BeanProperty

class Student{

    @BeanProperty var name:String = _
    @BeanProperty var id:Long = _
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;javap -c Student 后显示如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;Compiled from &quot;Student.scala&quot;
public class Student extends java.lang.Object implements scala.ScalaObject{
public java.lang.String name();
  Code:
   0:   aload_0
   1:   getfield        #13; //Field name:Ljava/lang/String;
   4:   areturn

public void name_$eq(java.lang.String);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #13; //Field name:Ljava/lang/String;
   5:   return

public void setName(java.lang.String);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #13; //Field name:Ljava/lang/String;
   5:   return

public long id();
  Code:
   0:   aload_0
   1:   getfield        #19; //Field id:J
   4:   lreturn

public void id_$eq(long);
  Code:
   0:   aload_0
   1:   lload_1
   2:   putfield        #19; //Field id:J
   5:   return

public void setId(long);
  Code:
   0:   aload_0
   1:   lload_1
   2:   putfield        #19; //Field id:J
   5:   return

public long getId();
  Code:
   0:   aload_0
   1:   invokevirtual   #25; //Method id:()J
   4:   lreturn

public java.lang.String getName();
  Code:
   0:   aload_0
   1:   invokevirtual   #28; //Method name:()Ljava/lang/String;
   4:   areturn

public Student();
  Code:
   0:   aload_0
   1:   invokespecial   #34; //Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   4:   return

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在5.2节的Person类中提供一个主构造器,将负年龄转换为0&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Person(var age:Int){
  age = if(age &amp;lt; 0) 0 else age
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个Person类，其主构造器接受一个字符串，该字符串包含名字，空格和姓，如new Person(&quot;Fred Smith&quot;)。提供只读属性firstName和lastName。主构造器参数应该是var,val还是普通参数？为什么？&lt;/h2&gt;

&lt;p&gt;必须为val。如果为var，则对应的此字符串有get和set方法，而Person中的firstName和lastName为只读的,所以不能重复赋值。如果为var则会重复赋值而报错&lt;/p&gt;

&lt;h2&gt;创建一个Car类，以只读属性对应制造商，型号名称，型号年份以及一个可读写的属性用于车牌。提供四组构造器。每个构造器fc都要求制造商和型号为必填。型号年份和车牌可选，如果未填，则型号年份为-1，车牌为空串。你会选择哪一个作为你的主构造器？为什么？&lt;/h2&gt;

&lt;p&gt;这个没太明白题意。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Car(val maker:String,val typeName:String,val year:Int = -1,var carLice:String = &quot;&quot;){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在Java,C#或C++重做前一个练习。Scala相比之下精简多少？&lt;/h2&gt;

&lt;p&gt;这个就不写了。&lt;/p&gt;

&lt;h2&gt;考虑如下的类&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Employ(val name:String,var salary:Double){
    def this(){this(&quot;John Q. Public&quot;,0.0)}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重写该类,使用显示的字段定义，和一个缺省主构造器。你更倾向于使用哪种形式？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;class Employ{
    val name:String = &quot;John Q. Public&quot;
    var salary:Double = 0.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;个人更喜欢第二种方式，简单明了。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第四章 映射和元组</title>
        <link href="http://ivanpig.github.io/2013/03/06/scala_exercises_04.html"/>
        <updated>2013-03-06T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/06/scala_exercises_04</id>
        <content type="html">&lt;h1&gt;映射和元组&lt;/h1&gt;

&lt;h2&gt;设置一个映射,其中包含你想要的一些装备，以及它们的价格。然后构建另一个映射，采用同一组键，但是价格上打9折&lt;/h2&gt;

&lt;p&gt;映射的简单操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; val map = Map(&quot;book&quot;-&amp;gt;10,&quot;gun&quot;-&amp;gt;18,&quot;ipad&quot;-&amp;gt;1000)
map: scala.collection.immutable.Map[java.lang.String,Int] = Map(book -&amp;gt; 10, gun -&amp;gt; 18, ipad -&amp;gt; 1000)

scala&amp;gt; for((k,v) &amp;lt;- map) yield (k,v * 0.9)
res3: scala.collection.immutable.Map[java.lang.String,Double] = Map(book -&amp;gt; 9.0, gun -&amp;gt; 16.2, ipad -&amp;gt; 900.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一段程序，从文件中读取单词。用一个可变映射来清点每个单词出现的频率。读取这些单词的操作可以使用java.util.Scanner:&lt;/h2&gt;

&lt;p&gt;val in = new java.util.Scanner(new java.io.File(&quot;myfile.txt&quot;))
while(in.hasNext()) 处理 in.next() 或者翻到第9章看看更Scala的做法。
最后，打印出所有单词和它们出现的次数。
@\&amp;lt;p&gt;当然使用Scala的方法啦。参考第9章@\&amp;lt;/p&gt;
首先，创建一个文件myfile.txt。输入如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;test test ttt test ttt t test sss s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source
import scala.collection.mutable.HashMap

//val source = Source.fromFile(&quot;myfile.txt&quot;)
//val tokens = source.mkString.split(&quot;\\s+&quot;)  //此写法tokens为空，不知为何

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

val map = new HashMap[String,Int]

for(key &amp;lt;- tokens){
    map(key) = map.getOrElse(key,0) + 1
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;重复前一个练习，这次用不可变的映射&lt;/h2&gt;

&lt;p&gt;不可变映射与可变映射的区别就是，每次添加元素，都会返回一个新的映射&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

var map = Map[String,Int]()

for(key &amp;lt;- tokens){
  map += (key -&amp;gt; (map.getOrElse(key,0) + 1))
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重复前一个练习，这次使用已排序的映射，以便单词可以按顺序打印出来&lt;/h2&gt;

&lt;p&gt;和上面的代码没有什么区别，只是将映射修改为SortedMap&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source
import scala.collection.SortedMap

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

var map = SortedMap[String,Int]()

for(key &amp;lt;- tokens){
  map += (key -&amp;gt; (map.getOrElse(key,0) + 1))
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重复前一个练习，这次使用java.util.TreeMap并使之适用于Scala API&lt;/h2&gt;

&lt;p&gt;主要涉及java与scala的转换类的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source
import scala.collection.mutable.Map
import scala.collection.JavaConversions.mapAsScalaMap
import java.util.TreeMap

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

val map:Map[String,Int] = new TreeMap[String,Int]

for(key &amp;lt;- tokens){
  map(key) = map.getOrElse(key,0) + 1
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个链式哈希映射,将&quot;Monday&quot;映射到java.util.Calendar.MONDAY,依次类推加入其他日期。展示元素是以插入的顺序被访问的&lt;/h2&gt;

&lt;p&gt;LinkedHashMap的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.collection.mutable.LinkedHashMap
import java.util.Calendar

val map = new LinkedHashMap[String,Int]

map += (&quot;Monday&quot;-&amp;gt;Calendar.MONDAY)
map += (&quot;Tuesday&quot;-&amp;gt;Calendar.TUESDAY)
map += (&quot;Wednesday&quot;-&amp;gt;Calendar.WEDNESDAY)
map += (&quot;Thursday&quot;-&amp;gt;Calendar.THURSDAY)
map += (&quot;Friday&quot;-&amp;gt;Calendar.FRIDAY)
map += (&quot;Saturday&quot;-&amp;gt;Calendar.SATURDAY)
map += (&quot;Sunday&quot;-&amp;gt;Calendar.SUNDAY)


println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;打印出所有Java系统属性的表格，&lt;/h2&gt;

&lt;p&gt;属性转scala map的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.collection.JavaConversions.propertiesAsScalaMap

val props:scala.collection.Map[String,String] = System.getProperties()

val keys = props.keySet

val keyLengths = for( key &amp;lt;- keys ) yield key.length

val maxKeyLength = keyLengths.max

for(key &amp;lt;- keys) {
  print(key)
  print(&quot; &quot; * (maxKeyLength - key.length))
  print(&quot; | &quot;)
  println(props(key))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数minmax(values:Array[Int]),返回数组中最小值和最大值的对偶&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def minmax(values:Array[Int])={
  (values.max,values.min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数Iteqgt(values:Array[int],v:Int),返回数组中小于v,等于v和大于v的数量，要求三个值一起返回&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def iteqgt(values:Array[Int],v:Int)={
  val buf = values.toBuffer
  (values.count(_ &amp;lt; v),values.count(_ == v),values.count(_ &amp;gt; v))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;当你将两个字符串拉链在一起，比如&quot;Hello&quot;.zip(&quot;World&quot;)，会是什么结果？想出一个讲得通的用例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; &quot;Hello&quot;.zip(&quot;World&quot;)
res0: scala.collection.immutable.IndexedSeq[(Char, Char)] = Vector((H,W), (e,o), (l,r), (l,l), (o,d))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StringOps中的zip定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;abstract def zip[B](that: GenIterable[B]): StringOps[(A, B)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GenIterable是可遍历对象需要包含的trait，对于String来说，它是可遍历的。但是它的遍历是遍历单个字母。
所以拉链就针对每个字母来进行。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;映射和元组&lt;/h1&gt;

&lt;h2&gt;设置一个映射,其中包含你想要的一些装备，以及它们的价格。然后构建另一个映射，采用同一组键，但是价格上打9折&lt;/h2&gt;

&lt;p&gt;映射的简单操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; val map = Map(&quot;book&quot;-&amp;gt;10,&quot;gun&quot;-&amp;gt;18,&quot;ipad&quot;-&amp;gt;1000)
map: scala.collection.immutable.Map[java.lang.String,Int] = Map(book -&amp;gt; 10, gun -&amp;gt; 18, ipad -&amp;gt; 1000)

scala&amp;gt; for((k,v) &amp;lt;- map) yield (k,v * 0.9)
res3: scala.collection.immutable.Map[java.lang.String,Double] = Map(book -&amp;gt; 9.0, gun -&amp;gt; 16.2, ipad -&amp;gt; 900.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一段程序，从文件中读取单词。用一个可变映射来清点每个单词出现的频率。读取这些单词的操作可以使用java.util.Scanner:&lt;/h2&gt;

&lt;p&gt;val in = new java.util.Scanner(new java.io.File(&quot;myfile.txt&quot;))
while(in.hasNext()) 处理 in.next() 或者翻到第9章看看更Scala的做法。
最后，打印出所有单词和它们出现的次数。
@\&amp;lt;p&gt;当然使用Scala的方法啦。参考第9章@\&amp;lt;/p&gt;
首先，创建一个文件myfile.txt。输入如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;test test ttt test ttt t test sss s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source
import scala.collection.mutable.HashMap

//val source = Source.fromFile(&quot;myfile.txt&quot;)
//val tokens = source.mkString.split(&quot;\\s+&quot;)  //此写法tokens为空，不知为何

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

val map = new HashMap[String,Int]

for(key &amp;lt;- tokens){
    map(key) = map.getOrElse(key,0) + 1
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;重复前一个练习，这次用不可变的映射&lt;/h2&gt;

&lt;p&gt;不可变映射与可变映射的区别就是，每次添加元素，都会返回一个新的映射&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

var map = Map[String,Int]()

for(key &amp;lt;- tokens){
  map += (key -&amp;gt; (map.getOrElse(key,0) + 1))
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重复前一个练习，这次使用已排序的映射，以便单词可以按顺序打印出来&lt;/h2&gt;

&lt;p&gt;和上面的代码没有什么区别，只是将映射修改为SortedMap&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source
import scala.collection.SortedMap

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

var map = SortedMap[String,Int]()

for(key &amp;lt;- tokens){
  map += (key -&amp;gt; (map.getOrElse(key,0) + 1))
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重复前一个练习，这次使用java.util.TreeMap并使之适用于Scala API&lt;/h2&gt;

&lt;p&gt;主要涉及java与scala的转换类的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.io.Source
import scala.collection.mutable.Map
import scala.collection.JavaConversions.mapAsScalaMap
import java.util.TreeMap

val source = Source.fromFile(&quot;myfile.txt&quot;).mkString

val tokens = source.split(&quot;\\s+&quot;)

val map:Map[String,Int] = new TreeMap[String,Int]

for(key &amp;lt;- tokens){
  map(key) = map.getOrElse(key,0) + 1
}

println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;定义一个链式哈希映射,将&quot;Monday&quot;映射到java.util.Calendar.MONDAY,依次类推加入其他日期。展示元素是以插入的顺序被访问的&lt;/h2&gt;

&lt;p&gt;LinkedHashMap的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.collection.mutable.LinkedHashMap
import java.util.Calendar

val map = new LinkedHashMap[String,Int]

map += (&quot;Monday&quot;-&amp;gt;Calendar.MONDAY)
map += (&quot;Tuesday&quot;-&amp;gt;Calendar.TUESDAY)
map += (&quot;Wednesday&quot;-&amp;gt;Calendar.WEDNESDAY)
map += (&quot;Thursday&quot;-&amp;gt;Calendar.THURSDAY)
map += (&quot;Friday&quot;-&amp;gt;Calendar.FRIDAY)
map += (&quot;Saturday&quot;-&amp;gt;Calendar.SATURDAY)
map += (&quot;Sunday&quot;-&amp;gt;Calendar.SUNDAY)


println(map.mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;打印出所有Java系统属性的表格，&lt;/h2&gt;

&lt;p&gt;属性转scala map的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.collection.JavaConversions.propertiesAsScalaMap

val props:scala.collection.Map[String,String] = System.getProperties()

val keys = props.keySet

val keyLengths = for( key &amp;lt;- keys ) yield key.length

val maxKeyLength = keyLengths.max

for(key &amp;lt;- keys) {
  print(key)
  print(&quot; &quot; * (maxKeyLength - key.length))
  print(&quot; | &quot;)
  println(props(key))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数minmax(values:Array[Int]),返回数组中最小值和最大值的对偶&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def minmax(values:Array[Int])={
  (values.max,values.min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数Iteqgt(values:Array[int],v:Int),返回数组中小于v,等于v和大于v的数量，要求三个值一起返回&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def iteqgt(values:Array[Int],v:Int)={
  val buf = values.toBuffer
  (values.count(_ &amp;lt; v),values.count(_ == v),values.count(_ &amp;gt; v))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;当你将两个字符串拉链在一起，比如&quot;Hello&quot;.zip(&quot;World&quot;)，会是什么结果？想出一个讲得通的用例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; &quot;Hello&quot;.zip(&quot;World&quot;)
res0: scala.collection.immutable.IndexedSeq[(Char, Char)] = Vector((H,W), (e,o), (l,r), (l,l), (o,d))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StringOps中的zip定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;abstract def zip[B](that: GenIterable[B]): StringOps[(A, B)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GenIterable是可遍历对象需要包含的trait，对于String来说，它是可遍历的。但是它的遍历是遍历单个字母。
所以拉链就针对每个字母来进行。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第三章 数组相关操作</title>
        <link href="http://ivanpig.github.io/2013/03/05/scala_exercises_03.html"/>
        <updated>2013-03-05T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/05/scala_exercises_03</id>
        <content type="html">&lt;h1&gt;数组相关操作&lt;/h1&gt;

&lt;h2&gt;编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0(包含)和n(不包含)之间&lt;/h2&gt;

&lt;p&gt;random和yield的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.random

def randomArray(n:Int)={
  for(i &amp;lt;- 0 until n) yield (random * n).toInt
}

println(randomArray(10).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个循环，将整数数组中相邻的元素置换。例如,Array(1,2,3,4,5)经过置换后变为Array(2,1,4,3,5)&lt;/h2&gt;

&lt;p&gt;对数组方法的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def reorderArray(arr:Array[Int]):Array[Int]={
  val t = arr.toBuffer
  for(i &amp;lt;- 1 until (t.length,2);tmp = t(i);j &amp;lt;- i - 1 until i){
    t(i) = t(j)
    t(j) = tmp
  }
  t.toArray
}

println(reorderArray(Array(1,2,3,4,5)).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def reorderArray(arr:Array[Int]):Array[Int]={
  (for(i &amp;lt;- 0 until (arr.length,2)) yield if (i + 1 &amp;lt; arr.length) Array(arr(i + 1),arr(i)) else Array(arr(i))).flatten.toArray
}

println(reorderArray(Array(1,2,3,4,5)).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉代码有点丑也难读。需要优化。&lt;/p&gt;

&lt;h2&gt;给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;//使用循环
 def reorderArray(arr:Array[Int]):Array[Int]={
     val a = ArrayBuffer[Int]()
     val b = ArrayBuffer[Int]()
     arr.foreach(arg =&amp;gt; if(arg &amp;gt; 0) a += arg else b += arg)
     a ++= b
     a.toArray
 }
//使用filter
def reorderArray(arr:Array[Int]):Array[Int]={
  val a = arr.filter(_ &amp;gt; 0).map(1 * _)
  val b = arr.filter(_ &amp;lt;= 0).map(1 * _)
  val c = a.toBuffer
  c ++= b
  c.toArray
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何计算Array[Double]的平均值？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def aveArray(arr:Array[Double]):Double={
  arr.sum/arr.length
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何重新组织Array[Int]的元素将他们以反序排列？对于ArrayBuffer[Int]你又会怎么做呢？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def reverseArray(arr:Array[Int]):Array[Int]={
  arr.reverse
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一段代码，产出数组中的所有值，去掉重复项。(提示：查看Scaladoc)&lt;/h2&gt;

&lt;p&gt;产出数组的代码就不编写了。去重只需要调用api即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; def distinctArray(arr:Array[Int]):Array[Int]={
   val t = arr.toBuffer
   t.distinct.toArray
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重新编写3.4节结尾的示例。收集负值元素的下标，反序，去掉最后一个下标，然后对每个下标调用a.remove(i)。比较这样做的效率和3.4节中另外两种方法的效率&lt;/h2&gt;

&lt;p&gt;性能嘛，自己比较吧!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; def removeArray(arr:Array[Int]):Array[Int]={
   val t = arr.toBuffer
   val idx = ArrayBuffer[Int]()
   for(i &amp;lt;- 0 until t.length){
     if(t(i) &amp;lt; 0)idx += i
   }
   idx.remove(0)
   idx.reverse
   idx.foreach(t.remove(_))
   t.toArray
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建一个由java.util.TimeZone.getAvailableIDs返回ide时区集合，判断条件是它们在美洲。去掉&quot;America/&quot;前缀并排序&lt;/h2&gt;

&lt;p&gt;显示的都是中文时间，后续的过滤无法操作。只列出所有的时区&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; val t = for(i &amp;lt;- getAvailableIDs) yield
           getTimeZone(i).getDisplayName()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;引入java.awt.datatransfer.~并构建一个类型为SystemFlavorMap类型的对象~:&lt;/h2&gt;

&lt;p&gt;val flavors =
SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]
然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。
(为什么用这样一个晦涩难懂的类？因为在Java标准库中很难找到使用java.util.List的代码)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]
println(flavors.getNativesForFlavor(DataFlavor.imageFlavor).toArray.toBuffer.mkString(&quot; | &quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;数组相关操作&lt;/h1&gt;

&lt;h2&gt;编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0(包含)和n(不包含)之间&lt;/h2&gt;

&lt;p&gt;random和yield的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.random

def randomArray(n:Int)={
  for(i &amp;lt;- 0 until n) yield (random * n).toInt
}

println(randomArray(10).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个循环，将整数数组中相邻的元素置换。例如,Array(1,2,3,4,5)经过置换后变为Array(2,1,4,3,5)&lt;/h2&gt;

&lt;p&gt;对数组方法的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def reorderArray(arr:Array[Int]):Array[Int]={
  val t = arr.toBuffer
  for(i &amp;lt;- 1 until (t.length,2);tmp = t(i);j &amp;lt;- i - 1 until i){
    t(i) = t(j)
    t(j) = tmp
  }
  t.toArray
}

println(reorderArray(Array(1,2,3,4,5)).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def reorderArray(arr:Array[Int]):Array[Int]={
  (for(i &amp;lt;- 0 until (arr.length,2)) yield if (i + 1 &amp;lt; arr.length) Array(arr(i + 1),arr(i)) else Array(arr(i))).flatten.toArray
}

println(reorderArray(Array(1,2,3,4,5)).mkString(&quot;,&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉代码有点丑也难读。需要优化。&lt;/p&gt;

&lt;h2&gt;给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;//使用循环
 def reorderArray(arr:Array[Int]):Array[Int]={
     val a = ArrayBuffer[Int]()
     val b = ArrayBuffer[Int]()
     arr.foreach(arg =&amp;gt; if(arg &amp;gt; 0) a += arg else b += arg)
     a ++= b
     a.toArray
 }
//使用filter
def reorderArray(arr:Array[Int]):Array[Int]={
  val a = arr.filter(_ &amp;gt; 0).map(1 * _)
  val b = arr.filter(_ &amp;lt;= 0).map(1 * _)
  val c = a.toBuffer
  c ++= b
  c.toArray
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何计算Array[Double]的平均值？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def aveArray(arr:Array[Double]):Double={
  arr.sum/arr.length
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如何重新组织Array[Int]的元素将他们以反序排列？对于ArrayBuffer[Int]你又会怎么做呢？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def reverseArray(arr:Array[Int]):Array[Int]={
  arr.reverse
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一段代码，产出数组中的所有值，去掉重复项。(提示：查看Scaladoc)&lt;/h2&gt;

&lt;p&gt;产出数组的代码就不编写了。去重只需要调用api即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; def distinctArray(arr:Array[Int]):Array[Int]={
   val t = arr.toBuffer
   t.distinct.toArray
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重新编写3.4节结尾的示例。收集负值元素的下标，反序，去掉最后一个下标，然后对每个下标调用a.remove(i)。比较这样做的效率和3.4节中另外两种方法的效率&lt;/h2&gt;

&lt;p&gt;性能嘛，自己比较吧!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; def removeArray(arr:Array[Int]):Array[Int]={
   val t = arr.toBuffer
   val idx = ArrayBuffer[Int]()
   for(i &amp;lt;- 0 until t.length){
     if(t(i) &amp;lt; 0)idx += i
   }
   idx.remove(0)
   idx.reverse
   idx.foreach(t.remove(_))
   t.toArray
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建一个由java.util.TimeZone.getAvailableIDs返回ide时区集合，判断条件是它们在美洲。去掉&quot;America/&quot;前缀并排序&lt;/h2&gt;

&lt;p&gt;显示的都是中文时间，后续的过滤无法操作。只列出所有的时区&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt; val t = for(i &amp;lt;- getAvailableIDs) yield
           getTimeZone(i).getDisplayName()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;引入java.awt.datatransfer.~并构建一个类型为SystemFlavorMap类型的对象~:&lt;/h2&gt;

&lt;p&gt;val flavors =
SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]
然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。
(为什么用这样一个晦涩难懂的类？因为在Java标准库中很难找到使用java.util.List的代码)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;val flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]
println(flavors.getNativesForFlavor(DataFlavor.imageFlavor).toArray.toBuffer.mkString(&quot; | &quot;)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第二章 控制结构和函数</title>
        <link href="http://ivanpig.github.io/2013/03/04/scala_exercises_02.html"/>
        <updated>2013-03-04T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/04/scala_exercises_02</id>
        <content type="html">&lt;h1&gt;控制结构和函数&lt;/h1&gt;

&lt;h2&gt;一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值&lt;/h2&gt;

&lt;p&gt;简单的逻辑判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def signum(num:Int){if(num&amp;gt;0)print(1)else if(num&amp;lt;0)print(-1)else print(0)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala中已经有此方法了，刚才查找API的时候，应该能看到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;BigInt(10).signum
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;一个空的快表达式{}的值是什么？类型是什么？&lt;/h2&gt;

&lt;p&gt;在REPL中就能看出来了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; val t = {}
t: Unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，它的值是()类型是Unit&lt;/p&gt;

&lt;h2&gt;指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)&lt;/h2&gt;

&lt;p&gt;题目已经给了明确的提示了。本章节中已经说过了，在scala中的赋值语句是Unit类型。所以只要x为Unit类型就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; var y=4;
y: Int = 4

scala&amp;gt; var x={}
x: Unit = ()

scala&amp;gt; x=y=7
x: Unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也再次证明了{}是Unit类型&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;针对下列Java循环编写一个Scala版本:for(int i=10;i&gt;=0;i--)System.out.println(i);&lt;/h2&gt;

&lt;p&gt;使用Scala版本改写就OK了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;for(i &amp;lt;- 0 to 10 reverse)print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个过程countdown(n:Int)，打印从n到0的数字&lt;/h2&gt;

&lt;p&gt;这个就是将上面的循环包装到过程中而已。还是换个写法吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def countdown(n:Int){
    0 to n reverse foreach print
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，&quot;Hello&quot;中所有字符串的乘积为9415087488L&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; var t:Long = 1
t: Long = 1

scala&amp;gt; for(i &amp;lt;- &quot;Hello&quot;){
     | t = t * i.toLong
     | }

scala&amp;gt; t
res57: Long = 9415087488
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; var t:Long = 1
t: Long = 1

scala&amp;gt; &quot;Hello&quot;.foreach(t *= _.toLong)

scala&amp;gt; t
res59: Long = 9415087488
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数product(s:String)，计算前面练习中提到的乘积&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def product(s:String):Long={
    var t:Long = 1
    for(i &amp;lt;- s){
    t *= i.toLong
    }
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;把前一个练习中的函数改成递归函数&lt;/h2&gt;

&lt;p&gt;配合前一章的take和drop来实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def product(s:String):Long={
    if(s.length == 1) return s.charAt(0).toLong
    else s.take(1).charAt(0).toLong * product(s.drop(1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写函数计算x&lt;sup&gt;n&lt;/sup&gt;^,其中n是整数，使用如下的递归定义:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;x&lt;sup&gt;n&lt;/sup&gt;^=y&lt;sup&gt;2&lt;/sup&gt;^,如果n是正偶数的话，这里的y=x&lt;sup&gt;n/2&lt;/sup&gt;^&lt;/li&gt;
&lt;li&gt;x&lt;sup&gt;n&lt;/sup&gt;^ = x*x&lt;sup&gt;n-1&lt;/sup&gt;^,如果n是正奇数的话&lt;/li&gt;
&lt;li&gt;x&lt;sup&gt;0&lt;/sup&gt;^ = 1&lt;/li&gt;
&lt;li&gt;x&lt;sup&gt;n&lt;/sup&gt;^ = 1/x&lt;sup&gt;-n&lt;/sup&gt;^,如果n是负数的话&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;不得使用return语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def mi(x:Double,n:Int):Double={
    if(n == 0) 1
    else if (n &amp;gt; 0 &amp;amp;&amp;amp; n%2 == 0) mi(x,n/2) * mi(x,n/2)
    else if(n&amp;gt;0 &amp;amp;&amp;amp; n%2 == 1) x * mi(x,n-1)
    else 1/mi(x,-n)
}
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;控制结构和函数&lt;/h1&gt;

&lt;h2&gt;一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值&lt;/h2&gt;

&lt;p&gt;简单的逻辑判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def signum(num:Int){if(num&amp;gt;0)print(1)else if(num&amp;lt;0)print(-1)else print(0)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Scala中已经有此方法了，刚才查找API的时候，应该能看到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;BigInt(10).signum
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;一个空的快表达式{}的值是什么？类型是什么？&lt;/h2&gt;

&lt;p&gt;在REPL中就能看出来了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; val t = {}
t: Unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，它的值是()类型是Unit&lt;/p&gt;

&lt;h2&gt;指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)&lt;/h2&gt;

&lt;p&gt;题目已经给了明确的提示了。本章节中已经说过了，在scala中的赋值语句是Unit类型。所以只要x为Unit类型就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; var y=4;
y: Int = 4

scala&amp;gt; var x={}
x: Unit = ()

scala&amp;gt; x=y=7
x: Unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也再次证明了{}是Unit类型&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h2&gt;针对下列Java循环编写一个Scala版本:for(int i=10;i&gt;=0;i--)System.out.println(i);&lt;/h2&gt;

&lt;p&gt;使用Scala版本改写就OK了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;for(i &amp;lt;- 0 to 10 reverse)print(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个过程countdown(n:Int)，打印从n到0的数字&lt;/h2&gt;

&lt;p&gt;这个就是将上面的循环包装到过程中而已。还是换个写法吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def countdown(n:Int){
    0 to n reverse foreach print
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，&quot;Hello&quot;中所有字符串的乘积为9415087488L&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; var t:Long = 1
t: Long = 1

scala&amp;gt; for(i &amp;lt;- &quot;Hello&quot;){
     | t = t * i.toLong
     | }

scala&amp;gt; t
res57: Long = 9415087488
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; var t:Long = 1
t: Long = 1

scala&amp;gt; &quot;Hello&quot;.foreach(t *= _.toLong)

scala&amp;gt; t
res59: Long = 9415087488
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写一个函数product(s:String)，计算前面练习中提到的乘积&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def product(s:String):Long={
    var t:Long = 1
    for(i &amp;lt;- s){
    t *= i.toLong
    }
    t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;把前一个练习中的函数改成递归函数&lt;/h2&gt;

&lt;p&gt;配合前一章的take和drop来实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def product(s:String):Long={
    if(s.length == 1) return s.charAt(0).toLong
    else s.take(1).charAt(0).toLong * product(s.drop(1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写函数计算x&lt;sup&gt;n&lt;/sup&gt;^,其中n是整数，使用如下的递归定义:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;x&lt;sup&gt;n&lt;/sup&gt;^=y&lt;sup&gt;2&lt;/sup&gt;^,如果n是正偶数的话，这里的y=x&lt;sup&gt;n/2&lt;/sup&gt;^&lt;/li&gt;
&lt;li&gt;x&lt;sup&gt;n&lt;/sup&gt;^ = x*x&lt;sup&gt;n-1&lt;/sup&gt;^,如果n是正奇数的话&lt;/li&gt;
&lt;li&gt;x&lt;sup&gt;0&lt;/sup&gt;^ = 1&lt;/li&gt;
&lt;li&gt;x&lt;sup&gt;n&lt;/sup&gt;^ = 1/x&lt;sup&gt;-n&lt;/sup&gt;^,如果n是负数的话&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;不得使用return语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;def mi(x:Double,n:Int):Double={
    if(n == 0) 1
    else if (n &amp;gt; 0 &amp;amp;&amp;amp; n%2 == 0) mi(x,n/2) * mi(x,n/2)
    else if(n&amp;gt;0 &amp;amp;&amp;amp; n%2 == 1) x * mi(x,n-1)
    else 1/mi(x,-n)
}
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>快学Scala习题解答—第一章 基础</title>
        <link href="http://ivanpig.github.io/2013/03/03/scala_exercises_01.html"/>
        <updated>2013-03-03T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/03/03/scala_exercises_01</id>
        <content type="html">&lt;h1&gt;基础&lt;/h1&gt;

&lt;h2&gt;在Scala REPL中键入3,然后按Tab键。有哪些方法可以被应用?&lt;/h2&gt;

&lt;p&gt;这个。。。。直接操作一遍就有结果了.此题不知是翻译的问题，还是原题的问题，在Scala
REPL中需要按3. 然后按Tab才会提示。 直接按3加Tab是没有提示的。下面是结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;!=             ##             %              &amp;amp;              *              +
-              /              &amp;lt;              &amp;lt;&amp;lt;             &amp;lt;=             ==
&amp;gt;              &amp;gt;=             &amp;gt;&amp;gt;             &amp;gt;&amp;gt;&amp;gt;            ^              asInstanceOf
equals         getClass       hashCode       isInstanceOf   toByte         toChar
toDouble       toFloat        toInt          toLong         toShort        toString
unary_+        unary_-        unary_~        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出的方法并不全，需要查询全部方法还是需要到Scaladoc中的Int,Double,RichInt,RichDouble等类中去查看。&lt;/p&gt;

&lt;h2&gt;在Scala REPL中，计算3的平方根,然后再对该值求平方。现在，这个结果与3相差多少？(提示:res变量是你的朋友)&lt;/h2&gt;

&lt;p&gt;依次进行计算即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; scala.math.sqrt(3)
warning: there were 1 deprecation warnings; re-run with -deprecation for details
res5: Double = 1.7320508075688772

scala&amp;gt; res5*res5
res6: Double = 2.9999999999999996

scala&amp;gt; 3 - res6
res7: Double = 4.440892098500626E-16
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;res变量是val还是var?&lt;/h2&gt;

&lt;p&gt;val是不可变的，而var是可变的，只需要给res变量重新赋值就可以检测res是val还是var了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; res9 = 3
&amp;lt;console&amp;gt;:8: error: reassignment to val
       res9 = 3
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Scala允许你用数字去乘字符串---去REPL中试一下&quot;crazy&quot;*3。这个操作做什么？在Scaladoc中如何找到这个操作?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; &quot;crazy&quot;*3
res11: String = crazycrazycrazy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码可以推断,*是&quot;crazy&quot;这个字符串所具有的方法，但是Java中的String可没这个方法，很明显。此方法在StringOps中。&lt;/p&gt;

&lt;h2&gt;10 max 2的含义是什么？max方法定义在哪个类中？&lt;/h2&gt;

&lt;p&gt;直接在REPL中执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; 10 max 2
res0: Int = 10

scala&amp;gt; 7 max 8
res1: Int = 8

scala&amp;gt; 0 max 0
res2: Int = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出,此方法返回两个数字中较大的那个。此方法Java中不存在，所以在RichInt中。&lt;/p&gt;

&lt;h2&gt;用BigInt计算2的1024次方&lt;/h2&gt;

&lt;p&gt;简单的API调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; BigInt(2).pow(1024)
res4: scala.math.BigInt = 17976931348623159077293051907890247336179769789423065727343008115
7732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124
3777678934248654852763022196012460941194530829520850057688381506823424628814739131105408272
37163350510684586298239947245938479716304835356329624224137216
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Radom之前使用任何限定符，你需要引入什么？&lt;/h2&gt;

&lt;p&gt;so easy.
import需要的包啊。Random在scala.util中，而probablePrime是BigInt中的方法，引入即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.BigInt._
import scala.util.Random

probablePrime(3,Random)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似&quot;qsnvbevtomcj38o06kul&quot;这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。&lt;/h2&gt;

&lt;p&gt;到BigInt中查找方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; scala.math.BigInt(scala.util.Random.nextInt).toString(36)
res21: String = utydx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在Scala中如何获取字符串的首字符和尾字符？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;//获取首字符
&quot;Hello&quot;(0)
&quot;Hello&quot;.take(1)
//获取尾字符
&quot;Hello&quot;.reverse(0)
&quot;Hello&quot;.takeRight(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？&lt;/h2&gt;

&lt;p&gt;查询API即可
take是从字符串首开始获取字符串,drop是从字符串首开始去除字符串。
takeRight和dropRight是从字符串尾开始操作。 这四个方法都是单方向的。
如果我想要字符串中间的子字符串，那么需要同时调用drop和dropRight，或者使用substring&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;基础&lt;/h1&gt;

&lt;h2&gt;在Scala REPL中键入3,然后按Tab键。有哪些方法可以被应用?&lt;/h2&gt;

&lt;p&gt;这个。。。。直接操作一遍就有结果了.此题不知是翻译的问题，还是原题的问题，在Scala
REPL中需要按3. 然后按Tab才会提示。 直接按3加Tab是没有提示的。下面是结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;!=             ##             %              &amp;amp;              *              +
-              /              &amp;lt;              &amp;lt;&amp;lt;             &amp;lt;=             ==
&amp;gt;              &amp;gt;=             &amp;gt;&amp;gt;             &amp;gt;&amp;gt;&amp;gt;            ^              asInstanceOf
equals         getClass       hashCode       isInstanceOf   toByte         toChar
toDouble       toFloat        toInt          toLong         toShort        toString
unary_+        unary_-        unary_~        |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出的方法并不全，需要查询全部方法还是需要到Scaladoc中的Int,Double,RichInt,RichDouble等类中去查看。&lt;/p&gt;

&lt;h2&gt;在Scala REPL中，计算3的平方根,然后再对该值求平方。现在，这个结果与3相差多少？(提示:res变量是你的朋友)&lt;/h2&gt;

&lt;p&gt;依次进行计算即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; scala.math.sqrt(3)
warning: there were 1 deprecation warnings; re-run with -deprecation for details
res5: Double = 1.7320508075688772

scala&amp;gt; res5*res5
res6: Double = 2.9999999999999996

scala&amp;gt; 3 - res6
res7: Double = 4.440892098500626E-16
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h2&gt;res变量是val还是var?&lt;/h2&gt;

&lt;p&gt;val是不可变的，而var是可变的，只需要给res变量重新赋值就可以检测res是val还是var了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; res9 = 3
&amp;lt;console&amp;gt;:8: error: reassignment to val
       res9 = 3
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Scala允许你用数字去乘字符串---去REPL中试一下&quot;crazy&quot;*3。这个操作做什么？在Scaladoc中如何找到这个操作?&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; &quot;crazy&quot;*3
res11: String = crazycrazycrazy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码可以推断,*是&quot;crazy&quot;这个字符串所具有的方法，但是Java中的String可没这个方法，很明显。此方法在StringOps中。&lt;/p&gt;

&lt;h2&gt;10 max 2的含义是什么？max方法定义在哪个类中？&lt;/h2&gt;

&lt;p&gt;直接在REPL中执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; 10 max 2
res0: Int = 10

scala&amp;gt; 7 max 8
res1: Int = 8

scala&amp;gt; 0 max 0
res2: Int = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出,此方法返回两个数字中较大的那个。此方法Java中不存在，所以在RichInt中。&lt;/p&gt;

&lt;h2&gt;用BigInt计算2的1024次方&lt;/h2&gt;

&lt;p&gt;简单的API调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; BigInt(2).pow(1024)
res4: scala.math.BigInt = 17976931348623159077293051907890247336179769789423065727343008115
7732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124
3777678934248654852763022196012460941194530829520850057688381506823424628814739131105408272
37163350510684586298239947245938479716304835356329624224137216
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Radom之前使用任何限定符，你需要引入什么？&lt;/h2&gt;

&lt;p&gt;so easy.
import需要的包啊。Random在scala.util中，而probablePrime是BigInt中的方法，引入即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;import scala.math.BigInt._
import scala.util.Random

probablePrime(3,Random)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似&quot;qsnvbevtomcj38o06kul&quot;这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。&lt;/h2&gt;

&lt;p&gt;到BigInt中查找方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;scala&amp;gt; scala.math.BigInt(scala.util.Random.nextInt).toString(36)
res21: String = utydx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;在Scala中如何获取字符串的首字符和尾字符？&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;{.scala}&quot;&gt;//获取首字符
&quot;Hello&quot;(0)
&quot;Hello&quot;.take(1)
//获取尾字符
&quot;Hello&quot;.reverse(0)
&quot;Hello&quot;.takeRight(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？&lt;/h2&gt;

&lt;p&gt;查询API即可
take是从字符串首开始获取字符串,drop是从字符串首开始去除字符串。
takeRight和dropRight是从字符串尾开始操作。 这四个方法都是单方向的。
如果我想要字符串中间的子字符串，那么需要同时调用drop和dropRight，或者使用substring&lt;/p&gt;
</summary>
    </entry>
    

</feed>
