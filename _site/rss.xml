<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

    <title>IvanPig's Blog</title>
    <link href="http://ivanpig.github.io/rss.xml" rel="self"/>
    <link href="http://ivanpig.github.io/"/>
    <updated>2015-02-02T11:11:23+08:00</updated>
    <id>http://ivanpig.github.io/</id>
    <author>
        <name>Ivan</name>
        <email>ivan.pig@foxmail.com</email>
    </author>

    
    <entry>
        <title>LightTable Theme</title>
        <link href="http://ivanpig.github.io/2014/11/28/pigtheme.html"/>
        <updated>2014-11-28T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2014/11/28/pigtheme</id>
        <content type="html">&lt;h1&gt;LightTable Theme&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;自用LightTable代码高亮配色,修改自solarized!&lt;/li&gt;
&lt;li&gt;从LightTable插件管理搜索pigtheme下载即可!&lt;/li&gt;
&lt;li&gt;主题修改为pigtheme生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/lighttable/shot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;LightTable Theme&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;自用LightTable代码高亮配色,修改自solarized!&lt;/li&gt;
&lt;li&gt;从LightTable插件管理搜索pigtheme下载即可!&lt;/li&gt;
&lt;li&gt;主题修改为pigtheme生效&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/assets/lighttable/shot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-升级</title>
        <link href="http://ivanpig.github.io/2013/10/02/upgrading.html"/>
        <updated>2013-10-02T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/10/02/upgrading</id>
        <content type="html">&lt;h1&gt;Upgrading to the Latest Version&lt;/h1&gt;

&lt;p&gt;不幸的是，框架无法自动从老版本升级到新版本。主要原因是新版本的依赖可能会有接口方面的修改，导致老代码无法正常运行。&lt;/p&gt;

&lt;p&gt;最好的方法是使用&lt;a href=&quot;https://github.com/xsc/lein-ancient&quot;&gt;lein-ancient&lt;/a&gt;插件来保持你的依赖包时刻为最新。这将会帮你很容易的发现哪些插件有了新的版本。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Upgrading to the Latest Version&lt;/h1&gt;

&lt;p&gt;不幸的是，框架无法自动从老版本升级到新版本。主要原因是新版本的依赖可能会有接口方面的修改，导致老代码无法正常运行。&lt;/p&gt;

&lt;p&gt;最好的方法是使用&lt;a href=&quot;https://github.com/xsc/lein-ancient&quot;&gt;lein-ancient&lt;/a&gt;插件来保持你的依赖包时刻为最新。这将会帮你很容易的发现哪些插件有了新的版本。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-实用库</title>
        <link href="http://ivanpig.github.io/2013/10/01/useful_libraries.html"/>
        <updated>2013-10-01T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/10/01/useful_libraries</id>
        <content type="html">&lt;p&gt;Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。&lt;/p&gt;

&lt;p&gt;包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，
Tower提供国际化等等其他包。&lt;/p&gt;

&lt;p&gt;当然，还有很多的包能给web开发带来便利。&lt;/p&gt;

&lt;p&gt;具体请见&lt;a href=&quot;http://www.luminusweb.net/docs/useful_libraries.md&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;p&gt;Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。&lt;/p&gt;

&lt;p&gt;包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，
Tower提供国际化等等其他包。&lt;/p&gt;

&lt;p&gt;当然，还有很多的包能给web开发带来便利。&lt;/p&gt;

&lt;p&gt;具体请见&lt;a href=&quot;http://www.luminusweb.net/docs/useful_libraries.md&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-部署</title>
        <link href="http://ivanpig.github.io/2013/09/30/deployment.html"/>
        <updated>2013-09-30T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/30/deployment</id>
        <content type="html">&lt;h1&gt;Running Standalone&lt;/h1&gt;

&lt;p&gt;要创建一个可独立运行的包，只需要运行如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包完成的jar会出现在target目录下。可以通过下面的命令运行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;java -jar myapp-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置\$PORT
环境变量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;export PORT=8080
java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Delpoying on Immutant&lt;/h1&gt;

&lt;p&gt;如果想部署应用到Immutant，请执行如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein immutant deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请访问&lt;a href=&quot;http://immutant.org/tutorials/deploying/index.html&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Deploying to Tomcat&lt;/h1&gt;

&lt;p&gt;如果想打包应用为war包:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后只需要将打好的包拷贝到tomcat的webapps目录下即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Heroku Deployment&lt;/h1&gt;

&lt;p&gt;首先确保你有git和Heroku，然后按照下面的步骤做就可以了。
要测试你的应用是否通过foreman在本地运行，只需要执行下面的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;foreman start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你能初始化你的git仓库，并提交你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git init
git add .
git commit -m &quot;init&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Heroku创建你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以创建数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku addons:add heroku-postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接信息可以在你的Heroku页面看到. 部署应用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你的应用就被部署到了Heroku上.
具体信息请看&lt;a href=&quot;https://devcenter.heroku.com/articles/clojure&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Running Standalone&lt;/h1&gt;

&lt;p&gt;要创建一个可独立运行的包，只需要运行如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打包完成的jar会出现在target目录下。可以通过下面的命令运行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;java -jar myapp-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置\$PORT
环境变量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;export PORT=8080
java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Delpoying on Immutant&lt;/h1&gt;

&lt;p&gt;如果想部署应用到Immutant，请执行如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein immutant deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请访问&lt;a href=&quot;http://immutant.org/tutorials/deploying/index.html&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Deploying to Tomcat&lt;/h1&gt;

&lt;p&gt;如果想打包应用为war包:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后只需要将打好的包拷贝到tomcat的webapps目录下即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Heroku Deployment&lt;/h1&gt;

&lt;p&gt;首先确保你有git和Heroku，然后按照下面的步骤做就可以了。
要测试你的应用是否通过foreman在本地运行，只需要执行下面的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;foreman start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你能初始化你的git仓库，并提交你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git init
git add .
git commit -m &quot;init&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Heroku创建你的应用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku create
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以创建数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;heroku addons:add heroku-postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接信息可以在你的Heroku页面看到. 部署应用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;git push heroku master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你的应用就被部署到了Heroku上.
具体信息请看&lt;a href=&quot;https://devcenter.heroku.com/articles/clojure&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-国际化</title>
        <link href="http://ivanpig.github.io/2013/09/29/internationalization.html"/>
        <updated>2013-09-29T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/29/internationalization</id>
        <content type="html">&lt;h1&gt;Internationalization&lt;/h1&gt;

&lt;p&gt;Luminius模板包含了&lt;a href=&quot;https://github.com/ptaoussanis/tower&quot;&gt;Tower&lt;/a&gt;依赖，Tower提供了函数式的国际化和翻译。&lt;/p&gt;

&lt;p&gt;首先，我们需要创建一个字典map：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def tconfig
  {:fallback-locale :en-US
   :dictionary
   {:en-US   {:page {:title &quot;Here is a title&quot;
                     :content &quot;Time to start building your site.&quot;}
              :missing  &quot;&amp;lt;Missing translation: [%1$s %2$s %3$s]&amp;gt;&quot;}
    :fr-FR {:page {:title &quot;Voici un titre&quot;
                   :content &quot;Il est temps de commencer votre site.&quot;}}
    }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Tower中间件来包装我们的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def app
 (app-handler
   [routes]
   :middleware
   [#(taoensso.tower.ring/wrap-tower-middleware % {:tconfig tconfig})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间件将会通过accept-language头来确定相应的语言。中间件将会添加两个key到请求中。地一个key是:t,它的值是翻译函数。第二个key是:locale，它的值是中间件提供的语言类型。&lt;/p&gt;

&lt;p&gt;你可以提供一个自定义的locale-selector函数给中间件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn my-selector [req]
  (when (= (:remote-addr req) &quot;127.0.0.1&quot;) :en))

(def app
  (app-handler
    [routes]
    :middleware
    [#(wrap-tower-middleware % {:tconfig tconfig
                                :locale-selector my-selector})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;中间件将按照如下顺序查找，会使用第一个有效的语言来进行处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(:locale request)
(when-let [ls locale-selector] (ls request))
(:locale session)
(:locale params)
(locale-from-headers headers)
fallback-locale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当中间件设置完成后，我们可以通过下面的代码来实现国际化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns mysite.routes.home
  (:use compojure.core)
  (:require [i18ntest.layout :as layout]
            [i18ntest.util :as util]
            [taoensso.tower :refer [t]]))

(defn home-page [{:keys [locale tconfig]}]
  (layout/render
    &quot;home.html&quot; {:title   (t locale tconfig :page/title)
                 :content (t locale tconfig :page/content)}))

(defn about-page []
  (layout/render &quot;about.html&quot;))

(defroutes home-routes
  (GET &quot;/&quot; req (home-page req))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Internationalization&lt;/h1&gt;

&lt;p&gt;Luminius模板包含了&lt;a href=&quot;https://github.com/ptaoussanis/tower&quot;&gt;Tower&lt;/a&gt;依赖，Tower提供了函数式的国际化和翻译。&lt;/p&gt;

&lt;p&gt;首先，我们需要创建一个字典map：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def tconfig
  {:fallback-locale :en-US
   :dictionary
   {:en-US   {:page {:title &quot;Here is a title&quot;
                     :content &quot;Time to start building your site.&quot;}
              :missing  &quot;&amp;lt;Missing translation: [%1$s %2$s %3$s]&amp;gt;&quot;}
    :fr-FR {:page {:title &quot;Voici un titre&quot;
                   :content &quot;Il est temps de commencer votre site.&quot;}}
    }})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Tower中间件来包装我们的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def app
 (app-handler
   [routes]
   :middleware
   [#(taoensso.tower.ring/wrap-tower-middleware % {:tconfig tconfig})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间件将会通过accept-language头来确定相应的语言。中间件将会添加两个key到请求中。地一个key是:t,它的值是翻译函数。第二个key是:locale，它的值是中间件提供的语言类型。&lt;/p&gt;

&lt;p&gt;你可以提供一个自定义的locale-selector函数给中间件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn my-selector [req]
  (when (= (:remote-addr req) &quot;127.0.0.1&quot;) :en))

(def app
  (app-handler
    [routes]
    :middleware
    [#(wrap-tower-middleware % {:tconfig tconfig
                                :locale-selector my-selector})]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;中间件将按照如下顺序查找，会使用第一个有效的语言来进行处理:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(:locale request)
(when-let [ls locale-selector] (ls request))
(:locale session)
(:locale params)
(locale-from-headers headers)
fallback-locale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当中间件设置完成后，我们可以通过下面的代码来实现国际化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns mysite.routes.home
  (:use compojure.core)
  (:require [i18ntest.layout :as layout]
            [i18ntest.util :as util]
            [taoensso.tower :refer [t]]))

(defn home-page [{:keys [locale tconfig]}]
  (layout/render
    &quot;home.html&quot; {:title   (t locale tconfig :page/title)
                 :content (t locale tconfig :page/content)}))

(defn about-page []
  (layout/render &quot;about.html&quot;))

(defroutes home-routes
  (GET &quot;/&quot; req (home-page req))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-日志</title>
        <link href="http://ivanpig.github.io/2013/09/28/logging.html"/>
        <updated>2013-09-28T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/28/logging</id>
        <content type="html">&lt;h1&gt;Logging&lt;/h1&gt;

&lt;p&gt;Luminus模板中包括&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Timbre&lt;/a&gt;和&lt;a href=&quot;https://bitbucket.org/postspectacular/rotor&quot;&gt;Rotor&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;日志通过在handler/init函数中进行如下的设置进行初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/append})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;.log&quot; :max-size 10000 :backlog 10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timbre可以记录Clojure的所有日志.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example
 (:use [taoensso.timbre :only [trace debug info warn error fatal]]))

(info &quot;Hello&quot;)

=&amp;gt;2012-Dec-24 09:03:09 -0500 Helios.local INFO [timbretest] - Hello

(info {:user {:id &quot;Anonymous&quot;}})

=&amp;gt;2012-Dec-24 09:02:44 -0500 Helios.local INFO [timbretest] - {:user {:id &quot;Anonymous&quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请见&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Logging&lt;/h1&gt;

&lt;p&gt;Luminus模板中包括&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Timbre&lt;/a&gt;和&lt;a href=&quot;https://bitbucket.org/postspectacular/rotor&quot;&gt;Rotor&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;日志通过在handler/init函数中进行如下的设置进行初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/append})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;.log&quot; :max-size 10000 :backlog 10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timbre可以记录Clojure的所有日志.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example
 (:use [taoensso.timbre :only [trace debug info warn error fatal]]))

(info &quot;Hello&quot;)

=&amp;gt;2012-Dec-24 09:03:09 -0500 Helios.local INFO [timbretest] - Hello

(info {:user {:id &quot;Anonymous&quot;}})

=&amp;gt;2012-Dec-24 09:02:44 -0500 Helios.local INFO [timbretest] - {:user {:id &quot;Anonymous&quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多信息请见&lt;a href=&quot;https://github.com/ptaoussanis/timbre&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-数据迁移</title>
        <link href="http://ivanpig.github.io/2013/09/27/database_migrations.html"/>
        <updated>2013-09-27T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/27/database_migrations</id>
        <content type="html">&lt;h1&gt;Migrations&lt;/h1&gt;

&lt;p&gt;默认情况下Luminus使用Ragtime来进行数据迁移。当你在创建Luminus项目时添加了+mysql或+postgres选项时，Ragtime会自动被添加进来。&lt;/p&gt;

&lt;h1&gt;Migrations with Ragtime&lt;/h1&gt;

&lt;p&gt;Ragtime通过Leiningen插件来执行。此插件需要配置project.clj的:plugins中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:plugins [... [ragtime/ragtime.lein &quot;0.3.4&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际的迁移动作是由ragtime.sql.files这个适配器来执行。此适配器需要配置在依赖列表中，同时配置相关数据库配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:dependencies [... [ragtime/ragtime.sql.files &quot;0.3.4&quot;]]
:ragtime {:migrations ragtime.sql.files/migrations
          :database &quot;jdbc:mysql://localhost:3306/example_db?user=root&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ragtime.sql.files适配器会从项目根目录下的指定目录查找sql脚本。我们只需要将脚本添加到对应目录下即可。&lt;/p&gt;

&lt;p&gt;脚本按字母顺序排序。我们来创建两个脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;migrations/2014-13-57-30-create-tables.up.sql

CREATE TABLE users (id INT, name VARCHAR(25));

migrations/2014-13-57-30-create-tables.down.sql

DROP TABLE users;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令回滚:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime rollback
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Migrations with Lobos&lt;/h1&gt;

&lt;p&gt;我们来看看如何在Luminus中集成Lobos.Lobos提供了功能强大的DSL来编
写迁移代码以及方便的对Korma进行扩展.&lt;/p&gt;

&lt;p&gt;首先，我们来创建一个Luminus项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus ltest +site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Lobos依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[lobos &quot;1.0.0-beta1&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们需要在src目录下创建一个lobos目录，并在该目录下创建两个文件
config.clj和migrations.clj，其中包含如下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.config
  (:use lobos.connectivity)
  (:require [ltest.models.schema :as schema]))

(open-global schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.migrations
  (:refer-clojure
   :exclude [alter drop bigint boolean char double float time])
  (:use (lobos [migration :only [defmigration]] core schema config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来创建我们的第一个迁移，使用lobos来管理create-users-table函数.
你只需要将create-users-table函数从schema.clj移动到migations.clj中即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmigration add-users-table
  (up [] (create
          (table :users
                 (varchar :id 20 :primary-key)
                 (varchar :first_name 30)
                 (varchar :last_name 30)
                 (varchar :email 30)
                 (boolean :admin)
                 (time    :last_login)
                 (boolean :is_active)
                 (varchar :pass 100))))
  (down [] (drop (table :users))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想添加其他的迁移，只需要再添加一个类似的definition即可。
现在我们定义了迁移，下面我们来看看schema命名空间，我们来更新并使用它。
我们将添加lobos.migration依赖:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns ltest.models.schema
  (:use [lobos.core :only (defcommand migrate)])
  (:require [noir.io :as io]
            [lobos.migration :as lm]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着定义一个command，返回给我们一个待迁移列表.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defcommand pending-migrations []
  (lm/pending-migrations db-spec sname))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据这个信息我们可以知道数据库的状态。我们来重命名initialised?和
actualized?函数，当待迁移列表没有数据时返回true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn actualized?
  &quot;checks if there are no pending migrations&quot;
  []
  (empty? (pending-migrations)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还需要将create-tables函数替换为actualize函数，actualize函数将会触
发迁移。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def actualize migrate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上actualize只是一个对migrate的引用，migrate是lobos.core中的函数.
最后我们需要做的就是更新handler.clj文件，来使用我们的新函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;runs when the application starts and checks if the database
   schema exists, calls schema/create-tables if not.&quot;
  []
  (if-not (schema/actualized?)
    (schema/actualize)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在运行你的服务器，你的应用将会自动运行所有的待执行迁移。
希望这个教程对你在Luminus中使用数据迁移有帮助。相关代码请见&lt;a href=&quot;https://github.com/edtsech/ltest&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Popular Migrations Alternatives&lt;/h1&gt;

&lt;p&gt;下面是几个比较流行的数据库迁移工具:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Drift - Drift是一个使用Clojure编写的数据库迁移工具。Drift工作方式和Rails迁移方式类似-使用一个目录来存放你所有的迁移文件。Drift将会决定去运行哪个合适的文件。&lt;/li&gt;
&lt;li&gt;Migratus - 一个通用的迁移框架，有一个数据库迁移的实现&lt;/li&gt;
&lt;li&gt;Ragtime - Ragtime是一个迁移结构化数据的Clojure库。它定义了一组接口来处理迁移，就像Ring定义了一组接口来处理web应用一样。&lt;/li&gt;
&lt;li&gt;Lobos - Lobos是一个使用Clojure编写的SQL数据库操作和迁移库.目前它提供对H2,MySQL,PostgreSQL,SQLite和SQL Server的支持.&lt;/li&gt;
&lt;/ul&gt;

</content>
        <summary type="html">&lt;h1&gt;Migrations&lt;/h1&gt;

&lt;p&gt;默认情况下Luminus使用Ragtime来进行数据迁移。当你在创建Luminus项目时添加了+mysql或+postgres选项时，Ragtime会自动被添加进来。&lt;/p&gt;

&lt;h1&gt;Migrations with Ragtime&lt;/h1&gt;

&lt;p&gt;Ragtime通过Leiningen插件来执行。此插件需要配置project.clj的:plugins中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:plugins [... [ragtime/ragtime.lein &quot;0.3.4&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际的迁移动作是由ragtime.sql.files这个适配器来执行。此适配器需要配置在依赖列表中，同时配置相关数据库配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:dependencies [... [ragtime/ragtime.sql.files &quot;0.3.4&quot;]]
:ragtime {:migrations ragtime.sql.files/migrations
          :database &quot;jdbc:mysql://localhost:3306/example_db?user=root&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ragtime.sql.files适配器会从项目根目录下的指定目录查找sql脚本。我们只需要将脚本添加到对应目录下即可。&lt;/p&gt;

&lt;p&gt;脚本按字母顺序排序。我们来创建两个脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;migrations/2014-13-57-30-create-tables.up.sql

CREATE TABLE users (id INT, name VARCHAR(25));

migrations/2014-13-57-30-create-tables.down.sql

DROP TABLE users;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过如下命令回滚:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lein ragtime rollback
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Migrations with Lobos&lt;/h1&gt;

&lt;p&gt;我们来看看如何在Luminus中集成Lobos.Lobos提供了功能强大的DSL来编
写迁移代码以及方便的对Korma进行扩展.&lt;/p&gt;

&lt;p&gt;首先，我们来创建一个Luminus项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus ltest +site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Lobos依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[lobos &quot;1.0.0-beta1&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着我们需要在src目录下创建一个lobos目录，并在该目录下创建两个文件
config.clj和migrations.clj，其中包含如下内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.config
  (:use lobos.connectivity)
  (:require [ltest.models.schema :as schema]))

(open-global schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns lobos.migrations
  (:refer-clojure
   :exclude [alter drop bigint boolean char double float time])
  (:use (lobos [migration :only [defmigration]] core schema config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来创建我们的第一个迁移，使用lobos来管理create-users-table函数.
你只需要将create-users-table函数从schema.clj移动到migations.clj中即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defmigration add-users-table
  (up [] (create
          (table :users
                 (varchar :id 20 :primary-key)
                 (varchar :first_name 30)
                 (varchar :last_name 30)
                 (varchar :email 30)
                 (boolean :admin)
                 (time    :last_login)
                 (boolean :is_active)
                 (varchar :pass 100))))
  (down [] (drop (table :users))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想添加其他的迁移，只需要再添加一个类似的definition即可。
现在我们定义了迁移，下面我们来看看schema命名空间，我们来更新并使用它。
我们将添加lobos.migration依赖:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns ltest.models.schema
  (:use [lobos.core :only (defcommand migrate)])
  (:require [noir.io :as io]
            [lobos.migration :as lm]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着定义一个command，返回给我们一个待迁移列表.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defcommand pending-migrations []
  (lm/pending-migrations db-spec sname))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据这个信息我们可以知道数据库的状态。我们来重命名initialised?和
actualized?函数，当待迁移列表没有数据时返回true&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn actualized?
  &quot;checks if there are no pending migrations&quot;
  []
  (empty? (pending-migrations)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还需要将create-tables函数替换为actualize函数，actualize函数将会触
发迁移。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def actualize migrate)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上actualize只是一个对migrate的引用，migrate是lobos.core中的函数.
最后我们需要做的就是更新handler.clj文件，来使用我们的新函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;runs when the application starts and checks if the database
   schema exists, calls schema/create-tables if not.&quot;
  []
  (if-not (schema/actualized?)
    (schema/actualize)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在运行你的服务器，你的应用将会自动运行所有的待执行迁移。
希望这个教程对你在Luminus中使用数据迁移有帮助。相关代码请见&lt;a href=&quot;https://github.com/edtsech/ltest&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Popular Migrations Alternatives&lt;/h1&gt;

&lt;p&gt;下面是几个比较流行的数据库迁移工具:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Drift - Drift是一个使用Clojure编写的数据库迁移工具。Drift工作方式和Rails迁移方式类似-使用一个目录来存放你所有的迁移文件。Drift将会决定去运行哪个合适的文件。&lt;/li&gt;
&lt;li&gt;Migratus - 一个通用的迁移框架，有一个数据库迁移的实现&lt;/li&gt;
&lt;li&gt;Ragtime - Ragtime是一个迁移结构化数据的Clojure库。它定义了一组接口来处理迁移，就像Ring定义了一组接口来处理web应用一样。&lt;/li&gt;
&lt;li&gt;Lobos - Lobos是一个使用Clojure编写的SQL数据库操作和迁移库.目前它提供对H2,MySQL,PostgreSQL,SQLite和SQL Server的支持.&lt;/li&gt;
&lt;/ul&gt;

</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-访问数据库</title>
        <link href="http://ivanpig.github.io/2013/09/26/database_access.html"/>
        <updated>2013-09-26T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/26/database_access</id>
        <content type="html">&lt;h1&gt;Configuring the Database&lt;/h1&gt;

&lt;p&gt;当你使用数据库参数来创建Luminus工程时，比如+postgress，那么Luminus会使用Korma来处理数据库操作.&lt;/p&gt;

&lt;p&gt;Korma是一个基于Clojure的数据库操作DSL。Korma提供了一套简单的接口，方便你来处理复杂的数据。&lt;/p&gt;

&lt;p&gt;给一个现有的项目添加数据库支持，非常的简单。首先，你需要在project.clj文件中添加Korma依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[korma &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还需要相应数据库的驱动，所以你还需要在project.clj中添加相关的数据库驱动。比如说，你要连接PostreSQL数据库，你需要添加如下的依赖.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[postgresql/postgresql &quot;9.3-1102-jdbc41&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完依赖后，你可以创建一个新的namespace来管理你的model,这个namespace建议叫db.core。你需要在里面引入korma.db。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:use korma.core
        [korma.db :only (defdb)]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Setting up the database connection&lt;/h2&gt;

&lt;p&gt;配置完依赖后，我们要做的事情就是定义数据库连接。我们只需要提供一个包含连接信息的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:subprotocol &quot;postgresql&quot;
         :subname &quot;//localhost/my_website&quot;
         :user &quot;admin&quot;
         :password &quot;admin&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者也可以配置服务器提供的JNDI名称来创建连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:name &quot;jdbc/myDatasource&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这种方式适合当你有多个连接的时候。比如说，你有个dev/staging/production
服务器，你可以将JNDI连接指向它所配置的数据库。应用程序将会从环境中来加
载数据库连接信息。这意味着，你可以随意的改变你的数据库连接，而不需要修
改你的代码。 最后，你能自己配置JDBC连接:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec
  {:datasource
    (doto (new PGPoolingDataSource)
     (.setServerName   &quot;localhost&quot;)
     (.setDatabaseName &quot;my_website&quot;)
     (.setUser         &quot;admin&quot;)
     (.setPassword     &quot;admin&quot;)
     (.setMaxConnections 10))})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Creating tables&lt;/h2&gt;

&lt;p&gt;Korma依赖clojure.java.jdbc.这个库提供操作表的功能。&lt;/p&gt;

&lt;p&gt;你可以使用create-table函数来从应用中创建数据表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn create-users-table []
  (sql/db-do-commands db-spec
    (sql/create-table-ddl
      :users
      [:id &quot;varchar(32)&quot;]
      [:pass &quot;varchar(100)&quot;])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create-table-ddl函数需要包含在db-do-commands内，db-do-commands保证了数据库连接的关闭。&lt;/p&gt;

&lt;h1&gt;Accessing the Database&lt;/h1&gt;

&lt;p&gt;当使用Korma时，你需要先用defdb来包裹db-spec。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defdb db schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会使用c3p0来创建一个连接池。需要注意的是，最后创建的连接池会被设为默认的连接池。&lt;/p&gt;

&lt;p&gt;Korma使用entities来表示sql表。这个entities构成了你查询的核心。&lt;/p&gt;

&lt;p&gt;entities使用defentity宏来创建:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defentity users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来创建user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-user [user]
  (insert users
          (values user)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果我们想查询user，我们可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn get-user [id]
  (first (select users
                 (where {:id id})
                 (limit 1))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细文档可参考&lt;a href=&quot;http://sqlkorma.com/docs&quot;&gt;Korma官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Yesql&lt;/h1&gt;

&lt;p&gt;Korma提供了操作SQL的DSL，而Yesql可以直接操作SQL.&lt;/p&gt;

&lt;p&gt;如果要使用Yesql你需要添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[yesql &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在classpath下创建一个包含查询的SQL文件，比如resources/queries.sql.文件格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -- name: find-users
    -- Find the users with the given ID(s).
    SELECT *
    FROM user
    WHERE user_id IN (:id)
    AND age &amp;gt; :min_age

    -- name: user-count
    -- Counts all the users.
    SELECT count(*) AS count
    FROM user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建问上述文件后，你需要在需要的地方引入yesql.core/defqueries。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:require [yesql.core :refer [defqueries]]))

(defqueries &quot;resources/queries.sql&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个查询可以像函数一样通过名字来调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(find-users db-spec [1001 1003 1005] 18)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Configuring the Database&lt;/h1&gt;

&lt;p&gt;当你使用数据库参数来创建Luminus工程时，比如+postgress，那么Luminus会使用Korma来处理数据库操作.&lt;/p&gt;

&lt;p&gt;Korma是一个基于Clojure的数据库操作DSL。Korma提供了一套简单的接口，方便你来处理复杂的数据。&lt;/p&gt;

&lt;p&gt;给一个现有的项目添加数据库支持，非常的简单。首先，你需要在project.clj文件中添加Korma依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[korma &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还需要相应数据库的驱动，所以你还需要在project.clj中添加相关的数据库驱动。比如说，你要连接PostreSQL数据库，你需要添加如下的依赖.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[postgresql/postgresql &quot;9.3-1102-jdbc41&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完依赖后，你可以创建一个新的namespace来管理你的model,这个namespace建议叫db.core。你需要在里面引入korma.db。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:use korma.core
        [korma.db :only (defdb)]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Setting up the database connection&lt;/h2&gt;

&lt;p&gt;配置完依赖后，我们要做的事情就是定义数据库连接。我们只需要提供一个包含连接信息的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:subprotocol &quot;postgresql&quot;
         :subname &quot;//localhost/my_website&quot;
         :user &quot;admin&quot;
         :password &quot;admin&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者也可以配置服务器提供的JNDI名称来创建连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec {:name &quot;jdbc/myDatasource&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这种方式适合当你有多个连接的时候。比如说，你有个dev/staging/production
服务器，你可以将JNDI连接指向它所配置的数据库。应用程序将会从环境中来加
载数据库连接信息。这意味着，你可以随意的改变你的数据库连接，而不需要修
改你的代码。 最后，你能自己配置JDBC连接:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def db-spec
  {:datasource
    (doto (new PGPoolingDataSource)
     (.setServerName   &quot;localhost&quot;)
     (.setDatabaseName &quot;my_website&quot;)
     (.setUser         &quot;admin&quot;)
     (.setPassword     &quot;admin&quot;)
     (.setMaxConnections 10))})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Creating tables&lt;/h2&gt;

&lt;p&gt;Korma依赖clojure.java.jdbc.这个库提供操作表的功能。&lt;/p&gt;

&lt;p&gt;你可以使用create-table函数来从应用中创建数据表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn create-users-table []
  (sql/db-do-commands db-spec
    (sql/create-table-ddl
      :users
      [:id &quot;varchar(32)&quot;]
      [:pass &quot;varchar(100)&quot;])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;create-table-ddl函数需要包含在db-do-commands内，db-do-commands保证了数据库连接的关闭。&lt;/p&gt;

&lt;h1&gt;Accessing the Database&lt;/h1&gt;

&lt;p&gt;当使用Korma时，你需要先用defdb来包裹db-spec。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defdb db schema/db-spec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会使用c3p0来创建一个连接池。需要注意的是，最后创建的连接池会被设为默认的连接池。&lt;/p&gt;

&lt;p&gt;Korma使用entities来表示sql表。这个entities构成了你查询的核心。&lt;/p&gt;

&lt;p&gt;entities使用defentity宏来创建:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defentity users)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来创建user:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-user [user]
  (insert users
          (values user)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果我们想查询user，我们可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn get-user [id]
  (first (select users
                 (where {:id id})
                 (limit 1))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细文档可参考&lt;a href=&quot;http://sqlkorma.com/docs&quot;&gt;Korma官网&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Yesql&lt;/h1&gt;

&lt;p&gt;Korma提供了操作SQL的DSL，而Yesql可以直接操作SQL.&lt;/p&gt;

&lt;p&gt;如果要使用Yesql你需要添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[yesql &quot;0.4.0&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在classpath下创建一个包含查询的SQL文件，比如resources/queries.sql.文件格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -- name: find-users
    -- Find the users with the given ID(s).
    SELECT *
    FROM user
    WHERE user_id IN (:id)
    AND age &amp;gt; :min_age

    -- name: user-count
    -- Counts all the users.
    SELECT count(*) AS count
    FROM user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建问上述文件后，你需要在需要的地方引入yesql.core/defqueries。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.db.core
  (:require [yesql.core :refer [defqueries]]))

(defqueries &quot;resources/queries.sql&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个查询可以像函数一样通过名字来调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(find-users db-spec [1001 1003 1005] 18)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-安全</title>
        <link href="http://ivanpig.github.io/2013/09/25/security.html"/>
        <updated>2013-09-25T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/25/security</id>
        <content type="html">&lt;h1&gt;Security&lt;/h1&gt;

&lt;p&gt;密码的散列和对比由noir.util.crypt提供。&lt;/p&gt;

&lt;p&gt;他提供了两个函数$encrypt$,$compare$.其中第一个函数加密密码，而第二个则是对比密码。实际上加密是通过BCrypt来处理的。&lt;/p&gt;

&lt;p&gt;对比代码的函数看起来像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(compare raw encrypted)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加密函数可以自定义salt，或者就不使用salt加密。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(encrypt salt raw)
(encrypt raw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想了解Secutiry库的更多内容，&lt;a href=&quot;https://github.com/cemerick/friend&quot;&gt;请点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;LDAP Authentication&lt;/h1&gt;

&lt;p&gt;下面的列子演示了如何通过clj-ldap来验证sAMAccountName&lt;/p&gt;

&lt;p&gt;首先，我们先添加依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[org.clojars.pntblnk/clj-ldap &quot;0.0.9&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要引入authentication命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns ldap-auth
  (:require [clj-ldap.client :as client]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;我们可以像下面这样定义LDAP主机。注意host键指向一个Vector。这个Vector里可以包含多个LDAP服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def host
  {:host
    [{:address &quot;my-ldap-server.ca&quot;
      :port 389
      :connect-timeout (* 1000 5)
      :timeout (* 1000 30)}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们可以编写一个函数使用上面的LDAP来验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn authenticate [username password &amp;amp; [attributes]]
  (let [server (client/connect host)
        qualified-name (str username &quot;@&quot; (-&amp;gt; host :host first :address))]
    (if (client/bind? server qualified-name  password)
      (first (client/search server &quot;OU=MyOrgPeople,DC=myorg,DC=ca&quot;
                            {:filter (str &quot;sAMAccountName=&quot; username)
                             :attributes (or attributes [])})))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性Vector可以用来过滤返回值，如果所有的验证都通过，则返回空Vector&lt;/p&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击是第三方通过拦截已登录的用户来操作你的网站的一个攻击。此攻击一般通过你的网站的恶意链接，表单提交或js来进行攻击。&lt;/p&gt;

&lt;p&gt;Ring-Anti-Forgery使用来防止CSRF攻击的。只需要引入相关命名空间并将mk-defaults设为true即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def app (app-handler
           [home-routes base-routes]
           :middleware (load-middleware)
           ;; set this to true in order to enable CSRF protection
           :ring-defaults (mk-defaults true)
           :access-rules []
           :formats [:json-kw :edn :transit-json]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当CSRF中间件开启后，一个随机产生的字符串会被绑定到anti-forgery-token上。任何POST请求需要包含__anti-forgery-token。&lt;/p&gt;

&lt;p&gt;我们需要先引入anti-forgery。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(require ... [ring.util.anti-forgery :refer [anti-forgery-field]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，定义一个CSRF标签到我们的初始化函数中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn init
  ...
  (parser/add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在表单中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
      &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有包含此token的POST请求会被拦截。服务器响应403&quot;Invalid anti-forgery token&quot;。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Security&lt;/h1&gt;

&lt;p&gt;密码的散列和对比由noir.util.crypt提供。&lt;/p&gt;

&lt;p&gt;他提供了两个函数$encrypt$,$compare$.其中第一个函数加密密码，而第二个则是对比密码。实际上加密是通过BCrypt来处理的。&lt;/p&gt;

&lt;p&gt;对比代码的函数看起来像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(compare raw encrypted)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加密函数可以自定义salt，或者就不使用salt加密。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(encrypt salt raw)
(encrypt raw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想了解Secutiry库的更多内容，&lt;a href=&quot;https://github.com/cemerick/friend&quot;&gt;请点击这里&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;LDAP Authentication&lt;/h1&gt;

&lt;p&gt;下面的列子演示了如何通过clj-ldap来验证sAMAccountName&lt;/p&gt;

&lt;p&gt;首先，我们先添加依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[org.clojars.pntblnk/clj-ldap &quot;0.0.9&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，我们需要引入authentication命名空间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns ldap-auth
  (:require [clj-ldap.client :as client]))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;我们可以像下面这样定义LDAP主机。注意host键指向一个Vector。这个Vector里可以包含多个LDAP服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def host
  {:host
    [{:address &quot;my-ldap-server.ca&quot;
      :port 389
      :connect-timeout (* 1000 5)
      :timeout (* 1000 30)}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们可以编写一个函数使用上面的LDAP来验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn authenticate [username password &amp;amp; [attributes]]
  (let [server (client/connect host)
        qualified-name (str username &quot;@&quot; (-&amp;gt; host :host first :address))]
    (if (client/bind? server qualified-name  password)
      (first (client/search server &quot;OU=MyOrgPeople,DC=myorg,DC=ca&quot;
                            {:filter (str &quot;sAMAccountName=&quot; username)
                             :attributes (or attributes [])})))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性Vector可以用来过滤返回值，如果所有的验证都通过，则返回空Vector&lt;/p&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击是第三方通过拦截已登录的用户来操作你的网站的一个攻击。此攻击一般通过你的网站的恶意链接，表单提交或js来进行攻击。&lt;/p&gt;

&lt;p&gt;Ring-Anti-Forgery使用来防止CSRF攻击的。只需要引入相关命名空间并将mk-defaults设为true即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(def app (app-handler
           [home-routes base-routes]
           :middleware (load-middleware)
           ;; set this to true in order to enable CSRF protection
           :ring-defaults (mk-defaults true)
           :access-rules []
           :formats [:json-kw :edn :transit-json]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当CSRF中间件开启后，一个随机产生的字符串会被绑定到anti-forgery-token上。任何POST请求需要包含__anti-forgery-token。&lt;/p&gt;

&lt;p&gt;我们需要先引入anti-forgery。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(require ... [ring.util.anti-forgery :refer [anti-forgery-field]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，定义一个CSRF标签到我们的初始化函数中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn init
  ...
  (parser/add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在表单中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
      &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有包含此token的POST请求会被拦截。服务器响应403&quot;Invalid anti-forgery token&quot;。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-输入验证</title>
        <link href="http://ivanpig.github.io/2013/09/24/input_validation.html"/>
        <updated>2013-09-24T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/24/input_validation</id>
        <content type="html">&lt;h1&gt;Input Validation&lt;/h1&gt;

&lt;p&gt;验证相关助手方法在noir.validation命名空间中。如果我们要使用验证，我们需要先引入这个命名空间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.routes
  (:require ... [noir.validation :as v]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证函数在当验证不通过时，将相应的错误设置到对应的字段上。验证函数接受一个条件函数和一个包含了需要验证的字段和错误信息的Vector.当验证函数验证通过时需要返回true否则返回false.&lt;/p&gt;

&lt;p&gt;下面是已经存在的验证函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;has-value? args: [v] - returns true if v is truthy and not an empty string.
has-values? args: [coll] - returns true if all members of the collection has-value? This works on maps as well.
not-nil? args: [v] - returns true if v is not nil
min-length? args: [v len] - returns true if v is greater than or equal to the given len
max-length? args: [v len - returns true if v is less than or equal to the given len
matches-regex? args: [v regex] - returns true if the string matches the given regular expression
is-email? args: [v] - returns true if v is an email address
valid-file? args: [m] - returns true if a valid file was supplied
valid-number? args: [v] - returns true if the string can be parsed to a Long
greater-than? args: [v n] - returns true if the string represents a number &amp;gt; given
less-than? args: [v n] - returns true if the string represents a number &amp;lt; given
equal-to? args: [v n] - returns true if the string represents a number = given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：如果我们想检查id和pass字段不能为空，则可以创建如下验证规则：&lt;/p&gt;

&lt;p&gt;````clojure
(v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])&lt;/p&gt;

&lt;p&gt;(v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])
```&lt;/p&gt;

&lt;p&gt;错误信息被保存在noir.validation/&lt;em&gt;errors&lt;/em&gt;这个atom中，这个atom被绑定到了request上。每个error都包含一个key和一个对应的错误Vector.验证函数可以在同一字段上多次调用来设置多个错误。&lt;/p&gt;

&lt;p&gt;一旦验证规则被执行了，我们可以通过errors?这个函数来检查是否有错误。如果没有传递参数，则此函数会检查noir.validation/&lt;em&gt;error&lt;/em&gt;是否为空，如果传递了参数，次函数根据传递的值来查询是否有错误。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns true if any errors have been set
(v/errors?)
;; returns true if any errors have been set for the key :id
(v/errors? :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，我们可以通过调用get-errors函数来获取当前的错误。当不传递参数时，返回所有的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns a sequence of all errors that have been set
(v/get-errors)
;; returns all the errors set for the key :id
(v/get-errors :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以通过on-error来提供自定义的错误处理函数。这个函数需要一个字段相关联的error集合作为参数。函数结果由on-error返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/on-error :id (fn [errors] (clojure.string/join &quot;, &quot; errors)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，错误可以通过clear-errors!函数来清除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/clear-errors!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个完整的登录相关验证。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn set-errors [id pass]
  (v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])

  (v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])

  (if (v/errors? :id :pass)
    {:body {:status &quot;error&quot; :errors (get-errors)}}
    (do
    (session/put! :user id)
     {:body {:status &quot;ok&quot;}})))
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Input Validation&lt;/h1&gt;

&lt;p&gt;验证相关助手方法在noir.validation命名空间中。如果我们要使用验证，我们需要先引入这个命名空间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(ns myapp.routes
  (:require ... [noir.validation :as v]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证函数在当验证不通过时，将相应的错误设置到对应的字段上。验证函数接受一个条件函数和一个包含了需要验证的字段和错误信息的Vector.当验证函数验证通过时需要返回true否则返回false.&lt;/p&gt;

&lt;p&gt;下面是已经存在的验证函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;has-value? args: [v] - returns true if v is truthy and not an empty string.
has-values? args: [coll] - returns true if all members of the collection has-value? This works on maps as well.
not-nil? args: [v] - returns true if v is not nil
min-length? args: [v len] - returns true if v is greater than or equal to the given len
max-length? args: [v len - returns true if v is less than or equal to the given len
matches-regex? args: [v regex] - returns true if the string matches the given regular expression
is-email? args: [v] - returns true if v is an email address
valid-file? args: [m] - returns true if a valid file was supplied
valid-number? args: [v] - returns true if the string can be parsed to a Long
greater-than? args: [v n] - returns true if the string represents a number &amp;gt; given
less-than? args: [v n] - returns true if the string represents a number &amp;lt; given
equal-to? args: [v n] - returns true if the string represents a number = given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：如果我们想检查id和pass字段不能为空，则可以创建如下验证规则：&lt;/p&gt;

&lt;p&gt;````clojure
(v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])&lt;/p&gt;

&lt;p&gt;(v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])
```&lt;/p&gt;

&lt;p&gt;错误信息被保存在noir.validation/&lt;em&gt;errors&lt;/em&gt;这个atom中，这个atom被绑定到了request上。每个error都包含一个key和一个对应的错误Vector.验证函数可以在同一字段上多次调用来设置多个错误。&lt;/p&gt;

&lt;p&gt;一旦验证规则被执行了，我们可以通过errors?这个函数来检查是否有错误。如果没有传递参数，则此函数会检查noir.validation/&lt;em&gt;error&lt;/em&gt;是否为空，如果传递了参数，次函数根据传递的值来查询是否有错误。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns true if any errors have been set
(v/errors?)
;; returns true if any errors have been set for the key :id
(v/errors? :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似的，我们可以通过调用get-errors函数来获取当前的错误。当不传递参数时，返回所有的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; returns a sequence of all errors that have been set
(v/get-errors)
;; returns all the errors set for the key :id
(v/get-errors :id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还可以通过on-error来提供自定义的错误处理函数。这个函数需要一个字段相关联的error集合作为参数。函数结果由on-error返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/on-error :id (fn [errors] (clojure.string/join &quot;, &quot; errors)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，错误可以通过clear-errors!函数来清除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(v/clear-errors!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个完整的登录相关验证。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;(defn set-errors [id pass]
  (v/rule (has-value? id)
        [:id &quot;screen name is required&quot;])

  (v/rule (has-value? pass)
        [:pass &quot;password is required&quot;])

  (if (v/errors? :id :pass)
    {:body {:status &quot;error&quot; :errors (get-errors)}}
    (do
    (session/put! :user id)
     {:body {:status &quot;ok&quot;}})))
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-Session与Cookie</title>
        <link href="http://ivanpig.github.io/2013/09/23/sessions_cookies.html"/>
        <updated>2013-09-23T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/23/sessions_cookies</id>
        <content type="html">&lt;h1&gt;Sessions&lt;/h1&gt;

&lt;p&gt;Session管理相关功能由noir.session提供。默认提供的noir.util.middleware/app-handler函数默认将Session保存在内存里。&lt;/p&gt;

&lt;p&gt;当然你可以修改它，只需要给函数传递第二个参数，告诉它将Session保存在哪里就可
以了。 下面的例子创建了一个保存在内存里的session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler [home-routes app-routes]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面，我们来重新定义session的保存位置。使用:session-options来替换掉默认的值就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app
  (middleware/app-handler
    [home-routes app-routes]
    :session-options {:cookie-name &quot;example-app-session&quot;
                      :store (cookie-store)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Accessing the session&lt;/h1&gt;

&lt;p&gt;你可以在任意范围内的任何函数里访问并操作session。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.session :as session])

(defn set-user [id]
  (session/put! :user id)
  (session/get :user))

(defn remove-user []
  (session/remove! :user)
  (session/get :user))

(defn set-user-if-nil [id]
  (session/get :user id))

(defn clear-session []
  (session/clear!))

(defroutes app-routes
  (GET &quot;/login/:id&quot; [id] (set-user id))
  (GET &quot;/remove&quot; [] (remove-user))
  (GET &quot;/set-if-nil/:id&quot; [id] (set-user-if-nil id))
  (GET &quot;/logout&quot; [] (clear-session)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以通过noir.session/flash-put!和noir.session/flash-get来创建flash变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(session/flash-put! :message &quot;User added!&quot;)
(session/flash-get :message)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Cookies&lt;/h1&gt;

&lt;p&gt;Cookie处理函数由noir.cookies提供。设置或获取Cookie和Session很类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.cookies :as cookies])

(defn set-user-cookie [id]
  (cookies/put! :user id)
  (cookies/get :user))

(defn set-user-if-nil [id]
  (cookies/get :user id))

(cookies/put! :track
              {:value (str (java.util.UUID/randomUUID))
              :path &quot;/&quot;
              :expires 1})
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Sessions&lt;/h1&gt;

&lt;p&gt;Session管理相关功能由noir.session提供。默认提供的noir.util.middleware/app-handler函数默认将Session保存在内存里。&lt;/p&gt;

&lt;p&gt;当然你可以修改它，只需要给函数传递第二个参数，告诉它将Session保存在哪里就可
以了。 下面的例子创建了一个保存在内存里的session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler [home-routes app-routes]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面，我们来重新定义session的保存位置。使用:session-options来替换掉默认的值就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app
  (middleware/app-handler
    [home-routes app-routes]
    :session-options {:cookie-name &quot;example-app-session&quot;
                      :store (cookie-store)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Accessing the session&lt;/h1&gt;

&lt;p&gt;你可以在任意范围内的任何函数里访问并操作session。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.session :as session])

(defn set-user [id]
  (session/put! :user id)
  (session/get :user))

(defn remove-user []
  (session/remove! :user)
  (session/get :user))

(defn set-user-if-nil [id]
  (session/get :user id))

(defn clear-session []
  (session/clear!))

(defroutes app-routes
  (GET &quot;/login/:id&quot; [id] (set-user id))
  (GET &quot;/remove&quot; [] (remove-user))
  (GET &quot;/set-if-nil/:id&quot; [id] (set-user-if-nil id))
  (GET &quot;/logout&quot; [] (clear-session)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你还可以通过noir.session/flash-put!和noir.session/flash-get来创建flash变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(session/flash-put! :message &quot;User added!&quot;)
(session/flash-get :message)
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Cookies&lt;/h1&gt;

&lt;p&gt;Cookie处理函数由noir.cookies提供。设置或获取Cookie和Session很类似。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.cookies :as cookies])

(defn set-user-cookie [id]
  (cookies/put! :user id)
  (cookies/get :user))

(defn set-user-if-nil [id]
  (cookies/get :user id))

(cookies/put! :track
              {:value (str (java.util.UUID/randomUUID))
              :path &quot;/&quot;
              :expires 1})
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-自定义中间件</title>
        <link href="http://ivanpig.github.io/2013/09/22/custom_middleware.html"/>
        <updated>2013-09-22T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/22/custom_middleware</id>
        <content type="html">&lt;h1&gt;Adding custom middleware&lt;/h1&gt;

&lt;p&gt;Luminus使用Ring来路由应用的处理程序，你也可以添加一些中间件。&lt;/p&gt;

&lt;p&gt;中间件可以给处理程序添加一些额外的功能。中间件函数主要被用来扩展Ring的基本处理函数。&lt;/p&gt;

&lt;p&gt;中间件其实就是个简单的函数，它接受现有的处理程序和一些可选参数作为函数参数并返回一个新的处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn wrap-nocache [handler]
  (fn [request]
     (let [response (handler request)]
        (assoc-in response [:headers  &quot;Pragma&quot;] &quot;no-cache&quot;))))

(def app (wrap-nocache handler))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上面的函数接受一个处理函数并返回一个新的函数，这个函数接受request作为参数。返回的函数只在handler所在的范围内有效。当调用这个函数时，它将会给响应map添加Pragma:no-cache键值对。&lt;/p&gt;

&lt;p&gt;你可以添加自定义的中间件，只需要使用:middleware关键字就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          ;;put any custom middleware
          ;;in the middleware vector
          :middleware [wrap-nocache]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体内容可参见Ring官方文档。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Useful ring middleware&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ring-middleware-format - Ring middleware for handling different fromats such as JSON and EDN&lt;/li&gt;
&lt;li&gt;ring-ratelimit - Rate limiting middleware&lt;/li&gt;
&lt;li&gt;ring-etag-middleware - Calculates etags for ring responses and returns 304 responses when appropriate&lt;/li&gt;
&lt;li&gt;ring-gzip-middleware - Gzips ring responses for user agents which can handle it&lt;/li&gt;
&lt;li&gt;ring-upload-progress - Provide upload progress data in ring session&lt;/li&gt;
&lt;li&gt;ring-anti-forgery - Ring middleware to prevent CSRF attacks&lt;/li&gt;
&lt;/ul&gt;

</content>
        <summary type="html">&lt;h1&gt;Adding custom middleware&lt;/h1&gt;

&lt;p&gt;Luminus使用Ring来路由应用的处理程序，你也可以添加一些中间件。&lt;/p&gt;

&lt;p&gt;中间件可以给处理程序添加一些额外的功能。中间件函数主要被用来扩展Ring的基本处理函数。&lt;/p&gt;

&lt;p&gt;中间件其实就是个简单的函数，它接受现有的处理程序和一些可选参数作为函数参数并返回一个新的处理程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn wrap-nocache [handler]
  (fn [request]
     (let [response (handler request)]
        (assoc-in response [:headers  &quot;Pragma&quot;] &quot;no-cache&quot;))))

(def app (wrap-nocache handler))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，上面的函数接受一个处理函数并返回一个新的函数，这个函数接受request作为参数。返回的函数只在handler所在的范围内有效。当调用这个函数时，它将会给响应map添加Pragma:no-cache键值对。&lt;/p&gt;

&lt;p&gt;你可以添加自定义的中间件，只需要使用:middleware关键字就可以了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          ;;put any custom middleware
          ;;in the middleware vector
          :middleware [wrap-nocache]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体内容可参见Ring官方文档。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Useful ring middleware&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ring-middleware-format - Ring middleware for handling different fromats such as JSON and EDN&lt;/li&gt;
&lt;li&gt;ring-ratelimit - Rate limiting middleware&lt;/li&gt;
&lt;li&gt;ring-etag-middleware - Calculates etags for ring responses and returns 304 responses when appropriate&lt;/li&gt;
&lt;li&gt;ring-gzip-middleware - Gzips ring responses for user agents which can handle it&lt;/li&gt;
&lt;li&gt;ring-upload-progress - Provide upload progress data in ring session&lt;/li&gt;
&lt;li&gt;ring-anti-forgery - Ring middleware to prevent CSRF attacks&lt;/li&gt;
&lt;/ul&gt;

</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-响应</title>
        <link href="http://ivanpig.github.io/2013/09/21/response_types.html"/>
        <updated>2013-09-21T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/21/response_types</id>
        <content type="html">&lt;h1&gt;Responses&lt;/h1&gt;

&lt;p&gt;noir.response提供了很多辅助函数来处理响应.&lt;/p&gt;

&lt;h1&gt;Setting headers&lt;/h1&gt;

&lt;p&gt;可以使用set-header来设置响应头，使用一个map作为参数。这里需要注意的是,map的key必须是字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set-headers {&quot;x-csrf&quot; csrf}
    (common/layout [:p &quot;hi there&quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Setting content type&lt;/h1&gt;

&lt;p&gt;你可以使用content-type函数来设置响应的类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/project&quot; []
       (noir.response/content-type
       &quot;application/pdf&quot;
       (clojure.java.io/input-stream &quot;report.pdf&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是有效的响应类型设置:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XML - Wraps the response with the content type for xml and sets the body to the content.&lt;/li&gt;
&lt;li&gt;JSON- Wraps the response in the json content type and generates JSON from the content&lt;/li&gt;
&lt;li&gt;JSONP - Generates JSON for the given content and creates a javascript response for calling func-name with it.&lt;/li&gt;
&lt;li&gt;edn - Wraps the response in the application/edn content-type and calls pr-str on the Clojure data stuctures passed in.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/xml&quot; [] (xml &quot;&amp;lt;foo&amp;gt;&amp;lt;/foo&amp;gt;&quot;))
(GET &quot;/json&quot; [] (json {:response &quot;ok&quot;}))
(GET &quot;/jsonp&quot; [] (jsonp  &quot;showUsers&quot; [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]))
(GET &quot;/edn&quot; [] (edn {:foo 1 :bar 2}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了设置响应类型，你还需要设置noir.util.middleware/app-handler中间件。和上一节的请求一样，你只需要配置:formats键就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(app-handler routes :formats [:json])
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;可用的格式化类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:json - JSON with string keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:json-kw - JSON with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:edn - native Clojure format.&lt;/li&gt;
&lt;li&gt;:yaml - YAML format&lt;/li&gt;
&lt;li&gt;:yaml-kw - YAML format with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:yaml-in-html - yaml in a html page&lt;/li&gt;
&lt;li&gt;Setting custom status&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以使用status函数来设置一个自定义的状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/missing-page&quot; [] (status 404 &quot;your page could not be found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Redirects&lt;/h1&gt;

&lt;p&gt;noir.response/redirect可以进行重定向。他可以向重定向函数传递参数。他支持如下类型:
-   :permanent
-   :found
-   :see-other
-   :not-modified
-   :proxy
-   :temporary&lt;/p&gt;

&lt;p&gt;如果不传递参数的话，那么默认为:found&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require 'noir.response)

(redirect &quot;/foo&quot;)
(redirect &quot;/bar&quot; :see-other)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Responses&lt;/h1&gt;

&lt;p&gt;noir.response提供了很多辅助函数来处理响应.&lt;/p&gt;

&lt;h1&gt;Setting headers&lt;/h1&gt;

&lt;p&gt;可以使用set-header来设置响应头，使用一个map作为参数。这里需要注意的是,map的key必须是字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set-headers {&quot;x-csrf&quot; csrf}
    (common/layout [:p &quot;hi there&quot;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Setting content type&lt;/h1&gt;

&lt;p&gt;你可以使用content-type函数来设置响应的类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/project&quot; []
       (noir.response/content-type
       &quot;application/pdf&quot;
       (clojure.java.io/input-stream &quot;report.pdf&quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是有效的响应类型设置:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XML - Wraps the response with the content type for xml and sets the body to the content.&lt;/li&gt;
&lt;li&gt;JSON- Wraps the response in the json content type and generates JSON from the content&lt;/li&gt;
&lt;li&gt;JSONP - Generates JSON for the given content and creates a javascript response for calling func-name with it.&lt;/li&gt;
&lt;li&gt;edn - Wraps the response in the application/edn content-type and calls pr-str on the Clojure data stuctures passed in.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/xml&quot; [] (xml &quot;&amp;lt;foo&amp;gt;&amp;lt;/foo&amp;gt;&quot;))
(GET &quot;/json&quot; [] (json {:response &quot;ok&quot;}))
(GET &quot;/jsonp&quot; [] (jsonp  &quot;showUsers&quot; [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]))
(GET &quot;/edn&quot; [] (edn {:foo 1 :bar 2}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了设置响应类型，你还需要设置noir.util.middleware/app-handler中间件。和上一节的请求一样，你只需要配置:formats键就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(app-handler routes :formats [:json])
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;可用的格式化类型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:json - JSON with string keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:json-kw - JSON with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:edn - native Clojure format.&lt;/li&gt;
&lt;li&gt;:yaml - YAML format&lt;/li&gt;
&lt;li&gt;:yaml-kw - YAML format with keywodized keys in :params and :body-params&lt;/li&gt;
&lt;li&gt;:yaml-in-html - yaml in a html page&lt;/li&gt;
&lt;li&gt;Setting custom status&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;可以使用status函数来设置一个自定义的状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/missing-page&quot; [] (status 404 &quot;your page could not be found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Redirects&lt;/h1&gt;

&lt;p&gt;noir.response/redirect可以进行重定向。他可以向重定向函数传递参数。他支持如下类型:
-   :permanent
-   :found
-   :see-other
-   :not-modified
-   :proxy
-   :temporary&lt;/p&gt;

&lt;p&gt;如果不传递参数的话，那么默认为:found&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require 'noir.response)

(redirect &quot;/foo&quot;)
(redirect &quot;/bar&quot; :see-other)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-请求</title>
        <link href="http://ivanpig.github.io/2013/09/20/request_types.html"/>
        <updated>2013-09-20T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/20/request_types</id>
        <content type="html">&lt;h1&gt;Requests&lt;/h1&gt;

&lt;p&gt;默认情况下，请求的参数(比如一个form的POST请求)将会被自动绑定到request的:params键上。&lt;/p&gt;

&lt;p&gt;但是，如果你在请求体内传递一些特殊类型的参数，则你需要使用适合的中间件来处理他们。Luminus使用ring-middleware-format来处理这些参数。&lt;/p&gt;

&lt;p&gt;中间件可以通过在noir.util.middleware/app-handler上添加:formats键来开启:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          :formats [:json :edn]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样请求中的application/json和application/edn类型将会被中间件处理。相应的请求参数会在:params中。注意，这也会处理响应中的对应类型参数。具体信息请见Response Types章节。&lt;/p&gt;

&lt;p&gt;下面是有效的格式化类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:json - JSON with string keys in :params and :body-params
:json-kw - JSON with keywodized keys in :params and :body-params
:edn - native Clojure format.
:yaml - YAML format
:yaml-kw - YAML format with keywodized keys in :params and :body-params
:yaml-in-html - yaml in a html page
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Requests&lt;/h1&gt;

&lt;p&gt;默认情况下，请求的参数(比如一个form的POST请求)将会被自动绑定到request的:params键上。&lt;/p&gt;

&lt;p&gt;但是，如果你在请求体内传递一些特殊类型的参数，则你需要使用适合的中间件来处理他们。Luminus使用ring-middleware-format来处理这些参数。&lt;/p&gt;

&lt;p&gt;中间件可以通过在noir.util.middleware/app-handler上添加:formats键来开启:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
          all-routes
          :formats [:json :edn]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样请求中的application/json和application/edn类型将会被中间件处理。相应的请求参数会在:params中。注意，这也会处理响应中的对应类型参数。具体信息请见Response Types章节。&lt;/p&gt;

&lt;p&gt;下面是有效的格式化类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:json - JSON with string keys in :params and :body-params
:json-kw - JSON with keywodized keys in :params and :body-params
:edn - native Clojure format.
:yaml - YAML format
:yaml-kw - YAML format with keywodized keys in :params and :body-params
:yaml-in-html - yaml in a html page
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-静态资源</title>
        <link href="http://ivanpig.github.io/2013/09/19/staticresource.html"/>
        <updated>2013-09-19T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/19/staticresource</id>
        <content type="html">&lt;h1&gt;Static resources&lt;/h1&gt;

&lt;p&gt;在noir.io下有多个访问静态资源的帮助方法。
你可以通过调用resource-path来获取public目录的路径。&lt;/p&gt;

&lt;h1&gt;Handling file uploads&lt;/h1&gt;

&lt;p&gt;上传文件通过noir.io空间下的upload-file方法来实现，upload-file接受一个路径和文件的map。
例如我们有一个upload.html文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;h2&amp;gt;Upload a file&amp;lt;/h2&amp;gt;
    &amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&amp;gt;
        &amp;lt;input id=&quot;file&quot; name=&quot;file&quot; type=&quot;file&quot; /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来处理文件上传。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.upload
  ...
  (:require [upload-test.views.layout :as layout]
            [noir.response :as response]
            [noir.io :as io]))

(defn upload-page []
  (layout/render &quot;upload.html&quot;))

(defn handle-upload [file]
  (io/upload-file &quot;/&quot; file)
  (response/redirect
    (str &quot;/&quot; (:filename file))))

(defroutes upload-routes
  (GET &quot;/upload&quot; [] (upload-page))
  (POST &quot;/upload&quot; [file] (handle-upload file)))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Serving static resources&lt;/h1&gt;

&lt;p&gt;你可以使用get-resource通过相对路径来加载public目录中的资源，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将返回在包含public/md/outline.md下资源的clojure.java.io/resource。
最后，我们可以使用slurp-resource来读取文件的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(slurp-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Static resources&lt;/h1&gt;

&lt;p&gt;在noir.io下有多个访问静态资源的帮助方法。
你可以通过调用resource-path来获取public目录的路径。&lt;/p&gt;

&lt;h1&gt;Handling file uploads&lt;/h1&gt;

&lt;p&gt;上传文件通过noir.io空间下的upload-file方法来实现，upload-file接受一个路径和文件的map。
例如我们有一个upload.html文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;h2&amp;gt;Upload a file&amp;lt;/h2&amp;gt;
    &amp;lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&amp;gt;
        &amp;lt;input id=&quot;file&quot; name=&quot;file&quot; type=&quot;file&quot; /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样来处理文件上传。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.upload
  ...
  (:require [upload-test.views.layout :as layout]
            [noir.response :as response]
            [noir.io :as io]))

(defn upload-page []
  (layout/render &quot;upload.html&quot;))

(defn handle-upload [file]
  (io/upload-file &quot;/&quot; file)
  (response/redirect
    (str &quot;/&quot; (:filename file))))

(defroutes upload-routes
  (GET &quot;/upload&quot; [] (upload-page))
  (POST &quot;/upload&quot; [file] (handle-upload file)))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Serving static resources&lt;/h1&gt;

&lt;p&gt;你可以使用get-resource通过相对路径来加载public目录中的资源，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(get-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将返回在包含public/md/outline.md下资源的clojure.java.io/resource。
最后，我们可以使用slurp-resource来读取文件的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(slurp-resource &quot;/md/outline.md&quot;)
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-路由定义</title>
        <link href="http://ivanpig.github.io/2013/09/18/defining_routes.html"/>
        <updated>2013-09-18T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/18/defining_routes</id>
        <content type="html">&lt;h1&gt;Defining routes&lt;/h1&gt;

&lt;p&gt;Luminus使用Compojure来定义应用的路由.路由由HTTP请求方法和接受它的URI，
参数和以及相应的处理程序组成。Compojure定义了所有标准HTTP请求的路由，
比如ANY,DELETE,GET,HEAD,OPTIONS,PATCH,POST和PUT。&lt;/p&gt;

&lt;p&gt;例如：如果我们想定义一个应用，它指向/，/返回&quot;Hello World!&quot;字符串。我们
可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes app-routes
  (GET &quot;/&quot; [] &quot;Hello World!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想构建一个路由来响应POST请求，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/hello&quot; [id] (str &quot;Welcome &quot; id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些路由需要访问请求的map，我们只需要在路由上定义第二个参数就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/foo&quot; request (interpose &quot;, &quot; (keys request)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的路由读出请求map中所有的key并展示出来。结果如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;:ssl-client-cert, :remote-addr, :scheme, :query-params, :session, :form-params,
:multipart-params, :request-method, :query-string, :route-params, :content-type,
:cookies, :uri, :server-name, :params, :headers, :content-length, :server-port,
:character-encoding, :body, :flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compojure还提供了一些有用的函数来处理请求map和表单参数。例如，在
guestbook应用的例子中，我们看到了如下的路由定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/&quot;  [name message] (save-message name message))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这个路由从参数中获取到name和message的值，并将其绑定到相同名字的变量上。
我们能像使用其他定义的变量那样来使用他们。我们也可以直接在路由中使用Clojure的解构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/:foo&quot; { {foo &quot;foo&quot;} :params}
  (str &quot;Foo = &quot; foo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，Compojure还提供了解构部分参数，并将其他参数构建为一个map的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[x y &amp;amp; z]
x -&amp;gt; &quot;foo&quot;
y -&amp;gt; &quot;bar&quot;
z -&amp;gt; {:v &quot;baz&quot;, :w &quot;qux&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中,参数x和y被绑定到了变量上，而v和w还在叫z的map中。
最后，如果我们需要获取完整的请求，我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/&quot; [x y :as r] (str x y r))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们将表单参数绑定到了x和y上，而完整的请求则绑定到了变量r上。&lt;/p&gt;

&lt;h1&gt;Organizing application routes&lt;/h1&gt;

&lt;p&gt;对路由管理的最佳实践就是对其统一管理。Compojure提供了defroutes宏来方便
我们作这样的处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes auth-routes
  (POST &quot;/login&quot; [id pass] (login id pass))
  (POST &quot;/logout&quot; [] (logout)))

(defroutes app-routes
  (GET &quot;/&quot; [] (home))
  (route/resources &quot;/&quot;)
  (route/not-found &quot;Not Found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于路径相似的路由，可以使用context来简化管理。
例如，你的路径都以/user/:id为根路径:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes user-routes
      (GET &quot;/user/:id/profile&quot; [id] ...)
      (GET &quot;/user/:id/settings&quot; [id] ...)
      (GET &quot;/user/:id/change-password&quot; [id] ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以这样简写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def user-routes
      (context &quot;/user/:id&quot; [id]
        (GET &quot;/profile&quot; [] ...)
        (GET &quot;/settings&quot; [] ...)
        (GET &quot;/change-password&quot; [] ...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你定义好了所有的路由，你可以将他们添加到
noir.util.middleware/app-handler下的vector中，它在handler目录下。
你应该注意到了，生成的项目中已经定义了一个叫app的变量，你只需要添加新的路由就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware []
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的文档请键Compojure官方wiki.&lt;/p&gt;

&lt;h1&gt;Restricting access&lt;/h1&gt;

&lt;p&gt;有些页面只能在特定条件下才可以访问。
例如，你可能想定义一个只能给管理员查看的页面或者一个用户管理页面，只给
当前用户看。
使用lib-noir中的noir.util.route可以达到这个目的，我们可以定义访问特殊
页面的逻辑&lt;/p&gt;

&lt;h1&gt;Marking Routes as Restricted&lt;/h1&gt;

&lt;p&gt;noir.util.route/restricted宏被用来定义访问路由的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/private/:id&quot; [id] (restricted &quot;private!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想定义多个路由的访问权限，可以使用def-restricted-routes宏.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def-restricted-routes private-pages
  (GET &quot;/profile&quot; [] (show-profile))
  (GET &quot;/my-secret-page&quot; [] (show-secret-page))
  (GET &quot;/another-secret-page&quot; [] (another-secret-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes private-pages
  (GET &quot;/profile&quot; [] (restricted (show-profile)))
  (GET &quot;/secret-page1&quot; [] (restricted (show-secret-page)))
  (GET &quot;/secret-page2&quot; [] (restricted (another-secret-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，受限访问的路由会检查请求是否符合所有的条件。&lt;/p&gt;

&lt;h1&gt;Specifying Access Rules&lt;/h1&gt;

&lt;p&gt;我们来看看如何创建一个路由，它只有在session中存在:user所对应的值时，
才能访问。 首先，我们需要引用noir.util.route和noir.session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require ...
            [noir.util.route :refer [restricted]]
            [noir.session :as session]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将编写函数来实现上面我们所说的访问规则。函数必须接受request
作为其参数并且返回true或者false来确认页面是否可以访问。
下面就是该函数的实现，它检查当前session中是否存在user。如果没有则重定
向。默认重定向到根路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn user-access [request]
  (session/get :user))

(def app
 (middleware/app-handler
   [app-routes]
   :access-rules [user-access]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，所有的受限的处理程序在session中不存在:user时都会重定向到根目录。&lt;/p&gt;

&lt;h1&gt;Access Rule Groups&lt;/h1&gt;

&lt;p&gt;当你以map的方式来提供访问规则，则可以进行进一步的处理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:uri - 符合访问规则的URI&lt;/li&gt;
&lt;li&gt;:uris - 和:uri类似，匹配多个URI&lt;/li&gt;
&lt;li&gt;:redirect - 重定向地址&lt;/li&gt;
&lt;li&gt;:on-fail - 重定向可选项，可以指定一个请求错误时的处理函数，函数必须
以request为参数&lt;/li&gt;
&lt;li&gt;:rule - 一个规则&lt;/li&gt;
&lt;li&gt;:rules - 多个规则&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:rules可以用在下面集中情形下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:rules [rule1 rule2]
:rules {:any [rule1 rule2]}
:rules {:every [rule1 rule2] :any [rule3 rule4]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，每个规则都必须通过才能访问成功，:any则表示只要符合任何一个
规则即可访问。下面是一些例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn admin-access [req]
 (session/get :admin))

:access-rules [{:redirect &quot;/access-denied&quot;
                :rule user-access}]

:access-rules [{:uris [&quot;/user/*&quot; &quot;/private*&quot;]
                :rule user-access}]

:access-rules [{:uri &quot;/admin/*&quot; :rule admin-access}
               {:uri &quot;/user/*&quot;
                :rules {:any [user-access admin-access]}}]

:access-rules [{:on-fail (fn [req] &quot;access restricted&quot;)
                :rule user-access}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击指的是第三方通过一个验证过的用户来提交动作。当你的网站包含了一
个恶意链接或按钮或js的时候，很容易发生。
我们可以使用Ring-Anti-Forgery来放置csrf攻击. 首先添加[ring-anti-forgery
&quot;0.2.1&quot;]依赖。接着引入相应的包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require
    ...
    [selmer.parser :refer [add-tag!]]
    [ring.util.anti-forgery :refer [anti-forgery-field]]
    [ring.middleware.anti-forgery :refer [wrap-anti-forgery]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将添加wrap-anti-forgery中间件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware [wrap-anti-forgery]
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完后一个随机字符串将会被赋给anti-forgery-token变量。所有的POST请求
将会包含一个叫_~anti~-forgery-token的token.
接着我们在init函数中添加csrf标签:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  ...
  (add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的POST请求如果不包含这个token，则会被拒绝。服务器返回403错误。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Defining routes&lt;/h1&gt;

&lt;p&gt;Luminus使用Compojure来定义应用的路由.路由由HTTP请求方法和接受它的URI，
参数和以及相应的处理程序组成。Compojure定义了所有标准HTTP请求的路由，
比如ANY,DELETE,GET,HEAD,OPTIONS,PATCH,POST和PUT。&lt;/p&gt;

&lt;p&gt;例如：如果我们想定义一个应用，它指向/，/返回&quot;Hello World!&quot;字符串。我们
可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes app-routes
  (GET &quot;/&quot; [] &quot;Hello World!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想构建一个路由来响应POST请求，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/hello&quot; [id] (str &quot;Welcome &quot; id))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些路由需要访问请求的map，我们只需要在路由上定义第二个参数就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/foo&quot; request (interpose &quot;, &quot; (keys request)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的路由读出请求map中所有的key并展示出来。结果如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.example}&quot;&gt;:ssl-client-cert, :remote-addr, :scheme, :query-params, :session, :form-params,
:multipart-params, :request-method, :query-string, :route-params, :content-type,
:cookies, :uri, :server-name, :params, :headers, :content-length, :server-port,
:character-encoding, :body, :flash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compojure还提供了一些有用的函数来处理请求map和表单参数。例如，在
guestbook应用的例子中，我们看到了如下的路由定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(POST &quot;/&quot;  [name message] (save-message name message))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;这个路由从参数中获取到name和message的值，并将其绑定到相同名字的变量上。
我们能像使用其他定义的变量那样来使用他们。我们也可以直接在路由中使用Clojure的解构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/:foo&quot; { {foo &quot;foo&quot;} :params}
  (str &quot;Foo = &quot; foo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上，Compojure还提供了解构部分参数，并将其他参数构建为一个map的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[x y &amp;amp; z]
x -&amp;gt; &quot;foo&quot;
y -&amp;gt; &quot;bar&quot;
z -&amp;gt; {:v &quot;baz&quot;, :w &quot;qux&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中,参数x和y被绑定到了变量上，而v和w还在叫z的map中。
最后，如果我们需要获取完整的请求，我们可以这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/&quot; [x y :as r] (str x y r))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们将表单参数绑定到了x和y上，而完整的请求则绑定到了变量r上。&lt;/p&gt;

&lt;h1&gt;Organizing application routes&lt;/h1&gt;

&lt;p&gt;对路由管理的最佳实践就是对其统一管理。Compojure提供了defroutes宏来方便
我们作这样的处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes auth-routes
  (POST &quot;/login&quot; [id pass] (login id pass))
  (POST &quot;/logout&quot; [] (logout)))

(defroutes app-routes
  (GET &quot;/&quot; [] (home))
  (route/resources &quot;/&quot;)
  (route/not-found &quot;Not Found&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于路径相似的路由，可以使用context来简化管理。
例如，你的路径都以/user/:id为根路径:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes user-routes
      (GET &quot;/user/:id/profile&quot; [id] ...)
      (GET &quot;/user/:id/settings&quot; [id] ...)
      (GET &quot;/user/:id/change-password&quot; [id] ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以这样简写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def user-routes
      (context &quot;/user/:id&quot; [id]
        (GET &quot;/profile&quot; [] ...)
        (GET &quot;/settings&quot; [] ...)
        (GET &quot;/change-password&quot; [] ...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你定义好了所有的路由，你可以将他们添加到
noir.util.middleware/app-handler下的vector中，它在handler目录下。
你应该注意到了，生成的项目中已经定义了一个叫app的变量，你只需要添加新的路由就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware []
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的文档请键Compojure官方wiki.&lt;/p&gt;

&lt;h1&gt;Restricting access&lt;/h1&gt;

&lt;p&gt;有些页面只能在特定条件下才可以访问。
例如，你可能想定义一个只能给管理员查看的页面或者一个用户管理页面，只给
当前用户看。
使用lib-noir中的noir.util.route可以达到这个目的，我们可以定义访问特殊
页面的逻辑&lt;/p&gt;

&lt;h1&gt;Marking Routes as Restricted&lt;/h1&gt;

&lt;p&gt;noir.util.route/restricted宏被用来定义访问路由的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(GET &quot;/private/:id&quot; [id] (restricted &quot;private!&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想定义多个路由的访问权限，可以使用def-restricted-routes宏.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def-restricted-routes private-pages
  (GET &quot;/profile&quot; [] (show-profile))
  (GET &quot;/my-secret-page&quot; [] (show-secret-page))
  (GET &quot;/another-secret-page&quot; [] (another-secret-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码等同于&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes private-pages
  (GET &quot;/profile&quot; [] (restricted (show-profile)))
  (GET &quot;/secret-page1&quot; [] (restricted (show-secret-page)))
  (GET &quot;/secret-page2&quot; [] (restricted (another-secret-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，受限访问的路由会检查请求是否符合所有的条件。&lt;/p&gt;

&lt;h1&gt;Specifying Access Rules&lt;/h1&gt;

&lt;p&gt;我们来看看如何创建一个路由，它只有在session中存在:user所对应的值时，
才能访问。 首先，我们需要引用noir.util.route和noir.session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require ...
            [noir.util.route :refer [restricted]]
            [noir.session :as session]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将编写函数来实现上面我们所说的访问规则。函数必须接受request
作为其参数并且返回true或者false来确认页面是否可以访问。
下面就是该函数的实现，它检查当前session中是否存在user。如果没有则重定
向。默认重定向到根路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn user-access [request]
  (session/get :user))

(def app
 (middleware/app-handler
   [app-routes]
   :access-rules [user-access]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，所有的受限的处理程序在session中不存在:user时都会重定向到根目录。&lt;/p&gt;

&lt;h1&gt;Access Rule Groups&lt;/h1&gt;

&lt;p&gt;当你以map的方式来提供访问规则，则可以进行进一步的处理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:uri - 符合访问规则的URI&lt;/li&gt;
&lt;li&gt;:uris - 和:uri类似，匹配多个URI&lt;/li&gt;
&lt;li&gt;:redirect - 重定向地址&lt;/li&gt;
&lt;li&gt;:on-fail - 重定向可选项，可以指定一个请求错误时的处理函数，函数必须
以request为参数&lt;/li&gt;
&lt;li&gt;:rule - 一个规则&lt;/li&gt;
&lt;li&gt;:rules - 多个规则&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;:rules可以用在下面集中情形下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:rules [rule1 rule2]
:rules {:any [rule1 rule2]}
:rules {:every [rule1 rule2] :any [rule3 rule4]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，每个规则都必须通过才能访问成功，:any则表示只要符合任何一个
规则即可访问。下面是一些例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn admin-access [req]
 (session/get :admin))

:access-rules [{:redirect &quot;/access-denied&quot;
                :rule user-access}]

:access-rules [{:uris [&quot;/user/*&quot; &quot;/private*&quot;]
                :rule user-access}]

:access-rules [{:uri &quot;/admin/*&quot; :rule admin-access}
               {:uri &quot;/user/*&quot;
                :rules {:any [user-access admin-access]}}]

:access-rules [{:on-fail (fn [req] &quot;access restricted&quot;)
                :rule user-access}]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Cross Site Request Forgery Protection&lt;/h1&gt;

&lt;p&gt;CSRF攻击指的是第三方通过一个验证过的用户来提交动作。当你的网站包含了一
个恶意链接或按钮或js的时候，很容易发生。
我们可以使用Ring-Anti-Forgery来放置csrf攻击. 首先添加[ring-anti-forgery
&quot;0.2.1&quot;]依赖。接着引入相应的包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns myapp.handler
  (:require
    ...
    [selmer.parser :refer [add-tag!]]
    [ring.util.anti-forgery :refer [anti-forgery-field]]
    [ring.middleware.anti-forgery :refer [wrap-anti-forgery]]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们将添加wrap-anti-forgery中间件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(def app (middleware/app-handler
           ;;add your application routes here
           [home-routes app-routes]
           ;;add custom middleware here
           :middleware [wrap-anti-forgery]
           ;;add access rules here
           ;;each rule should be a vector
           :access-rules []))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完后一个随机字符串将会被赋给anti-forgery-token变量。所有的POST请求
将会包含一个叫_~anti~-forgery-token的token.
接着我们在init函数中添加csrf标签:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  ...
  (add-tag! :csrf-token (fn [_ _] (anti-forgery-field)))
  ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在模板中使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;form name=&quot;input&quot; action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
      { % csrf-token %}
      Username: &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;
      Password: &amp;lt;input type=&quot;password&quot; name=&quot;pass&quot;&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的POST请求如果不包含这个token，则会被拒绝。服务器返回403错误。&lt;/p&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-ClojureScript</title>
        <link href="http://ivanpig.github.io/2013/09/17/clojurescript.html"/>
        <updated>2013-09-17T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/17/clojurescript</id>
        <content type="html">&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;ClojureScript可以作为JavaScript在客户端的替代品。使用ClojureScript可以
有如下有点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在客户端和服务端使用相同的语言&lt;/li&gt;
&lt;li&gt;在前后端共用相同的代码&lt;/li&gt;
&lt;li&gt;简介流畅的语言&lt;/li&gt;
&lt;li&gt;使用Leiningen管理依赖关系&lt;/li&gt;
&lt;li&gt;不可变数据&lt;/li&gt;
&lt;li&gt;功能强大的库&lt;/li&gt;
&lt;li&gt;Adding ClojureScript Support&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最简单的添加ClojureScript支持的方法就是在创建新项目的时候添加+cljs选项
。不过在现有的项目中添加ClojureScript也同样的简单。你只需要在
project.clj文件中添加如下内容即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:plugins [...
          [lein-cljsbuild &quot;0.3.0&quot;]]

:hooks [... leiningen.cljsbuild]

:cljsbuild
{:builds [{:source-paths [&quot;src-cljs&quot;]
           :compiler {:output-to &quot;resources/public/js/site.js&quot;
                      :optimizations :advanced}}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将在项目中添加cljsbuild插件和一个钩子。
所有的命名空间需要在项目根目录下的src-cljs目录内。注意，ClojureScript
文件需要以.cljs结尾。如果文件以.clj结尾，它也会被编译，不过它就无法访
问js命名空间。&lt;/p&gt;

&lt;h1&gt;Using Libraries&lt;/h1&gt;

&lt;p&gt;使用ClojureScript的一个好处就是你可以使用Leiningen来管理客户端的依赖。
ClojureScript库和其他库一样都配置在project.clj文件中。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Running the Compiler&lt;/h1&gt;

&lt;p&gt;开发ClojureScript应用最简单的方法就是自动运行编译器。这样，你的任何修
改都会立即生效。要开启自动编译，只需要输入如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用一次编译的方式。这将会将所有的js编译到一个js文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild once
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Advanced Compilation and Exports&lt;/h1&gt;

&lt;p&gt;使用高级编译的话变量名会被编译器压缩。如果要确保函数被编译为js时函数名
不变，那么我们需要保证他们的名字是受保护的。而这只需要添加^:export注解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns main)

(defn ^:export init []
  (js/alert &quot;hello world&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以像这样来调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;script&amp;gt;
    main.init();
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在代码里使用js库，那么我们必须要保护我们所调用的函数名。例如，
如果我们想使用AlbumColors库，如果我们这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn ^:export init []
  (.getColors (js/AlbumColors. &quot;/img/foo.jpg&quot;)
    (fn [[background]]
     (.log js/console background))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用高级编译时AlbumColors和getColors将会被改写。为了不让编译器改写他
们，我们需要创建一个js文件，里面包含了我们需要保护的函数，并在代码里引
用它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.javascript}&quot;&gt;var AlbumColors = {};
AlbumColors.getColors = function() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把上面的代码放到resource目录下一个叫externs.js文件里面。并在
cljsbuild丽引用它，像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{:source-paths [&quot;src-cljs&quot;]
     :compiler
     {:pretty-print false
      :output-to &quot;resources/public/js/site.js&quot;
      ;;specify the externs file to protect function names
      :externs [&quot;resources/externs.js&quot;]
      :optimizations :advanced}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Interacting with JavaScript&lt;/h1&gt;

&lt;p&gt;所有的js函数和变量都是在js这个Namespace的。&lt;/p&gt;

&lt;p&gt;*方法调用*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.method object params)

(.log js/console &quot;hello world!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*访问属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.-property object)

(.-style div)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*设置属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set! (.-property object))

(set! (.-color (.-style div) &quot;#234567&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的例子请查看&lt;a href=&quot;http://himera.herokuapp.com/synonym.html&quot;&gt;Himera文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Working With the DOM&lt;/h1&gt;

&lt;p&gt;有不少的库可以访问和修改DOM元素。一般用得比较多的是&lt;a href=&quot;https://github.com/levand/domina&quot;&gt;Domina&lt;/a&gt;和&lt;a href=&quot;https://github.com/Prismatic/dommy&quot;&gt;Dommy&lt;/a&gt;。
Domina对选择和操作DOM元素做了轻量级的封装。而Dommy是个类似hiccup的模板。&lt;/p&gt;

&lt;h1&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Luminus使用cljs-ajax来处理Ajax请求。这个库提供的ajax-request，GET和
POST函数能很方便的发送ajax请求。&lt;/p&gt;

&lt;p&gt;*ajax-request* ajax-request是最基本的请求函数，有如下参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;uri - 请求URI&lt;/li&gt;
&lt;li&gt;method - 一个表示http请求类型的字符串,比如：&quot;PUT&quot;, &quot;DELETE&quot;&lt;/li&gt;
&lt;li&gt;format - 一个表示响应类型的关键字,比如： :json 或者 :edn,默认是 :edn&lt;/li&gt;
&lt;li&gt;handler - 请求成功的回调函数，以响应为参数&lt;/li&gt;
&lt;li&gt;error-handler - 请求失败的回调函数,以一个map为参数，map包含了错误信
息，相应的key为: :status 和 :status-text&lt;/li&gt;
&lt;li&gt;params - 一个包含参数的map，发送给服务器&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;*GET/POST helpers* GET和POST助手接收一个URL和选项，来简化请求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:handler - 请求成功回调函数&lt;/li&gt;
&lt;li&gt;:error-handler - 请求失败函数&lt;/li&gt;
&lt;li&gt;:format - 相应格式化&lt;/li&gt;
&lt;li&gt;:params - 发送给服务器的参数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;和ajax-request参数功能相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns foo
  (:require [ajax.core :refer [GET POST]]))

(defn handler [response]
  (.log js/console (str response)))

(defn error-handler [{:keys [status status-text]}]
  (.log js/console
    (str &quot;something bad happened: &quot; status &quot; &quot; status-text)))

(GET &quot;/hello&quot;)

(GET &quot;/hello&quot; {:handler handler})

(POST &quot;/hello&quot;)

(POST &quot;/send-message&quot;
        {:params {:message &quot;Hello World&quot;
                  :user    &quot;Bob&quot;}
         :handler handler
         :error-handler error-handler})
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;ClojureScript可以作为JavaScript在客户端的替代品。使用ClojureScript可以
有如下有点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在客户端和服务端使用相同的语言&lt;/li&gt;
&lt;li&gt;在前后端共用相同的代码&lt;/li&gt;
&lt;li&gt;简介流畅的语言&lt;/li&gt;
&lt;li&gt;使用Leiningen管理依赖关系&lt;/li&gt;
&lt;li&gt;不可变数据&lt;/li&gt;
&lt;li&gt;功能强大的库&lt;/li&gt;
&lt;li&gt;Adding ClojureScript Support&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;最简单的添加ClojureScript支持的方法就是在创建新项目的时候添加+cljs选项
。不过在现有的项目中添加ClojureScript也同样的简单。你只需要在
project.clj文件中添加如下内容即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;:plugins [...
          [lein-cljsbuild &quot;0.3.0&quot;]]

:hooks [... leiningen.cljsbuild]

:cljsbuild
{:builds [{:source-paths [&quot;src-cljs&quot;]
           :compiler {:output-to &quot;resources/public/js/site.js&quot;
                      :optimizations :advanced}}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将在项目中添加cljsbuild插件和一个钩子。
所有的命名空间需要在项目根目录下的src-cljs目录内。注意，ClojureScript
文件需要以.cljs结尾。如果文件以.clj结尾，它也会被编译，不过它就无法访
问js命名空间。&lt;/p&gt;

&lt;h1&gt;Using Libraries&lt;/h1&gt;

&lt;p&gt;使用ClojureScript的一个好处就是你可以使用Leiningen来管理客户端的依赖。
ClojureScript库和其他库一样都配置在project.clj文件中。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;Running the Compiler&lt;/h1&gt;

&lt;p&gt;开发ClojureScript应用最简单的方法就是自动运行编译器。这样，你的任何修
改都会立即生效。要开启自动编译，只需要输入如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用一次编译的方式。这将会将所有的js编译到一个js文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein cljsbuild once
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Advanced Compilation and Exports&lt;/h1&gt;

&lt;p&gt;使用高级编译的话变量名会被编译器压缩。如果要确保函数被编译为js时函数名
不变，那么我们需要保证他们的名字是受保护的。而这只需要添加^:export注解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns main)

(defn ^:export init []
  (js/alert &quot;hello world&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以像这样来调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;    &amp;lt;script&amp;gt;
    main.init();
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们在代码里使用js库，那么我们必须要保护我们所调用的函数名。例如，
如果我们想使用AlbumColors库，如果我们这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn ^:export init []
  (.getColors (js/AlbumColors. &quot;/img/foo.jpg&quot;)
    (fn [[background]]
     (.log js/console background))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用高级编译时AlbumColors和getColors将会被改写。为了不让编译器改写他
们，我们需要创建一个js文件，里面包含了我们需要保护的函数，并在代码里引
用它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.javascript}&quot;&gt;var AlbumColors = {};
AlbumColors.getColors = function() {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把上面的代码放到resource目录下一个叫externs.js文件里面。并在
cljsbuild丽引用它，像这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{:source-paths [&quot;src-cljs&quot;]
     :compiler
     {:pretty-print false
      :output-to &quot;resources/public/js/site.js&quot;
      ;;specify the externs file to protect function names
      :externs [&quot;resources/externs.js&quot;]
      :optimizations :advanced}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Interacting with JavaScript&lt;/h1&gt;

&lt;p&gt;所有的js函数和变量都是在js这个Namespace的。&lt;/p&gt;

&lt;p&gt;*方法调用*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.method object params)

(.log js/console &quot;hello world!&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*访问属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(.-property object)

(.-style div)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*设置属性*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(set! (.-property object))

(set! (.-color (.-style div) &quot;#234567&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的例子请查看&lt;a href=&quot;http://himera.herokuapp.com/synonym.html&quot;&gt;Himera文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;Working With the DOM&lt;/h1&gt;

&lt;p&gt;有不少的库可以访问和修改DOM元素。一般用得比较多的是&lt;a href=&quot;https://github.com/levand/domina&quot;&gt;Domina&lt;/a&gt;和&lt;a href=&quot;https://github.com/Prismatic/dommy&quot;&gt;Dommy&lt;/a&gt;。
Domina对选择和操作DOM元素做了轻量级的封装。而Dommy是个类似hiccup的模板。&lt;/p&gt;

&lt;h1&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Luminus使用cljs-ajax来处理Ajax请求。这个库提供的ajax-request，GET和
POST函数能很方便的发送ajax请求。&lt;/p&gt;

&lt;p&gt;*ajax-request* ajax-request是最基本的请求函数，有如下参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;uri - 请求URI&lt;/li&gt;
&lt;li&gt;method - 一个表示http请求类型的字符串,比如：&quot;PUT&quot;, &quot;DELETE&quot;&lt;/li&gt;
&lt;li&gt;format - 一个表示响应类型的关键字,比如： :json 或者 :edn,默认是 :edn&lt;/li&gt;
&lt;li&gt;handler - 请求成功的回调函数，以响应为参数&lt;/li&gt;
&lt;li&gt;error-handler - 请求失败的回调函数,以一个map为参数，map包含了错误信
息，相应的key为: :status 和 :status-text&lt;/li&gt;
&lt;li&gt;params - 一个包含参数的map，发送给服务器&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;*GET/POST helpers* GET和POST助手接收一个URL和选项，来简化请求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;:handler - 请求成功回调函数&lt;/li&gt;
&lt;li&gt;:error-handler - 请求失败函数&lt;/li&gt;
&lt;li&gt;:format - 相应格式化&lt;/li&gt;
&lt;li&gt;:params - 发送给服务器的参数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;和ajax-request参数功能相同。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns foo
  (:require [ajax.core :refer [GET POST]]))

(defn handler [response]
  (.log js/console (str response)))

(defn error-handler [{:keys [status status-text]}]
  (.log js/console
    (str &quot;something bad happened: &quot; status &quot; &quot; status-text)))

(GET &quot;/hello&quot;)

(GET &quot;/hello&quot; {:handler handler})

(POST &quot;/hello&quot;)

(POST &quot;/send-message&quot;
        {:params {:message &quot;Hello World&quot;
                  :user    &quot;Bob&quot;}
         :handler handler
         :error-handler error-handler})
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-HTML模板</title>
        <link href="http://ivanpig.github.io/2013/09/16/html_templating.html"/>
        <updated>2013-09-16T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/16/html_templating</id>
        <content type="html">&lt;h1&gt;Templating Options&lt;/h1&gt;

&lt;p&gt;Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。
Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成
HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。
你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢
的模板框架，比如Enlive或者Stencil。&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Selmer&lt;/h1&gt;

&lt;p&gt;Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语
言，那么你会感觉很熟悉.&lt;/p&gt;

&lt;h2&gt;Creating Templates&lt;/h2&gt;

&lt;p&gt;Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的
HTML文件。来看下面的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;My First Template&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;Hello { {name}}&amp;lt;/h2&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们
需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为
name的变量的值。
有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来
渲染模板。而render-file接收一个字符串作为路径来渲染模板。
如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example.routes.home
  (:use [selmer.parser :only [render-file]]))

(defn index [request]
  (render-file &quot;example/views/templates/index.html&quot;
               {:name &quot;John&quot;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;render-file函数将src目录作为根路径，使用相对路径来查找模板。
上面，我们传递了一个字符串作为变量name的值。实际上，我们可以传递任何类
型的值。比如，我们传递一个集合，在模板里我们可以使用tag来遍历这个集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;ul&amp;gt;
        { % for item in items %}
        &amp;lt;li&amp;gt; { {item}} &amp;lt;/li&amp;gt;
        { % endfor %}
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render-file &quot;/example/views/templates/items.html {:items (range 10)}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果传递的是个map，我们可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;&amp;lt;p&amp;gt;Hello { {user.first}} { {user.last}}&amp;lt;/p&amp;gt;&quot;
        {:user {:first &quot;John&quot; :last &quot;Doe&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有指定的展示方式，那么默认调用toString方法。
默认情况下，Selmer会缓存编译后的模板。只有当文件发生变化时，才会触发
Selmer重新编译模板。你也可以选择Selmer是开启缓存还是关闭缓存。只需要调
用(selmer.parser/cache-on!)或(selmer.parser/cache-off!).&lt;/p&gt;

&lt;h2&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filter允许我们在渲染变量之前对其做一些处理。比如将其值变为大写，计算一
个hash或者是计算长度。Filter的使用方法很简单，只需要在变量名后面跟一个
&quot;|&quot;接着是Filter即可。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { {name|upper}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是内置的filter:&lt;/p&gt;

&lt;p&gt;*add*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {add_me|add:2:3:4}}&quot; {:add_me 2}) =&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*addslashes* 为了保留字符串中的转义符&quot;&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|addslashes}}&quot; {:name &quot;\&quot;Russian tea is best tea\&quot;&quot;}) =&amp;gt; &quot;\&quot;Russian tea is best tea\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block.super* 在代码块中插入上级代码块中的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;        { % block foo %} { {block.super}} some content{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*capitalize*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|capitalize}}&quot; {:name &quot;russian tea is best tea&quot;}) =&amp;gt; &quot;Russian tea is best tea&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*center*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|center:20}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot; bitemyapp &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*count*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|count}}&quot; {:name &quot;Yogthos&quot;}) =&amp;gt; &quot;7&quot;

(render &quot;{ {items|count}}&quot; {:items [1 2 3 4]}) =&amp;gt; &quot;4&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*date*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {creation-time|date:\&quot;yyyy-MM-dd_HH:mm:ss\&quot;}}&quot; {:created-at (java.util.Date.)}) =&amp;gt; &quot;2013-07-28_20:51:48&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;[]&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default-if-empty*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*double-format*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|double-format:2}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.00

(render &quot;{ {tis-a-number|double-format}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*first*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {seq-of-some-sort|first}}&quot; {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]}) =&amp;gt; :dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*get-digit* 从右边返回相应位数的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|get-digit:1}}&quot; {:tis-a-number 12.34567}) =&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*hash* 有效的hash方式: md5, sha, sha256, sha384, sha512&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {domain|hash:\&quot;md5\&quot;}}&quot; {:domain &quot;example.org&quot;}) =&amp;gt; &quot;1bdf72e04d6b50c82a48c7e4dd38cc69&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*join*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|join}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; &quot;1234&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*json* 生成json格式，默认情况下特殊字符会被编码.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data|json}}&quot; {:data [1 2 {:foo 27 :dan &quot;awesome&quot;}]})
               =&amp;gt; &quot;[1,2,{&amp;amp;quot;foo&amp;amp;quot;:27,&amp;amp;quot;dan&amp;amp;quot;:&amp;amp;quot;awesome&amp;amp;quot;}]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不希望被编码则使用safe过滤器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {f|json|safe}}&quot; {:f {:foo 27 :dan &quot;awesome&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*last*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|last}}&quot; {:sequence 12.34567}) =&amp;gt; 7

(render &quot;{ {sequence|last}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length-is*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length-is:4}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks* 普通换行替换为html换行,结果在\&amp;lt;p&gt;标签内&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;&amp;lt;p&amp;gt;&amp;lt;br /&amp;gt;bar&amp;lt;br /&amp;gt;baz&amp;lt;/p&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks-br* 和linebreaks功能相同，但是没有\&amp;lt;p&gt;标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks-br|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;bar&amp;lt;br /&amp;gt;baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linenumbers* 显示行号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linenumbers&quot; {:foo &quot;foo\n\bar\nbaz&quot;}) =&amp;gt; &quot;1. foo\n2. \bar\n3. baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*lower*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|lower}}&quot; {:foo &quot;FOOBaR&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*pluralize* 返回单词的复数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items []}) =&amp;gt; &quot;0 items&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1]}) =&amp;gt; &quot;1 item&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1 2]}) =&amp;gt; &quot;2 items&quot;

(render &quot;{ {fruit|count}} tomato{ {fruit|pluralize:\&quot;es\&quot;}}&quot; {:fruit []}) =&amp;gt; &quot;0 tomatoes&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1]}) =&amp;gt; &quot;1 lady&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1 2]}) =&amp;gt; &quot;2 ladies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*rand-nth* 从集合中返回rand-nths值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|rand-nth}}&quot; {:foo [1 2 3]}) =&amp;gt; &quot;2&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove* 从字符串中去除特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|remove:\&quot;aeiou\&quot;}}&quot; {:foo &quot;abcdefghijklmnop&quot;}) =&amp;gt; &quot;bcdfghjklmnp&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove-tags* 去除html标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|remove-tags:b:span }}&quot; {:value &quot;&amp;lt;b&amp;gt;&amp;lt;span&amp;gt;foobar&amp;lt;/span&amp;gt;&amp;lt;/b&amp;gt;&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*safe* 默认情况下Selmer会编码所有的内容，此过滤器时Selmer不去编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;amp;lt;foo&amp;amp;gt;&quot;

(render &quot;{ {data|safe}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;lt;foo&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort }}&quot; {:value [1 4 2 3 5]}) =&amp;gt; &quot;(1 2 3 4 5)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-by*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort-by:name }}&quot; {:value [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]})
                     =&amp;gt; &quot;({:name &amp;amp;quot;Jane&amp;amp;quot;} {:name &amp;amp;quot;John&amp;amp;quot;})&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-reversed* 反序排列&lt;/p&gt;

&lt;p&gt;*sort-by-reversed* 和sort-by功能相同，反序&lt;/p&gt;

&lt;p&gt;upper&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {shout|upper}}&quot; {:shout &quot;hello&quot;}) =&amp;gt; &quot;HELLO&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Filters&lt;/h2&gt;

&lt;p&gt;你可以使用selmer.filters/add-filter!函数来方便的添加自定义的Filter.此
函数以元素作为参数，并返回替换后的值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.filters)

(add-filter! :embiginate #(.toUpperCase %))
 (render &quot;{ {shout|embiginate}}&quot; {:shout &quot;hello&quot;})

(add-filter! :count count)
(render &quot;{ {foo|count}}&quot; {:foo (range 3)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filters可以链式使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ {foo|upper|empty?}}&quot; {:foo &quot;Hello&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Tags&lt;/h2&gt;

&lt;p&gt;Selmer提供了两种类型的Tag。一种是类似extends和include这样的内联tag。这
种tag不需要结束tag。另一种形式的tag是块tag。这种tag有开始和结束tag，以
及代码块。比如if ... endif块。 让我们先来看看默认的tag:&lt;/p&gt;

&lt;p&gt;*include* 将引用的模板内容替换其自身&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % include &quot;path/to/comments.html&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以提供默认的参数，如果tag有匹配上上的参数，则会获取它的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{ % include &quot;templates/inheritance/child.html&quot; with name=&quot;Jane Doe&quot; greeting=&quot;Hello!&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block*
定义一个块，可以使用模板继承的方式来覆盖，类似Java中的父类方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block foo %}This text can be overridden later{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*cycle* 循环提供的参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % for i in items %}&amp;lt;li class={ % cycle \&quot;blue\&quot; \&quot;white\&quot;%}&amp;gt;{ {i}}&amp;lt;/li&amp;gt;{ % endfor %}&quot; {:items (range 5)})
                        =&amp;gt; &quot;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;0&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;white\&quot;&amp;gt;1&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;2&amp;lt;/li&amp;gt;
                            &amp;lt;li class=\&quot;white\&quot;&amp;gt;3&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;4&amp;lt;/li&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*extends* 引用父模板。父模板中的块会被子模板中相应的块覆盖。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Note: 子模板只能包含块。任何块以外的tag或文本都被忽略&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;例如有一个叫base.html的父模板和一个叫child.html的子模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    { % block foo %}This text can be overridden later{ % endblock %}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % extends &quot;base.html&quot; %}
    { % block foo %}
      &amp;lt;p&amp;gt;This text will override the text in the parent&amp;lt;/p&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*if*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % if condition %}yes!{ % endif %}

{ % if condition %}yes!{ % else %}no!{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合filter使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ % if files|empty? %}no files{ % else %}files{ % endif %}&quot;
  {:files []})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*ifequal* 之用当两个参数相等时才执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % ifequal foo bar %}yes!{ % endifequal %}

{ % ifequal foo bar %}yes!{ % else %}no!{ % endifequal %}

{ % ifequal foo &quot;this also works&quot; %}yes!{ % endifequal %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*for* 遍历集合中的元素。同时可以使用如下参数。
-   forloop.first
-   forloop.last
-   forloop.counter
-   forloop.counter0
-   forloop.revcounter
-   forloop.revcounter0
-   forloop.length&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for x in some-list %}element: { {x}} first? { {forloop.first}} last? { {forloop.last}}{ % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以直接访问结构化的数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for item in items %} &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{ {item.name}}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{ {item.age}}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; { % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*now* 当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render (str &quot;{ % now \&quot;&quot; date-format &quot;\&quot;%}&quot;) {}) =&amp;gt; &quot;\&quot;01 08 2013\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*comment* 注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;foo bar { % comment %} baz test { {x}} { % endcomment %} blah&quot; {}) =&amp;gt; &quot;foo bar baz test blah&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*firstof* 取得第一个不是false的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % firstof var1 var2 var3 %}&quot; {:var2 &quot;x&quot; :var3 &quot;not me&quot;}) =&amp;gt; &quot;x&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*script*
生成一个html的script标签，并以servlet-context键提供的值类作为文件的前
置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % script \&quot;/js/site.js\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;script src=\&quot;/myapp/js/site.js\&quot; type=\&quot;text/javascript\&quot;&amp;gt;&amp;lt;/script&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*style*&lt;/p&gt;

&lt;p&gt;生成一个html的style标签，并以servlet-context键提供的值类作为文件的前置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % style \&quot;/css/screen.css\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;link href=\&quot;/myapp/css/screen.css\&quot; rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; /&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*verbatim* 阻止内容中的parseeither解析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % verbatim %}{ {if dying}}Still alive.{ {/if}}{ % endverbatim %}&quot; {}) =&amp;gt; &quot;{ {if dying}}Still alive.{ {/if}}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*with* 向上下文map中新增一个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % with total=business.employees|count %}{ { total }}{ % endwith %}&quot;
         {:business {:employees (range 5)}})
=&amp;gt; &quot;5 employees&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Tags&lt;/h2&gt;

&lt;p&gt;除了上面已经提供的tag。你也可以自定义tag。使用add-tag!宏就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.parser)

(add-tag! :foo
  (fn [args context-map]
    (str &quot;foo &quot; (first args))))

(render &quot;{ % foo quux %} { % foo baz %}&quot; {})

(add-tag! :bar
  (fn [args context-map content]
    (str content))
  :baz :endbar)

(render &quot;{ % bar %} some text { % baz %} some more text { % endbar %}&quot; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，我们定义的tag提供了一个关键字作为tag的名称后面是tag体,结尾的
tag不是必须的。
当没有结尾的tag时,tag不包含任何内容。这种tag获取参数类进行处理。
当有结尾tag时，每个块内的内容都会被作为开头那个tag所对应的map的键.开头
tag对应的map包含:args和:content键，content的内容就对应到了:content.&lt;/p&gt;

&lt;h2&gt;Template inheritance&lt;/h2&gt;

&lt;p&gt;Selmer模板可以使用块tag来引用其他的模板。有两种方法可以引用模板，一个
是extends一个是include.&lt;/p&gt;

&lt;h3&gt;Extending Templates&lt;/h3&gt;

&lt;p&gt;当我们使用extends这个tag时，当前的模板将会将引用的模板作为父模板。
任何在base模板中的块，会被子模板中相同名字的块给覆盖.
子模板中的内容需要在块tag中。不在块中的内容将会被忽略。
我们来看个例子,我们创建一个叫base.html的父模板.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % block content %}{ % endblock %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们创建一个home.html模板来继承base.html。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % extends &quot;base.html&quot; %}

    { % block content %}
        { % for entry in entries %}
            &amp;lt;h2&amp;gt;{ { entry.title }}&amp;lt;/h2&amp;gt;
            &amp;lt;p&amp;gt;{ { entry.body }}&amp;lt;/p&amp;gt;
        { % endfor %}
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染home.html时entries的内容将会被打印出来。而在home.html中，我们没
有定义title块，在渲染时会获取base.html中的title块的定义。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注意，你可以多层级的继承模板。引擎会渲染最后的那个块.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Including Templates&lt;/h3&gt;

&lt;p&gt;include这个tag允许你包含一个模板。
我们还是来看一个例子，我们有一个base.html这个模板，它包含了一个叫做
register.html的模板和一个home.html的模板：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % if user %}
        { % include &quot;templates_path/home.html&quot; %}
        { % else %}
        { % include &quot;templates_path/register.html&quot; %}
        { % endif %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们能定义register.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block register %}
      &amp;lt;form action=&quot;/register&quot; method=&quot;POST&quot;&amp;gt;
          &amp;lt;label for=&quot;id&quot;&amp;gt;user id&amp;lt;/label&amp;gt;
          &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input pass=&quot;pass&quot; name=&quot;pass&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input type=&quot;submit&quot; value=&quot;register&quot;&amp;gt;
      &amp;lt;/form&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和home.html:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block home %}
    &amp;lt;h1&amp;gt;Hello { {user}}&amp;lt;/h1&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染base.html时，将会引入register.html和home.html。
更多信息请见&lt;a href=&quot;https://github.com/yogthos/Selmer&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Hiccup&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weavejester/hiccup&quot;&gt;Hiccup&lt;/a&gt;
是另一个Clojure的HTML模板引擎。它的优势是我们可以使用纯正的
Clojure代码来生成页面。也就是说我们不需要学习第三方的语法了。
Hiccup主要使用Clojure的vector来渲染页面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:tag-name {:attribute-key &quot;attribute value&quot;} tag-body]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，如果我们想创建一个包含内容的div，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div {:id &quot;hello&quot;, :class &quot;content&quot;} [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将生成如下的html代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;        &amp;lt;div id=&quot;hello&quot; class=&quot;content&quot;&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup提供了简化设置id和class的方法，简写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div#hello.content [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup还提供了一些帮助类函数来创建元素，比如: forms, links, images, 等
等.所有这些函数只是简单的返回类似上面格式的vector。也就是说，如果一个
函数无法达到你的要求，你可以手写相应代码或者获取函数的返回值进行修改。
每个函数可以使用一个map作为其第一个参数，来描绘属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(image {:align &quot;left&quot;} &quot;foo.png&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成html代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;&amp;lt;img align=\&quot;left\&quot; src=\&quot;foo.png\&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是最佳实践还是将其保存到独立的CSS文件中。&lt;/p&gt;

&lt;h2&gt;Forms and Input&lt;/h2&gt;

&lt;p&gt;Hiccup还提供了form助手函数，看例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(form-to [:post &quot;/login&quot;]
  (text-field {:placeholder &quot;screen name&quot;} &quot;id&quot;)
  (password-field {:placeholder &quot;password&quot;} &quot;pass&quot;)
  (submit-button &quot;login&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数第一个参数是一个vector，以HTTP请求类型为关键字，紧接着是请求
url。其余的参数必须是HTML元素。生成的HTML代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
  &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; placeholder=&quot;screen name&quot; type=&quot;text&quot; /&amp;gt;
  &amp;lt;input id=&quot;pass&quot; name=&quot;pass&quot; placeholder=&quot;password&quot; type=&quot;password&quot; /&amp;gt;
  &amp;lt;input type=&quot;submit&quot; value=&quot;login&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后LUminus模板在你的应用下面提供了一辅助函数。叫做md-&gt;html,这个函数能
渲染载resources/public/目录下的markdown文件并返回一个HTML字符串。这个
可以和Hiccup函数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [&amp;lt;yourapp&amp;gt;.util :as util])
...
(html [:div.contenr [:p (util/md-&amp;gt;html &quot;/md/paragraph.md&quot;)]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown生成由markdown-clj来处理，具体信息请见其&lt;a href=&quot;https://github.com/yogthos/markdown-clj&quot;&gt;Github&lt;/a&gt;
页。&lt;/p&gt;

&lt;h1&gt;Content caching&lt;/h1&gt;

&lt;p&gt;lib-noir通过cache!宏提供了基本的内存式缓存，相应的宏在noir.util.cache
下。如果想缓存一个页面，你是需要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.util.cache :as cache])

(defn slow-loading-page []
  (cache/cache!
   :slow-page
   (common/layout
    [:div &quot;I load slowly&quot;]
     (parse-lots-of-files))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用invalidate!来取消缓存,需要提供需要取消的缓存的key。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/invalidate! :slow-page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用clear!来清除当前所有的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/clear!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用set-timeout!来设置缓存时间(单位：秒)，超时后会重新加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-timeout! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你可以通过set-size!来设置缓存的大小。当缓存超出了限定的大小，最先
使用的数据将被被替换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-size! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意，缓存会在操作成功后才重新加载。也就是说，比如程序去获取一个远程
文件，但是失败了，那么缓存是不会被重新加载的。&lt;/li&gt;
&lt;/ul&gt;

</content>
        <summary type="html">&lt;h1&gt;Templating Options&lt;/h1&gt;

&lt;p&gt;Luminus包含了Hiccup的依赖.如果你熟悉Hiccup那么可以直接使用。
Hiccup使用clojure数据结构来描述模板。并且,Hiccup提供了丰富的API来生成
HTML元素。 Luminus也包含了Selmer，Selmer使用了普通的文本文件来描述模板。
你可以使用它们中的任何一个模板，或者混合使用.抑或你可以选择任何你喜欢
的模板框架，比如Enlive或者Stencil。&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Selmer&lt;/h1&gt;

&lt;p&gt;Selmer是一个类似Django模板的框架。如果你熟悉Django或者其他类似的模板语
言，那么你会感觉很熟悉.&lt;/p&gt;

&lt;h2&gt;Creating Templates&lt;/h2&gt;

&lt;p&gt;Selmer将展示逻辑和程序逻辑分开。实际上Selmer模板就是包含了动态元素的
HTML文件。来看下面的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;My First Template&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;Hello { {name}}&amp;lt;/h2&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模板使用了一个包含了键值对的上下文环境。上下文环境中包含了我们
需要在运行时获得的变量的值。上面的代码中，我们从上下文环境中获取名字为
name的变量的值。
有两个函数可以渲染模板,render和render-file。render函数接收一个字符串来
渲染模板。而render-file接收一个字符串作为路径来渲染模板。
如果我们将上面的模板定义保存到index.html文件中。我们就可以这样来渲染:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns example.routes.home
  (:use [selmer.parser :only [render-file]]))

(defn index [request]
  (render-file &quot;example/views/templates/index.html&quot;
               {:name &quot;John&quot;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;p&gt;render-file函数将src目录作为根路径，使用相对路径来查找模板。
上面，我们传递了一个字符串作为变量name的值。实际上，我们可以传递任何类
型的值。比如，我们传递一个集合，在模板里我们可以使用tag来遍历这个集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    &amp;lt;ul&amp;gt;
        { % for item in items %}
        &amp;lt;li&amp;gt; { {item}} &amp;lt;/li&amp;gt;
        { % endfor %}
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render-file &quot;/example/views/templates/items.html {:items (range 10)}&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果传递的是个map，我们可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;&amp;lt;p&amp;gt;Hello { {user.first}} { {user.last}}&amp;lt;/p&amp;gt;&quot;
        {:user {:first &quot;John&quot; :last &quot;Doe&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有指定的展示方式，那么默认调用toString方法。
默认情况下，Selmer会缓存编译后的模板。只有当文件发生变化时，才会触发
Selmer重新编译模板。你也可以选择Selmer是开启缓存还是关闭缓存。只需要调
用(selmer.parser/cache-on!)或(selmer.parser/cache-off!).&lt;/p&gt;

&lt;h2&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filter允许我们在渲染变量之前对其做一些处理。比如将其值变为大写，计算一
个hash或者是计算长度。Filter的使用方法很简单，只需要在变量名后面跟一个
&quot;|&quot;接着是Filter即可。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { {name|upper}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是内置的filter:&lt;/p&gt;

&lt;p&gt;*add*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {add_me|add:2:3:4}}&quot; {:add_me 2}) =&amp;gt; 11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*addslashes* 为了保留字符串中的转义符&quot;&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|addslashes}}&quot; {:name &quot;\&quot;Russian tea is best tea\&quot;&quot;}) =&amp;gt; &quot;\&quot;Russian tea is best tea\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block.super* 在代码块中插入上级代码块中的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;        { % block foo %} { {block.super}} some content{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*capitalize*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|capitalize}}&quot; {:name &quot;russian tea is best tea&quot;}) =&amp;gt; &quot;Russian tea is best tea&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*center*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|center:20}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot; bitemyapp &quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*count*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|count}}&quot; {:name &quot;Yogthos&quot;}) =&amp;gt; &quot;7&quot;

(render &quot;{ {items|count}}&quot; {:items [1 2 3 4]}) =&amp;gt; &quot;4&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*date*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {creation-time|date:\&quot;yyyy-MM-dd_HH:mm:ss\&quot;}}&quot; {:created-at (java.util.Date.)}) =&amp;gt; &quot;2013-07-28_20:51:48&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;[]&quot;

(render &quot;{ {name|default:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*default-if-empty*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name &quot;bitemyapp&quot;}) =&amp;gt; &quot;bitemyapp&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name nil}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {:name []}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;

(render &quot;{ {name|default-if-empty:&quot;I &amp;lt;3 ponies&quot;}}&quot; {}) =&amp;gt; &quot;I &amp;lt;3 ponies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*double-format*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|double-format:2}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.00

(render &quot;{ {tis-a-number|double-format}}&quot; {:tis-a-number 10.00001}) =&amp;gt; 10.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*first*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {seq-of-some-sort|first}}&quot; {:seq-of-some-sort [:dog :cat :bird :bird :bird :is :the :word]}) =&amp;gt; :dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*get-digit* 从右边返回相应位数的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {tis-a-number|get-digit:1}}&quot; {:tis-a-number 12.34567}) =&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*hash* 有效的hash方式: md5, sha, sha256, sha384, sha512&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {domain|hash:\&quot;md5\&quot;}}&quot; {:domain &quot;example.org&quot;}) =&amp;gt; &quot;1bdf72e04d6b50c82a48c7e4dd38cc69&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*join*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|join}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; &quot;1234&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*json* 生成json格式，默认情况下特殊字符会被编码.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data|json}}&quot; {:data [1 2 {:foo 27 :dan &quot;awesome&quot;}]})
               =&amp;gt; &quot;[1,2,{&amp;amp;quot;foo&amp;amp;quot;:27,&amp;amp;quot;dan&amp;amp;quot;:&amp;amp;quot;awesome&amp;amp;quot;}]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不希望被编码则使用safe过滤器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {f|json|safe}}&quot; {:f {:foo 27 :dan &quot;awesome&quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*last*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|last}}&quot; {:sequence 12.34567}) =&amp;gt; 7

(render &quot;{ {sequence|last}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*length-is*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {sequence|length-is:4}}&quot; {:sequence [1 2 3 4]}) =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks* 普通换行替换为html换行,结果在\&amp;lt;p&gt;标签内&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;&amp;lt;p&amp;gt;&amp;lt;br /&amp;gt;bar&amp;lt;br /&amp;gt;baz&amp;lt;/p&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linebreaks-br* 和linebreaks功能相同，但是没有\&amp;lt;p&gt;标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linebreaks-br|safe}}&quot; {:foo &quot;\nbar\nbaz&quot;}) =&amp;gt; &quot;bar&amp;lt;br /&amp;gt;baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*linenumbers* 显示行号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|linenumbers&quot; {:foo &quot;foo\n\bar\nbaz&quot;}) =&amp;gt; &quot;1. foo\n2. \bar\n3. baz&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*lower*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|lower}}&quot; {:foo &quot;FOOBaR&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*pluralize* 返回单词的复数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items []}) =&amp;gt; &quot;0 items&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1]}) =&amp;gt; &quot;1 item&quot;

(render &quot;{ {items|count}} item{ {items|pluralize}}&quot; {:items [1 2]}) =&amp;gt; &quot;2 items&quot;

(render &quot;{ {fruit|count}} tomato{ {fruit|pluralize:\&quot;es\&quot;}}&quot; {:fruit []}) =&amp;gt; &quot;0 tomatoes&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1]}) =&amp;gt; &quot;1 lady&quot;

(render &quot;{ {people|count}} lad{ {people|pluralize:\&quot;y\&quot;:\&quot;ies\&quot;}}&quot; {:people [1 2]}) =&amp;gt; &quot;2 ladies&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*rand-nth* 从集合中返回rand-nths值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|rand-nth}}&quot; {:foo [1 2 3]}) =&amp;gt; &quot;2&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove* 从字符串中去除特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {foo|remove:\&quot;aeiou\&quot;}}&quot; {:foo &quot;abcdefghijklmnop&quot;}) =&amp;gt; &quot;bcdfghjklmnp&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*remove-tags* 去除html标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|remove-tags:b:span }}&quot; {:value &quot;&amp;lt;b&amp;gt;&amp;lt;span&amp;gt;foobar&amp;lt;/span&amp;gt;&amp;lt;/b&amp;gt;&quot;}) =&amp;gt; &quot;foobar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*safe* 默认情况下Selmer会编码所有的内容，此过滤器时Selmer不去编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {data}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;amp;lt;foo&amp;amp;gt;&quot;

(render &quot;{ {data|safe}}&quot; {:data &quot;&amp;lt;foo&amp;gt;&quot;}) =&amp;gt; &quot;&amp;lt;foo&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort }}&quot; {:value [1 4 2 3 5]}) =&amp;gt; &quot;(1 2 3 4 5)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-by*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ { value|sort-by:name }}&quot; {:value [{:name &quot;John&quot;} {:name &quot;Jane&quot;}]})
                     =&amp;gt; &quot;({:name &amp;amp;quot;Jane&amp;amp;quot;} {:name &amp;amp;quot;John&amp;amp;quot;})&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*sort-reversed* 反序排列&lt;/p&gt;

&lt;p&gt;*sort-by-reversed* 和sort-by功能相同，反序&lt;/p&gt;

&lt;p&gt;upper&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ {shout|upper}}&quot; {:shout &quot;hello&quot;}) =&amp;gt; &quot;HELLO&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Filters&lt;/h2&gt;

&lt;p&gt;你可以使用selmer.filters/add-filter!函数来方便的添加自定义的Filter.此
函数以元素作为参数，并返回替换后的值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.filters)

(add-filter! :embiginate #(.toUpperCase %))
 (render &quot;{ {shout|embiginate}}&quot; {:shout &quot;hello&quot;})

(add-filter! :count count)
(render &quot;{ {foo|count}}&quot; {:foo (range 3)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filters可以链式使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ {foo|upper|empty?}}&quot; {:foo &quot;Hello&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Tags&lt;/h2&gt;

&lt;p&gt;Selmer提供了两种类型的Tag。一种是类似extends和include这样的内联tag。这
种tag不需要结束tag。另一种形式的tag是块tag。这种tag有开始和结束tag，以
及代码块。比如if ... endif块。 让我们先来看看默认的tag:&lt;/p&gt;

&lt;p&gt;*include* 将引用的模板内容替换其自身&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % include &quot;path/to/comments.html&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以提供默认的参数，如果tag有匹配上上的参数，则会获取它的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;{ % include &quot;templates/inheritance/child.html&quot; with name=&quot;Jane Doe&quot; greeting=&quot;Hello!&quot; %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*block*
定义一个块，可以使用模板继承的方式来覆盖，类似Java中的父类方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block foo %}This text can be overridden later{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*cycle* 循环提供的参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % for i in items %}&amp;lt;li class={ % cycle \&quot;blue\&quot; \&quot;white\&quot;%}&amp;gt;{ {i}}&amp;lt;/li&amp;gt;{ % endfor %}&quot; {:items (range 5)})
                        =&amp;gt; &quot;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;0&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;white\&quot;&amp;gt;1&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;2&amp;lt;/li&amp;gt;
                            &amp;lt;li class=\&quot;white\&quot;&amp;gt;3&amp;lt;/li&amp;gt;&amp;lt;li class=\&quot;blue\&quot;&amp;gt;4&amp;lt;/li&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*extends* 引用父模板。父模板中的块会被子模板中相应的块覆盖。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Note: 子模板只能包含块。任何块以外的tag或文本都被忽略&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;例如有一个叫base.html的父模板和一个叫child.html的子模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    { % block foo %}This text can be overridden later{ % endblock %}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % extends &quot;base.html&quot; %}
    { % block foo %}
      &amp;lt;p&amp;gt;This text will override the text in the parent&amp;lt;/p&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*if*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % if condition %}yes!{ % endif %}

{ % if condition %}yes!{ % else %}no!{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配合filter使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(add-filter! :empty? empty?)
(render &quot;{ % if files|empty? %}no files{ % else %}files{ % endif %}&quot;
  {:files []})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*ifequal* 之用当两个参数相等时才执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % ifequal foo bar %}yes!{ % endifequal %}

{ % ifequal foo bar %}yes!{ % else %}no!{ % endifequal %}

{ % ifequal foo &quot;this also works&quot; %}yes!{ % endifequal %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*for* 遍历集合中的元素。同时可以使用如下参数。
-   forloop.first
-   forloop.last
-   forloop.counter
-   forloop.counter0
-   forloop.revcounter
-   forloop.revcounter0
-   forloop.length&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for x in some-list %}element: { {x}} first? { {forloop.first}} last? { {forloop.last}}{ % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以直接访问结构化的数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % for item in items %} &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{ {item.name}}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{ {item.age}}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; { % endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*now* 当前时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render (str &quot;{ % now \&quot;&quot; date-format &quot;\&quot;%}&quot;) {}) =&amp;gt; &quot;\&quot;01 08 2013\&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*comment* 注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;foo bar { % comment %} baz test { {x}} { % endcomment %} blah&quot; {}) =&amp;gt; &quot;foo bar baz test blah&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*firstof* 取得第一个不是false的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % firstof var1 var2 var3 %}&quot; {:var2 &quot;x&quot; :var3 &quot;not me&quot;}) =&amp;gt; &quot;x&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*script*
生成一个html的script标签，并以servlet-context键提供的值类作为文件的前
置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;(render &quot;{ % script \&quot;/js/site.js\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;script src=\&quot;/myapp/js/site.js\&quot; type=\&quot;text/javascript\&quot;&amp;gt;&amp;lt;/script&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*style*&lt;/p&gt;

&lt;p&gt;生成一个html的style标签，并以servlet-context键提供的值类作为文件的前置目录.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % style \&quot;/css/screen.css\&quot; %}&quot; {:servlet-context &quot;/myapp&quot;}) =&amp;gt;
&quot;&amp;lt;link href=\&quot;/myapp/css/screen.css\&quot; rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; /&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*verbatim* 阻止内容中的parseeither解析&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % verbatim %}{ {if dying}}Still alive.{ {/if}}{ % endverbatim %}&quot; {}) =&amp;gt; &quot;{ {if dying}}Still alive.{ {/if}}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*with* 向上下文map中新增一个值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(render &quot;{ % with total=business.employees|count %}{ { total }}{ % endwith %}&quot;
         {:business {:employees (range 5)}})
=&amp;gt; &quot;5 employees&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Defining Custom Tags&lt;/h2&gt;

&lt;p&gt;除了上面已经提供的tag。你也可以自定义tag。使用add-tag!宏就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(use 'selmer.parser)

(add-tag! :foo
  (fn [args context-map]
    (str &quot;foo &quot; (first args))))

(render &quot;{ % foo quux %} { % foo baz %}&quot; {})

(add-tag! :bar
  (fn [args context-map content]
    (str content))
  :baz :endbar)

(render &quot;{ % bar %} some text { % baz %} some more text { % endbar %}&quot; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，我们定义的tag提供了一个关键字作为tag的名称后面是tag体,结尾的
tag不是必须的。
当没有结尾的tag时,tag不包含任何内容。这种tag获取参数类进行处理。
当有结尾tag时，每个块内的内容都会被作为开头那个tag所对应的map的键.开头
tag对应的map包含:args和:content键，content的内容就对应到了:content.&lt;/p&gt;

&lt;h2&gt;Template inheritance&lt;/h2&gt;

&lt;p&gt;Selmer模板可以使用块tag来引用其他的模板。有两种方法可以引用模板，一个
是extends一个是include.&lt;/p&gt;

&lt;h3&gt;Extending Templates&lt;/h3&gt;

&lt;p&gt;当我们使用extends这个tag时，当前的模板将会将引用的模板作为父模板。
任何在base模板中的块，会被子模板中相同名字的块给覆盖.
子模板中的内容需要在块tag中。不在块中的内容将会被忽略。
我们来看个例子,我们创建一个叫base.html的父模板.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % block content %}{ % endblock %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们创建一个home.html模板来继承base.html。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;{ % extends &quot;base.html&quot; %}

    { % block content %}
        { % for entry in entries %}
            &amp;lt;h2&amp;gt;{ { entry.title }}&amp;lt;/h2&amp;gt;
            &amp;lt;p&amp;gt;{ { entry.body }}&amp;lt;/p&amp;gt;
        { % endfor %}
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染home.html时entries的内容将会被打印出来。而在home.html中，我们没
有定义title块，在渲染时会获取base.html中的title块的定义。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注意，你可以多层级的继承模板。引擎会渲染最后的那个块.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Including Templates&lt;/h3&gt;

&lt;p&gt;include这个tag允许你包含一个模板。
我们还是来看一个例子，我们有一个base.html这个模板，它包含了一个叫做
register.html的模板和一个home.html的模板：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&amp;gt;
        &amp;lt;title&amp;gt;{ % block title %}My amazing site{ % endblock %}&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;content&quot;&amp;gt;
        { % if user %}
        { % include &quot;templates_path/home.html&quot; %}
        { % else %}
        { % include &quot;templates_path/register.html&quot; %}
        { % endif %}
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们能定义register.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block register %}
      &amp;lt;form action=&quot;/register&quot; method=&quot;POST&quot;&amp;gt;
          &amp;lt;label for=&quot;id&quot;&amp;gt;user id&amp;lt;/label&amp;gt;
          &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input pass=&quot;pass&quot; name=&quot;pass&quot; type=&quot;text&quot;&amp;gt;&amp;lt;/input&amp;gt;
          &amp;lt;input type=&quot;submit&quot; value=&quot;register&quot;&amp;gt;
      &amp;lt;/form&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和home.html:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;    { % block home %}
    &amp;lt;h1&amp;gt;Hello { {user}}&amp;lt;/h1&amp;gt;
    { % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当渲染base.html时，将会引入register.html和home.html。
更多信息请见&lt;a href=&quot;https://github.com/yogthos/Selmer&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;HTML Templating Using Hiccup&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/weavejester/hiccup&quot;&gt;Hiccup&lt;/a&gt;
是另一个Clojure的HTML模板引擎。它的优势是我们可以使用纯正的
Clojure代码来生成页面。也就是说我们不需要学习第三方的语法了。
Hiccup主要使用Clojure的vector来渲染页面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:tag-name {:attribute-key &quot;attribute value&quot;} tag-body]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，如果我们想创建一个包含内容的div，我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div {:id &quot;hello&quot;, :class &quot;content&quot;} [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将生成如下的html代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;        &amp;lt;div id=&quot;hello&quot; class=&quot;content&quot;&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup提供了简化设置id和class的方法，简写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;[:div#hello.content [:p &quot;Hello world!&quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hiccup还提供了一些帮助类函数来创建元素，比如: forms, links, images, 等
等.所有这些函数只是简单的返回类似上面格式的vector。也就是说，如果一个
函数无法达到你的要求，你可以手写相应代码或者获取函数的返回值进行修改。
每个函数可以使用一个map作为其第一个参数，来描绘属性:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(image {:align &quot;left&quot;} &quot;foo.png&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成html代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;&amp;lt;img align=\&quot;left\&quot; src=\&quot;foo.png\&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是最佳实践还是将其保存到独立的CSS文件中。&lt;/p&gt;

&lt;h2&gt;Forms and Input&lt;/h2&gt;

&lt;p&gt;Hiccup还提供了form助手函数，看例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(form-to [:post &quot;/login&quot;]
  (text-field {:placeholder &quot;screen name&quot;} &quot;id&quot;)
  (password-field {:placeholder &quot;password&quot;} &quot;pass&quot;)
  (submit-button &quot;login&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数第一个参数是一个vector，以HTTP请求类型为关键字，紧接着是请求
url。其余的参数必须是HTML元素。生成的HTML代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/login&quot; method=&quot;POST&quot;&amp;gt;
  &amp;lt;input id=&quot;id&quot; name=&quot;id&quot; placeholder=&quot;screen name&quot; type=&quot;text&quot; /&amp;gt;
  &amp;lt;input id=&quot;pass&quot; name=&quot;pass&quot; placeholder=&quot;password&quot; type=&quot;password&quot; /&amp;gt;
  &amp;lt;input type=&quot;submit&quot; value=&quot;login&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后LUminus模板在你的应用下面提供了一辅助函数。叫做md-&gt;html,这个函数能
渲染载resources/public/目录下的markdown文件并返回一个HTML字符串。这个
可以和Hiccup函数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(:require [&amp;lt;yourapp&amp;gt;.util :as util])
...
(html [:div.contenr [:p (util/md-&amp;gt;html &quot;/md/paragraph.md&quot;)]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;markdown生成由markdown-clj来处理，具体信息请见其&lt;a href=&quot;https://github.com/yogthos/markdown-clj&quot;&gt;Github&lt;/a&gt;
页。&lt;/p&gt;

&lt;h1&gt;Content caching&lt;/h1&gt;

&lt;p&gt;lib-noir通过cache!宏提供了基本的内存式缓存，相应的宏在noir.util.cache
下。如果想缓存一个页面，你是需要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(require '[noir.util.cache :as cache])

(defn slow-loading-page []
  (cache/cache!
   :slow-page
   (common/layout
    [:div &quot;I load slowly&quot;]
     (parse-lots-of-files))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用invalidate!来取消缓存,需要提供需要取消的缓存的key。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/invalidate! :slow-page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用clear!来清除当前所有的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/clear!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用set-timeout!来设置缓存时间(单位：秒)，超时后会重新加载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-timeout! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后你可以通过set-size!来设置缓存的大小。当缓存超出了限定的大小，最先
使用的数据将被被替换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(cache/set-size! 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意，缓存会在操作成功后才重新加载。也就是说，比如程序去获取一个远程
文件，但是失败了，那么缓存是不会被重新加载的。&lt;/li&gt;
&lt;/ul&gt;

</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-应用配置</title>
        <link href="http://ivanpig.github.io/2013/09/15/application_profile.html"/>
        <updated>2013-09-15T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/15/application_profile</id>
        <content type="html">&lt;h1&gt;Profiles&lt;/h1&gt;

&lt;p&gt;使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。&lt;/p&gt;

&lt;p&gt;下面就是各个配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+cljs - 添加ClojureScript支持&lt;/li&gt;
&lt;li&gt;+cucumber - 提供通过clj-webdriver配置cucumber&lt;/li&gt;
&lt;li&gt;+h2 - 添加models.db并提供H2数据库依赖&lt;/li&gt;
&lt;li&gt;+postgres - 添加models.db并提供PostreSQL数据库依赖&lt;/li&gt;
&lt;li&gt;+mysql - 添加models.db并提供mysql依赖&lt;/li&gt;
&lt;li&gt;+mongodb - 添加db.core并提供MongoDB依赖&lt;/li&gt;
&lt;li&gt;+site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2&lt;/li&gt;
&lt;li&gt;+dailycred -
添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架&lt;/li&gt;
&lt;li&gt;+http-kit - 添加HTTP Kit支持&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;要添加配置，只需要简单的添加到你的应用的名字后面，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +cljs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以多个参数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +site +postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生
成的文件。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;HTTP Kit notes&lt;/h1&gt;

&lt;p&gt;HTTP Kit是一个嵌入式的服务器。与Jetty不同的是，HTTP Kit并不被lein-ring
支持。所以你需要这样来运行HTTP Kit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能热部署，你需要使用-dev选项，并且可以自定义端口号。默认端口号是8080
要打包一个可运行的HTTP Kit的jar不包，使用如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein uberjar
&lt;/code&gt;&lt;/pre&gt;
</content>
        <summary type="html">&lt;h1&gt;Profiles&lt;/h1&gt;

&lt;p&gt;使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。&lt;/p&gt;

&lt;p&gt;下面就是各个配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;+cljs - 添加ClojureScript支持&lt;/li&gt;
&lt;li&gt;+cucumber - 提供通过clj-webdriver配置cucumber&lt;/li&gt;
&lt;li&gt;+h2 - 添加models.db并提供H2数据库依赖&lt;/li&gt;
&lt;li&gt;+postgres - 添加models.db并提供PostreSQL数据库依赖&lt;/li&gt;
&lt;li&gt;+mysql - 添加models.db并提供mysql依赖&lt;/li&gt;
&lt;li&gt;+mongodb - 添加db.core并提供MongoDB依赖&lt;/li&gt;
&lt;li&gt;+site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2&lt;/li&gt;
&lt;li&gt;+dailycred -
添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架&lt;/li&gt;
&lt;li&gt;+http-kit - 添加HTTP Kit支持&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;要添加配置，只需要简单的添加到你的应用的名字后面，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +cljs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以多个参数一起使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein new luminus myapp +site +postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生
成的文件。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;h1&gt;HTTP Kit notes&lt;/h1&gt;

&lt;p&gt;HTTP Kit是一个嵌入式的服务器。与Jetty不同的是，HTTP Kit并不被lein-ring
支持。所以你需要这样来运行HTTP Kit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能热部署，你需要使用-dev选项，并且可以自定义端口号。默认端口号是8080
要打包一个可运行的HTTP Kit的jar不包，使用如下的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.bash}&quot;&gt;lein uberjar
&lt;/code&gt;&lt;/pre&gt;
</summary>
    </entry>
    
    <entry>
        <title>Luminus手册-第一个应用</title>
        <link href="http://ivanpig.github.io/2013/09/14/your_first_application.html"/>
        <updated>2013-09-14T00:00:00+08:00</updated>
        <id>http://ivanpig.github.io//2013/09/14/your_first_application</id>
        <content type="html">&lt;h1&gt;Guestbook应用&lt;/h1&gt;

&lt;p&gt;此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构.&lt;/p&gt;

&lt;h1&gt;安装Leiningen&lt;/h1&gt;

&lt;p&gt;首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载脚本&lt;/li&gt;
&lt;li&gt;将其设置为可执行权限(chmod +x lein)&lt;/li&gt;
&lt;li&gt;将脚本放到你的PATH下面&lt;/li&gt;
&lt;li&gt;运行lein self-install ，然后等待安装结束&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod +x lein
mv lein ~/bin
lein self-install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建一个新应用&lt;/h1&gt;

&lt;p&gt;安装完Leiningen后，你就可以在命令行中输入如下的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein new luminus guestbook +h2
cd guestbook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。现在我们就可以运行这个项目了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server
guestbook started successfully...
2013-03-01 19:05:30.389:INFO:oejs.Server:jetty-7.6.1.v20120215
Started server on port 3000
2013-03-01 19:05:30.459:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器会自动打开，你将能看到运行的应用。如果你不想浏览器自动打开，你可以用下面的命令来启动项目.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以自定义端口号，命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless 8000
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;剖析Luminus应用&lt;/h1&gt;

&lt;p&gt;新创建的项目的目录结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;example&quot;&gt;Procfile
README.md
project.clj
src
  └ log4j.xml
    guestbook
       └ handler.clj
         util.clj
         repl.clj
         models
           └ db.clj
             schema.clj
          routes
           └ home.clj
          views
           └ layout.clj
           └ templates
              └ about.html
                base.html
                home.html
test
  └ guestbook
       └ test
           └ handler.clj
resources
  └ public
       └ css
           └ screen.css
             img
             js
             md
              └ docs.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来看一看根目录下的文件的作用:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Procfile - 部署相关信息&lt;/li&gt;
&lt;li&gt;README.md - 项目相关的文档&lt;/li&gt;
&lt;li&gt;project.clj - 用于管理项目的配置以及Leiningen依赖关系&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;源代码目录&lt;/h1&gt;

&lt;p&gt;所有的代码都在src目录下。我们的应用名称叫guestbook，这个名字同时也是源代码的根命名空间。让我们来看一下源代码目录下所有的命名空间。&lt;/p&gt;

&lt;h2&gt;guestbook&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;handler.clj - 定义了应用最基本的路由。这是应用的入口。我们自定义的所有的页面都需要在这里添加各自的路由定义。&lt;/li&gt;
&lt;li&gt;layout.clj - 页面布局帮助命名空间&lt;/li&gt;
&lt;li&gt;middleware.clj - 中间件命名空间&lt;/li&gt;
&lt;li&gt;repl.clj - 提供了从REPL启动和停止应用的函数&lt;/li&gt;
&lt;li&gt;util.clj - 提供了常用的帮助类函数，比较常用的是md-&gt;html的帮助函数&lt;/li&gt;
&lt;li&gt;log4j.xml - Korma的日志配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.db&lt;/h2&gt;

&lt;p&gt;db命名空间下定义的是应用所使用的model以及持久化相关操作.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;core.clj - 包含一组可以和数据库交互的函数&lt;/li&gt;
&lt;li&gt;schema.clj - 用来定义数据库连接参数以及数据表&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.routes&lt;/h2&gt;

&lt;p&gt;routes命名空间是存放路由以及controller的地方。当你要添加路由的时候，比如安全验证，特殊流程等等，你需要在这里创建他们。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;home.clj - 一个定义了home和about页面的命名空间&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;测试目录&lt;/h1&gt;

&lt;p&gt;这里是放置测试代码的地方。该目录下已经有样例测试代码。&lt;/p&gt;

&lt;h1&gt;资源目录&lt;/h1&gt;

&lt;p&gt;这里是存放静态资源的地方。包括css,javascript,images和markdown.&lt;/p&gt;

&lt;h2&gt;HTML模板&lt;/h2&gt;

&lt;p&gt;这个命名空间存放的是Selmer模板文件，用于应用页面的展示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;about.html - about页面&lt;/li&gt;
&lt;li&gt;base.html - base页面&lt;/li&gt;
&lt;li&gt;home.html - home页面&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;添加依赖&lt;/h1&gt;

&lt;p&gt;上面已经说过了，项目所有的依赖关系都是由project.clj来管理的。这个文件看起来像这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defproject
  guestbook &quot;0.1.0-SNAPSHOT&quot;

  :url &quot;http://example.com/FIXME&quot;
  :description &quot;FIXME: write description&quot;

  :dependencies
  [[com.h2database/h2 &quot;1.4.178&quot;]
   [ring-server &quot;0.3.1&quot;]
   [environ &quot;1.0.0&quot;]
   [com.taoensso/timbre &quot;3.2.1&quot;]
   [markdown-clj &quot;0.9.55&quot;]
   [korma &quot;0.4.0&quot;]
   [com.taoensso/tower &quot;2.0.2&quot;]
   [selmer &quot;0.7.2&quot;]
   [org.clojure/clojure &quot;1.6.0&quot;]
   [log4j
    &quot;1.2.17&quot;
    :exclusions
    [javax.mail/mail
     javax.jms/jms
     com.sun.jdmk/jmxtools
     com.sun.jmx/jmxri]]
   [compojure &quot;1.2.1&quot;]
   [lib-noir &quot;0.9.4&quot;]]

  :plugins
  [[lein-ring &quot;0.8.13&quot;] [lein-environ &quot;1.0.0&quot;]]

  :ring
  {:handler guestbook.handler/app,
   :init guestbook.handler/init,
   :destroy guestbook.handler/destroy}

  :profiles
  {:uberjar {:aot :all}
   :production
   {:ring
    {:open-browser? false, :stacktraces? false, :auto-reload? false}},
   :dev
   {:dependencies [[ring-mock &quot;0.1.5&quot;] [ring/ring-devel &quot;1.2.2&quot;]],
    :env {:dev true}}}

  :min-lein-version &quot;2.0.0&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;project.clj就是个简单的Clojure的list，这个list中包含了键值对，描述了应用的方方面面。如果你要添加自定义依赖，只需要简单的将需要的依赖添加到:dependencies这个vector内。&lt;/p&gt;

&lt;h1&gt;访问数据库&lt;/h1&gt;

&lt;p&gt;首先，我们来创建一个model。我们需要编辑位于src/guestbook/db目录下的schema.clj文件。
这这个文件中，已经定义了数据库连接。定义的方式就是使用了一个包含了jdbc驱动，协议，用户名和密码的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.schema
  (:require [clojure.java.jdbc :as sql]
            [clojure.java.io :refer [file]]
            [noir.io :as io]))

(def db-store (str (.getName (file &quot;.&quot;)) &quot;/site.db&quot;))

(def db-spec {:classname &quot;org.h2.Driver&quot;
              :subprotocol &quot;h2&quot;
              :subname db-store
              :user &quot;sa&quot;
              :password &quot;&quot;
              :make-pool? true
              :naming {:keys clojure.string/lower-case
                       :fields clojure.string/upper-case}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;紧接着是一个叫做create-users-table的函数。这是用来定义名字叫做users的
数据表的。我们替换掉这个函数，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-guestbook-table []
  (sql/db-do-commands
    db-spec
    (sql/create-table-ddl
      :guestbook
      [:id &quot;INTEGER PRIMARY KEY AUTO_INCREMENT&quot;]
      [:timestamp :timestamp]
      [:name &quot;varchar(30)&quot;]
      [:message &quot;varchar(200)&quot;]))
  (sql/db-do-prepared db-spec
      &quot;CREATE INDEX timestamp_index ON guestbook (timestamp)&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数定义了guestbook数据表结构。同时我们修改create-tables函数来调用它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-tables
  &quot;creates the database tables used by the application&quot;
  []
  (create-guestbook-table))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据表创建完成后，我们就可以来读写留言信息了。让我们打开core.clj文件。同样的，文件里已经有了一些代码，我们需要替换它们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.core
  (:use korma.core
        [korma.db :only (defdb)])
  (:require [guestbook.db.schema :as schema]))

(defdb db schema/db-spec)

(defentity guestbook)

(defn save-message
  [name message]
  (insert guestbook
          (values {:name name
                   :message message
                   :timestamp (new java.util.Date)})))

(defn get-messages []
  (select guestbook))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们创建了一个实体来映射guestbook数据表。然后创建了save-message和get-message来操作它.&lt;/p&gt;

&lt;h1&gt;启动时运行&lt;/h1&gt;

&lt;p&gt;hander命名空间中包含了一个叫做init的函数。这个函数只会在应用启动的时候调用一次。让我们来添加一些代码来验证数据库是否在应用启动前初始化成功。
为了能够使用initialized?和create-tables函数，我们需要一个指向schema命名空间的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.handler
  (:use ...)
  (:require ...
            [guestbook.db.schema :as schema]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们修改init函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;init will be called once when
   app is deployed as a servlet on
   an app server such as Tomcat
   put any initialization code here&quot;
  []
  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/appender-fn})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;guestbook.log&quot; :max-size (* 512 1024) :backlog 10})

  (if (env :selmer-dev) (parser/cache-off!))

  ;;initialize the database if needed
  (when-not (schema/initialized?)
    (schema/create-tables))

  (timbre/info &quot;guestbook started successfully&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们修改了init函数，我们就需要重启应用。使用CTRL+c来停止应用，再输入lein ring server来启动应用。&lt;/p&gt;

&lt;h1&gt;创建表单页面&lt;/h1&gt;

&lt;p&gt;应用的路由是定义在guestbook.routes.home命名空间下的。我们来打开它，并添加一些逻辑。首先，需要添加db命名空间.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.routes.home
  (:use ...)
  (:require ...
            [guestbook.db.core :as db]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后呢，我们会修改home-page这个controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn home-page [&amp;amp; [name message error]]
  (layout/render &quot;home.html&quot;
                 {:error    error
                  :name     name
                  :message  message
                  :messages (db/get-messages)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们所做的就是多传递了几个参数给模板，其中一个是从数据库中查询到的信息.&lt;/p&gt;

&lt;p&gt;我们提供了用户可以发布新留言的功能，所以我们需要在controller中来处理这
个请求:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn save-message [name message]
  (cond

    (empty? name)
    (home-page name message &quot;Somebody forgot to leave a name&quot;)

    (empty? message)
    (home-page name message &quot;Don't you have something to say?&quot;)

    :else
    (do
      (db/save-message name message)
      (home-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后呢，在home-routes定义里面添加这个controller的路由定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes home-routes
  (GET &quot;/&quot; [] (home-page))
  (POST &quot;/&quot; [name message] (save-message name message))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;controller已经编写OK。我们打开处于resources/templates下的home.html模板,目前只是简单的显示内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Time to start building your site!&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;http://luminusweb.net&quot;&amp;gt;Learn more &amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
    { {content|safe}}
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们改为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
      &amp;lt;ul&amp;gt;
      { % for item in messages %}
        &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
        &amp;lt;/li&amp;gt;
      { % endfor %}
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了迭代器来遍历信息。而每个迭代结果都是一个包含了信息的map。我们能通过名字来访问它们。同时，我们使用了一个日期过滤器来生成一个适于人类阅读的时间. 接着我们来添加错误信息的展示.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只是简单的检查了一下是否有错误信息，如果有就展示。最后我们创建一个form来接受用户提交留言.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，home.html看起来像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;guestbook/views/templates/base.html&quot; %}

{ % block content %}
    &amp;lt;ul&amp;gt;
    { % for item in messages %}
      &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
      &amp;lt;/li&amp;gt;
    { % endfor %}
    &amp;lt;/ul&amp;gt;

{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}

&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以修改位于resources/public/css目录下的screen.css来使得页面更好看一些.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.css}&quot;&gt;body {
    height: 100%;
    padding-top: 70px;
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #eaeaea;
    color: #4d4d4d;
    width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-font-smoothing: antialiased;
    -ms-font-smoothing: antialiased;
    -o-font-smoothing: antialiased;
    font-smoothing: antialiased;
}

input[type=submit] {
    margin: 0;
    padding: 0;
    border: 0;
  line-height: 1.4em;
    background: none;
    vertical-align: baseline;
}

input[type=submit], textarea {
    font-size: 24px;
    font-family: inherit;
    border: 0;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -o-box-sizing: border-box;
    box-sizing: border-box;
}

input[type=submit]:hover {
    background: rgba(0, 0, 0, 0.15);
    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.3);
}

textarea {
    position: relative;
    line-height: 1em;
    width: 100%;
}

.error {
  font-weight: bold;
    color: red;
}

.jumbotron {
    position: relative;
    background: white;
    z-index: 2;
    border-top: 1px dotted #adadad;
}

h1 {
    width: 100%;
    font-size: 70px;
    font-weight: bold;
    text-align: center;
}

ul {
    margin: 0;
    padding: 0;
    list-style: none;
}

li {
    position: relative;
    font-size: 16px;
    padding: 5px;
    border-bottom: 1px dotted #ccc;
  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

li:last-child {
    border-bottom: none;
}

li time {
    font-size: 12px;
    padding-bottom: 20px;
}

form:before, .error:before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    height: 15px;
    border-bottom: 1px solid #6c615c;
    background: #8d7d77;
}

form, .error {
    width: 520px;
    padding: 30px;
    margin-bottom: 50px;
    background: #fff;
    border: 1px solid #ccc;
    position: relative;
    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

form input {
    width: 50%;
    clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在刷新页面就可以看到我们修改的内容了。试试留个言！&lt;/p&gt;

&lt;h1&gt;打包应用&lt;/h1&gt;

&lt;p&gt;要打包程序，可输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会创建一个可运行的jar。通过下面的命令来运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;java -jar target/guestbook-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想把应用部署到tomcat这样的服务器上，你可以运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会打包一个war包。&lt;/p&gt;

&lt;p&gt;完整的源代码可以到&lt;a href=&quot;https://github.com/yogthos/guestbook&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
</content>
        <summary type="html">&lt;h1&gt;Guestbook应用&lt;/h1&gt;

&lt;p&gt;此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构.&lt;/p&gt;

&lt;h1&gt;安装Leiningen&lt;/h1&gt;

&lt;p&gt;首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载脚本&lt;/li&gt;
&lt;li&gt;将其设置为可执行权限(chmod +x lein)&lt;/li&gt;
&lt;li&gt;将脚本放到你的PATH下面&lt;/li&gt;
&lt;li&gt;运行lein self-install ，然后等待安装结束&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod +x lein
mv lein ~/bin
lein self-install
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建一个新应用&lt;/h1&gt;

&lt;p&gt;安装完Leiningen后，你就可以在命令行中输入如下的命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein new luminus guestbook +h2
cd guestbook
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。现在我们就可以运行这个项目了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server
guestbook started successfully...
2013-03-01 19:05:30.389:INFO:oejs.Server:jetty-7.6.1.v20120215
Started server on port 3000
2013-03-01 19:05:30.459:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器会自动打开，你将能看到运行的应用。如果你不想浏览器自动打开，你可以用下面的命令来启动项目.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以自定义端口号，命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring server-headless 8000
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;


&lt;h1&gt;剖析Luminus应用&lt;/h1&gt;

&lt;p&gt;新创建的项目的目录结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;example&quot;&gt;Procfile
README.md
project.clj
src
  └ log4j.xml
    guestbook
       └ handler.clj
         util.clj
         repl.clj
         models
           └ db.clj
             schema.clj
          routes
           └ home.clj
          views
           └ layout.clj
           └ templates
              └ about.html
                base.html
                home.html
test
  └ guestbook
       └ test
           └ handler.clj
resources
  └ public
       └ css
           └ screen.css
             img
             js
             md
              └ docs.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先来看一看根目录下的文件的作用:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Procfile - 部署相关信息&lt;/li&gt;
&lt;li&gt;README.md - 项目相关的文档&lt;/li&gt;
&lt;li&gt;project.clj - 用于管理项目的配置以及Leiningen依赖关系&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;源代码目录&lt;/h1&gt;

&lt;p&gt;所有的代码都在src目录下。我们的应用名称叫guestbook，这个名字同时也是源代码的根命名空间。让我们来看一下源代码目录下所有的命名空间。&lt;/p&gt;

&lt;h2&gt;guestbook&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;handler.clj - 定义了应用最基本的路由。这是应用的入口。我们自定义的所有的页面都需要在这里添加各自的路由定义。&lt;/li&gt;
&lt;li&gt;layout.clj - 页面布局帮助命名空间&lt;/li&gt;
&lt;li&gt;middleware.clj - 中间件命名空间&lt;/li&gt;
&lt;li&gt;repl.clj - 提供了从REPL启动和停止应用的函数&lt;/li&gt;
&lt;li&gt;util.clj - 提供了常用的帮助类函数，比较常用的是md-&gt;html的帮助函数&lt;/li&gt;
&lt;li&gt;log4j.xml - Korma的日志配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.db&lt;/h2&gt;

&lt;p&gt;db命名空间下定义的是应用所使用的model以及持久化相关操作.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;core.clj - 包含一组可以和数据库交互的函数&lt;/li&gt;
&lt;li&gt;schema.clj - 用来定义数据库连接参数以及数据表&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;guestbook.routes&lt;/h2&gt;

&lt;p&gt;routes命名空间是存放路由以及controller的地方。当你要添加路由的时候，比如安全验证，特殊流程等等，你需要在这里创建他们。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;home.clj - 一个定义了home和about页面的命名空间&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;测试目录&lt;/h1&gt;

&lt;p&gt;这里是放置测试代码的地方。该目录下已经有样例测试代码。&lt;/p&gt;

&lt;h1&gt;资源目录&lt;/h1&gt;

&lt;p&gt;这里是存放静态资源的地方。包括css,javascript,images和markdown.&lt;/p&gt;

&lt;h2&gt;HTML模板&lt;/h2&gt;

&lt;p&gt;这个命名空间存放的是Selmer模板文件，用于应用页面的展示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;about.html - about页面&lt;/li&gt;
&lt;li&gt;base.html - base页面&lt;/li&gt;
&lt;li&gt;home.html - home页面&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;添加依赖&lt;/h1&gt;

&lt;p&gt;上面已经说过了，项目所有的依赖关系都是由project.clj来管理的。这个文件看起来像这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defproject
  guestbook &quot;0.1.0-SNAPSHOT&quot;

  :url &quot;http://example.com/FIXME&quot;
  :description &quot;FIXME: write description&quot;

  :dependencies
  [[com.h2database/h2 &quot;1.4.178&quot;]
   [ring-server &quot;0.3.1&quot;]
   [environ &quot;1.0.0&quot;]
   [com.taoensso/timbre &quot;3.2.1&quot;]
   [markdown-clj &quot;0.9.55&quot;]
   [korma &quot;0.4.0&quot;]
   [com.taoensso/tower &quot;2.0.2&quot;]
   [selmer &quot;0.7.2&quot;]
   [org.clojure/clojure &quot;1.6.0&quot;]
   [log4j
    &quot;1.2.17&quot;
    :exclusions
    [javax.mail/mail
     javax.jms/jms
     com.sun.jdmk/jmxtools
     com.sun.jmx/jmxri]]
   [compojure &quot;1.2.1&quot;]
   [lib-noir &quot;0.9.4&quot;]]

  :plugins
  [[lein-ring &quot;0.8.13&quot;] [lein-environ &quot;1.0.0&quot;]]

  :ring
  {:handler guestbook.handler/app,
   :init guestbook.handler/init,
   :destroy guestbook.handler/destroy}

  :profiles
  {:uberjar {:aot :all}
   :production
   {:ring
    {:open-browser? false, :stacktraces? false, :auto-reload? false}},
   :dev
   {:dependencies [[ring-mock &quot;0.1.5&quot;] [ring/ring-devel &quot;1.2.2&quot;]],
    :env {:dev true}}}

  :min-lein-version &quot;2.0.0&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;project.clj就是个简单的Clojure的list，这个list中包含了键值对，描述了应用的方方面面。如果你要添加自定义依赖，只需要简单的将需要的依赖添加到:dependencies这个vector内。&lt;/p&gt;

&lt;h1&gt;访问数据库&lt;/h1&gt;

&lt;p&gt;首先，我们来创建一个model。我们需要编辑位于src/guestbook/db目录下的schema.clj文件。
这这个文件中，已经定义了数据库连接。定义的方式就是使用了一个包含了jdbc驱动，协议，用户名和密码的map。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.schema
  (:require [clojure.java.jdbc :as sql]
            [clojure.java.io :refer [file]]
            [noir.io :as io]))

(def db-store (str (.getName (file &quot;.&quot;)) &quot;/site.db&quot;))

(def db-spec {:classname &quot;org.h2.Driver&quot;
              :subprotocol &quot;h2&quot;
              :subname db-store
              :user &quot;sa&quot;
              :password &quot;&quot;
              :make-pool? true
              :naming {:keys clojure.string/lower-case
                       :fields clojure.string/upper-case}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;紧接着是一个叫做create-users-table的函数。这是用来定义名字叫做users的
数据表的。我们替换掉这个函数，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-guestbook-table []
  (sql/db-do-commands
    db-spec
    (sql/create-table-ddl
      :guestbook
      [:id &quot;INTEGER PRIMARY KEY AUTO_INCREMENT&quot;]
      [:timestamp :timestamp]
      [:name &quot;varchar(30)&quot;]
      [:message &quot;varchar(200)&quot;]))
  (sql/db-do-prepared db-spec
      &quot;CREATE INDEX timestamp_index ON guestbook (timestamp)&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数定义了guestbook数据表结构。同时我们修改create-tables函数来调用它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn create-tables
  &quot;creates the database tables used by the application&quot;
  []
  (create-guestbook-table))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据表创建完成后，我们就可以来读写留言信息了。让我们打开core.clj文件。同样的，文件里已经有了一些代码，我们需要替换它们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.db.core
  (:use korma.core
        [korma.db :only (defdb)])
  (:require [guestbook.db.schema :as schema]))

(defdb db schema/db-spec)

(defentity guestbook)

(defn save-message
  [name message]
  (insert guestbook
          (values {:name name
                   :message message
                   :timestamp (new java.util.Date)})))

(defn get-messages []
  (select guestbook))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们创建了一个实体来映射guestbook数据表。然后创建了save-message和get-message来操作它.&lt;/p&gt;

&lt;h1&gt;启动时运行&lt;/h1&gt;

&lt;p&gt;hander命名空间中包含了一个叫做init的函数。这个函数只会在应用启动的时候调用一次。让我们来添加一些代码来验证数据库是否在应用启动前初始化成功。
为了能够使用initialized?和create-tables函数，我们需要一个指向schema命名空间的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.handler
  (:use ...)
  (:require ...
            [guestbook.db.schema :as schema]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们修改init函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn init
  &quot;init will be called once when
   app is deployed as a servlet on
   an app server such as Tomcat
   put any initialization code here&quot;
  []
  (timbre/set-config!
    [:appenders :rotor]
    {:min-level :info
     :enabled? true
     :async? false ; should be always false for rotor
     :max-message-per-msecs nil
     :fn rotor/appender-fn})

  (timbre/set-config!
    [:shared-appender-config :rotor]
    {:path &quot;guestbook.log&quot; :max-size (* 512 1024) :backlog 10})

  (if (env :selmer-dev) (parser/cache-off!))

  ;;initialize the database if needed
  (when-not (schema/initialized?)
    (schema/create-tables))

  (timbre/info &quot;guestbook started successfully&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们修改了init函数，我们就需要重启应用。使用CTRL+c来停止应用，再输入lein ring server来启动应用。&lt;/p&gt;

&lt;h1&gt;创建表单页面&lt;/h1&gt;

&lt;p&gt;应用的路由是定义在guestbook.routes.home命名空间下的。我们来打开它，并添加一些逻辑。首先，需要添加db命名空间.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(ns guestbook.routes.home
  (:use ...)
  (:require ...
            [guestbook.db.core :as db]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后呢，我们会修改home-page这个controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn home-page [&amp;amp; [name message error]]
  (layout/render &quot;home.html&quot;
                 {:error    error
                  :name     name
                  :message  message
                  :messages (db/get-messages)}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们所做的就是多传递了几个参数给模板，其中一个是从数据库中查询到的信息.&lt;/p&gt;

&lt;p&gt;我们提供了用户可以发布新留言的功能，所以我们需要在controller中来处理这
个请求:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defn save-message [name message]
  (cond

    (empty? name)
    (home-page name message &quot;Somebody forgot to leave a name&quot;)

    (empty? message)
    (home-page name message &quot;Don't you have something to say?&quot;)

    :else
    (do
      (db/save-message name message)
      (home-page))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后呢，在home-routes定义里面添加这个controller的路由定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.clojure}&quot;&gt;(defroutes home-routes
  (GET &quot;/&quot; [] (home-page))
  (POST &quot;/&quot; [name message] (save-message name message))
  (GET &quot;/about&quot; [] (about-page)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;controller已经编写OK。我们打开处于resources/templates下的home.html模板,目前只是简单的显示内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Time to start building your site!&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;http://luminusweb.net&quot;&amp;gt;Learn more &amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
    { {content|safe}}
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们改为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;templates/base.html&quot; %}
{ % block content %}
 &amp;lt;div class=&quot;jumbotron&quot;&amp;gt;
    &amp;lt;h1&amp;gt;Welcome to guestbook&amp;lt;/h1&amp;gt;
 &amp;lt;/div&amp;gt;

 &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
    &amp;lt;div class=&quot;span8&quot;&amp;gt;
      &amp;lt;ul&amp;gt;
      { % for item in messages %}
        &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
        &amp;lt;/li&amp;gt;
      { % endfor %}
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了迭代器来遍历信息。而每个迭代结果都是一个包含了信息的map。我们能通过名字来访问它们。同时，我们使用了一个日期过滤器来生成一个适于人类阅读的时间. 接着我们来添加错误信息的展示.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只是简单的检查了一下是否有错误信息，如果有就展示。最后我们创建一个form来接受用户提交留言.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.html}&quot;&gt;&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，home.html看起来像这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;{ % extends &quot;guestbook/views/templates/base.html&quot; %}

{ % block content %}
    &amp;lt;ul&amp;gt;
    { % for item in messages %}
      &amp;lt;li&amp;gt;
          &amp;lt;time&amp;gt;{ {item.timestamp|date:&quot;yyyy-MM-dd HH:mm&quot;}}&amp;lt;/time&amp;gt;
          &amp;lt;p&amp;gt;{ {item.message}}&amp;lt;/p&amp;gt;
          &amp;lt;p&amp;gt; - { {item.name}}&amp;lt;/p&amp;gt;
      &amp;lt;/li&amp;gt;
    { % endfor %}
    &amp;lt;/ul&amp;gt;

{ % if error %}
    &amp;lt;p&amp;gt;{ {error}}&amp;lt;/p&amp;gt;
{ % endif %}

&amp;lt;form action=&quot;/&quot; method=&quot;POST&quot;&amp;gt;
    &amp;lt;p&amp;gt;
       Name:
       &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; value={ {name}}&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
       Message:
       &amp;lt;textarea rows=&quot;4&quot; cols=&quot;50&quot; name=&quot;message&quot;&amp;gt;
           { {message}}
       &amp;lt;/textarea&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;comment&quot;&amp;gt;
&amp;lt;/form&amp;gt;
{ % endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以修改位于resources/public/css目录下的screen.css来使得页面更好看一些.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;{.css}&quot;&gt;body {
    height: 100%;
    padding-top: 70px;
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #eaeaea;
    color: #4d4d4d;
    width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-font-smoothing: antialiased;
    -ms-font-smoothing: antialiased;
    -o-font-smoothing: antialiased;
    font-smoothing: antialiased;
}

input[type=submit] {
    margin: 0;
    padding: 0;
    border: 0;
  line-height: 1.4em;
    background: none;
    vertical-align: baseline;
}

input[type=submit], textarea {
    font-size: 24px;
    font-family: inherit;
    border: 0;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    -moz-box-sizing: border-box;
    -ms-box-sizing: border-box;
    -o-box-sizing: border-box;
    box-sizing: border-box;
}

input[type=submit]:hover {
    background: rgba(0, 0, 0, 0.15);
    box-shadow: 0 -1px 0 0 rgba(0, 0, 0, 0.3);
}

textarea {
    position: relative;
    line-height: 1em;
    width: 100%;
}

.error {
  font-weight: bold;
    color: red;
}

.jumbotron {
    position: relative;
    background: white;
    z-index: 2;
    border-top: 1px dotted #adadad;
}

h1 {
    width: 100%;
    font-size: 70px;
    font-weight: bold;
    text-align: center;
}

ul {
    margin: 0;
    padding: 0;
    list-style: none;
}

li {
    position: relative;
    font-size: 16px;
    padding: 5px;
    border-bottom: 1px dotted #ccc;
  box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

li:last-child {
    border-bottom: none;
}

li time {
    font-size: 12px;
    padding-bottom: 20px;
}

form:before, .error:before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    left: 0;
    height: 15px;
    border-bottom: 1px solid #6c615c;
    background: #8d7d77;
}

form, .error {
    width: 520px;
    padding: 30px;
    margin-bottom: 50px;
    background: #fff;
    border: 1px solid #ccc;
    position: relative;
    box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.15);
}

form input {
    width: 50%;
    clear: both;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在刷新页面就可以看到我们修改的内容了。试试留个言！&lt;/p&gt;

&lt;h1&gt;打包应用&lt;/h1&gt;

&lt;p&gt;要打包程序，可输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberjar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会创建一个可运行的jar。通过下面的命令来运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;java -jar target/guestbook-0.1.0-SNAPSHOT-standalone.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们想把应用部署到tomcat这样的服务器上，你可以运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;lein ring uberwar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会打包一个war包。&lt;/p&gt;

&lt;p&gt;完整的源代码可以到&lt;a href=&quot;https://github.com/yogthos/guestbook&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
</summary>
    </entry>
    

</feed>
