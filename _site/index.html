<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="keywords" content=""/>
    <meta name="author" content="liyouhai.com"> 
    <link rel="canonical" href="http://liyouhai.com/index.html">
    <link href="http://liyouhai.com/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
    <title>IvanPig's Blog</title>
    <link rel="stylesheet" href="/css/min/pure-min.css">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
    <!--<![endif]-->

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/JekyllPure.css">
    <!--<![endif]-->

    <link href="/css/min/font-awesome.min.css" rel="stylesheet">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
    <![endif]-->
    <script src="/js/min/jquery-1.7.2.min.js"></script>
    <!--
     /\_ \    __                         /\ \                __
     \//\ \  /\_\  __  __    ___   __  __\ \ \___      __   /\_\
       \ \ \ \/\ \/\ \/\ \  / __`\/\ \/\ \\ \  _ `\  /'__`\ \/\ \
        \_\ \_\ \ \ \ \_\ \/\ \L\ \ \ \_\ \\ \ \ \ \/\ \L\.\_\ \ \
        /\____\\ \_\/`____ \ \____/\ \____/ \ \_\ \_\ \__/.\_\\ \_\
        \/____/ \/_/`/___/> \/___/  \/___/   \/_/\/_/\/__/\/_/ \/_/
                       /\___/
                       \/__/
     图像可以到http://asciigen.com/  生成..记得翻墙才能正常生成.如不方便可以博客留言我帮你生成
     -->
</head>

<body>







<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
        <div class="header">
            <div class="headerpic">
                <a href="/">
                    <img src="/img/op.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                </a>
            </div>
            <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
            <h2 class="brand-tagline">IvanPig's Blog</h2>

            <nav class="nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a class="pure-button" href="/Timing">时间轴</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/tag">标签库</a>
                    </li>
                    <!--<li class="nav-item">
                        <a class="pure-button" href="/1">收藏站</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/1">音乐屋</a>-->

                </ul>
            </nav>
            <div class="search">
                <form action="/search">
                    <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                </form>
            </div>
            <div id="toc"></div>
            <nav id="nav">
                <ul class="nav-list">
                    <li class="nav-link">
                    <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <!--[if lt IE 8]>
        <i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
        <![endif]-->
        <div>
            <div class="posts">

                


    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/cat1/test.html">Sample2</a></h2>

            <p class="post-meta">By 11月28日  2014  



 
<a class="post-categorybut " href="/type/#cat1"><i class="fa fa-folder-open"></i> cat1 (1)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> tag1 (1)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> tag2 (1)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <h1>Sample2</h1>

<p>Sample2</p>

<pre><code class="clojure">
(println "Hello")
</code></pre>



            <a href="/cat1/test.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b%25e5%2591%25bd%25e5%2590%258d%25e7%25a9%25ba%25e9%2597%25b4-4.html">Clojure教程:命名空间</a></h2>

            <p class="post-meta">By 08月29日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {<br />
  margin: 0; padding: 0; vertical-align: baseline; border: none; }<br />
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }<br />
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }<br />
td.sourceCode { padding-left: 5px; }<br />
pre, code { background-color: #f8f8f8; }<br />
code > span.kw { color: #204a87; font-weight: bold; }<br />
code > span.dt { color: #204a87; }<br />
code > span.dv { color: #0000cf; }<br />
code > span.bn { color: #0000cf; }<br />
code > span.fl { color: #0000cf; }<br />
code > span.ch { color: #4e9a06; }<br />
code > span.st { color: #4e9a06; }<br />
code > span.co { color: #8f5902; font-style: italic; }<br />
code > span.ot { color: #8f5902; }<br />
code > span.al { color: #ef2929; }<br />
code > span.fu { color: #000000; }<br />
code > span.er { font-weight: bold; }<br />
  </style>
<style type="text/css">
code {<br />
background-color: #f7f7f9;<br />
border: none;<br />
padding: 2px 4px;<br />
padding: 0.125rem 0.25rem;<br />
}<br />
pre.sourceCode{<br />
border : 1px solid #e1e1e8;<br />
}<br />
</style>
<div class="container">
<div class="row">
<div id="side-navigation">
<div id="TOC" class="bs-sidebar hidden-print">
<ul>
<li><a href="#版本">版本</a></li>
<li><a href="#概述">概述</a></li>
<li><a href="#定义一个命名空间">定义一个命名空间</a>
<ul>
<li><a href="#require">:require</a>
<ul>
<li><a href="#refer选项">:refer选项</a></li>
</ul>
</li>
<li><a href="#import">:import</a></li>
<li><a href="#当前命名空间">当前命名空间</a></li>
<li><a href="#refer-clojure">:refer-clojure</a></li>
<li><a href="#use">:use</a></li>
<li><a href="#文档与元数据">文档与元数据</a></li>
</ul>
</li>
<li><a href="#如何在repl里使用其它命名空间的函数">如何在REPL里使用其它命名空间的函数</a></li>
<li><a href="#命名空间和编译">命名空间和编译</a></li>
<li><a href="#私有vars">私有Vars</a></li>
<li><a href="#常量vars">常量Vars</a></li>
<li><a href="#如何通过名称来查找和执行函数">如何通过名称来查找和执行函数</a></li>
<li><a href="#编译异常">编译异常</a>
<ul>
<li><a href="#classnotfoundexception">ClassNotFoundException</a></li>
<li><a href="#compilerexception-java.lang.runtimeexception-no-such-var">CompilerException java.lang.RuntimeException: No such var</a></li>
</ul>
</li>
</ul></div>
</p></div>
<div class="col-md-9">
<div id="content">
<h1 id="版本"><a href="#版本">版本</a></h1>
<p>本文翻译自<a href="http://clojure-doc.org/articles/language/namespaces.html">Clojure Namespaces and Vars</a> 本文涵盖如下内容: + Clojure命名空间和var概述 + 如何定义命名空间 + 如何使用其它命名空间里的函数 + require,refer和use + 常见错误和典型错误,以及导致这些错误的原因 + 命名空间和代码管理</p>
<p>版权:</p>
<p>This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<p>涵盖Clojure版本:Clojure 1.5</p>
<h1 id="概述"><a href="#概述">概述</a></h1>
<p>Clojure的函数通过命名空间来组织.Clojure命名空间和Java的包或者Python的模块很类似.命名空间实际上就是个map,将名字映射到了var上.在大部分情况下,这些var持有这些函数.</p>
<h1 id="定义一个命名空间"><a href="#定义一个命名空间">定义一个命名空间</a></h1>
<p>一般情况下使用clojure.core/ns宏来定义命名空间.最基本的形式下,它将名字作为符号.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> superlib.core)</code></pre>
<p>命名空间可以由点号切割的好多段组成</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.service.core)</code></pre>
<p>需要注意的是,请尽量避免使用单段的命名空间,以免与其它开发人员的命名空间相冲突.如果库或者应用属于某个组织,那么建议以如下形式作为命名空间.[组织名称].[包名|应用名].[函数组名] 例如</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> clojurewerkz.welle.kv)
          
          (<span class="kw">ns</span> megacorp.search.indexer.core)</code></pre>
<p>另外,ns宏可以包含如下形式: + (:require ...) + (:import ...) + (:use ...) + (:refer-clojure ...) + (:gen-class ...)</p>
<p>这些其实就是clojure.core/import,clojure.core/require等等这些的简写形式而已</p>
<h2 id="require"><a href="#require">:require</a></h2>
<p>:require形式可以使你的代码能访问其它命名空间的Clojure代码.例如</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> clojure.<span class="kw">set</span>))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (clojure.set/difference #{1 2 3} #{3 4 5})</span></code></pre>
<p>此代码将保证clojure.set命名空间被加载,编译并且可以通过clojure.set名来调用.当然可以给加载的命名空间取个别名:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:as</span> cs]))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (cs/difference #{1 2 3} #{3 4 5})</span></code></pre>
<p>一次导入两个命名空间的例子;</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span>  <span class="kw">:as</span> cs]
                      [clojure.<span class="kw">walk</span> <span class="kw">:as</span> <span class="kw">walk</span>]))</code></pre>
<h3 id="refer选项"><a href="#refer选项">:refer选项</a></h3>
<p>如果想在当前命名空间里通过简写名称来引用clojure.set空间里的函数,可以通过refer来实现:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">difference</span> <span class="kw">intersection</span>]]))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (difference #{1 2 3} #{3 4 5})</span></code></pre>
<p>:require形式中的:refer特性为Clojure1.4新增特性.</p>
<p>可能有时需要引入某个命名空间下所有的函数:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> <span class="kw">:all</span>]))
          
          <span class="co">;; Now it is possible to do:</span>
          <span class="co">;; (difference #{1 2 3} #{3 4 5})</span></code></pre>
<h2 id="import"><a href="#import">:import</a></h2>
<p>:import的作用是在当前命名空间引入Java类:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:import</span> java.util.concurrent.Executors))</code></pre>
<p>执行上面的代码后,java.util.concurrent.Executors类将会被引入,请可以直接通过名字Executors来使用.可以同时引入多个类.</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:import</span> java.util.concurrent.Executors
                     java.util.concurrent.TimeUnit
                     java.util.Date))</code></pre>
<p>如果引入的多个类在同一个包下面,就像上面那样,可以使用如下的简介方式:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:import</span> [java.util.concurrent Executors TimeUnit]
                     java.util.Date))</code></pre>
<p>虽然导入的list被叫做list,实际上可以使用任意的Clojure的集合(一般使用vector)</p>
<h2 id="当前命名空间"><a href="#当前命名空间">当前命名空间</a></h2>
<p>Clojure将通过*ns*来持有当前的命名空间.使用def形式定义的var被添加到了当前命名空间中.</p>
<h2 id="refer-clojure"><a href="#refer-clojure">:refer-clojure</a></h2>
<p>我们在使用像clojure.core/get这样的函数和clojure.core/defn这样的宏的时候我们不需要使用它的全限定名.这是因为Clojure默认将clojure.core下的内容全部加载进了当前命名空间里了.所以如果你定义了一个函数名和clojure.core里的重复了(比如find),你将会得到一个警告.</p>
<pre class="sh"><code>WARNING: find already refers to: #&#39;clojure.core/find in namespace:    megacorp.profitd.scheduling, being replaced by: #&#39;megacorp.profitd.scheduling/find</code></pre>
<p>这个警告的意思是在megacorp.profitd.scheduling这个命名空间里,已经有一个clojure.core/find了,但是现在它被你定义的函数覆盖了.请记住,Clojure是很动态的语言,命名空间就是map而已.</p>
<p>解决这个问题的办法有:你可以重命名你的函数或者不引入clojure.core里的这个函数</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:refer-clojure</span> <span class="kw">:exclude</span> [<span class="kw">find</span>]))
          
          (<span class="kw">defn</span><span class="fu"> find</span>
            <span class="st">&quot;Finds a needle in the haystack.&quot;</span>
            [^String haystack]
            (<span class="kw">comment</span> ...))</code></pre>
<p>在这里,如果你想使用clojure.core/find的话,你需要通过全限定名来使用:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling
            (<span class="kw">:refer-clojure</span> <span class="kw">:exclude</span> [<span class="kw">find</span>]))
          
          (<span class="kw">defn</span><span class="fu"> find</span>
            <span class="st">&quot;Finds a needle in the haystack.&quot;</span>
            [^String haystack]
            (clojure.core/find haystack <span class="kw">:needle</span>))</code></pre>
<h2 id="use"><a href="#use">:use</a></h2>
<p>Clojure在1.4之前,:require是不支持:refer的,只能使用:use</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling-test
            (<span class="kw">:use</span> clojure.<span class="kw">test</span>))</code></pre>
<p>在上面的例子中,clojure.test里的所有内容都被引入到了当前命名空间中.但是一般不会这样使用,建议是只引入需要的函数:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling-test
            (<span class="kw">:use</span> clojure.<span class="kw">test</span> <span class="kw">:only</span> [<span class="kw">deftest</span><span class="fu"> testing </span><span class="kw">is</span>]))</code></pre>
<p>1.4以前的做法</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.profitd.scheduling-test
            (<span class="kw">:require</span> clojure.<span class="kw">test</span> <span class="kw">:refer</span> [<span class="kw">deftest</span><span class="fu"> testing </span><span class="kw">is</span>]))</code></pre>
<p>而现在鼓励的做法是使用:require,通过:refer来进行限制.</p>
<h2 id="文档与元数据"><a href="#文档与元数据">文档与元数据</a></h2>
<p>命名空间可以包含说明文档.你可以在ns宏里添加:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> superlib.core
            <span class="st">&quot;Core functionality of Superlib.</span>
          
          <span class="st">   Other parts of Superlib depend on functions and macros in this namespace.&quot;</span>
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">union</span> <span class="kw">difference</span>]]))</code></pre>
<p>或者元数据</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> ^{<span class="kw">:doc</span> <span class="st">&quot;Core functionality of Superlib.</span>
          <span class="st">            Other parts of Superlib depend on functions and macros in this namespace.&quot;</span>
                <span class="kw">:author</span> <span class="st">&quot;Joe Smith&quot;</span>}
             superlib.core
            (<span class="kw">:require</span> [clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">union</span> <span class="kw">difference</span>]]))</code></pre>
<p>元数据可以包含任意的键,例如:author,很多工具可以使用(像Codox,Cadastre或者lein-clojuredocs)</p>
<h1 id="如何在repl里使用其它命名空间的函数"><a href="#如何在repl里使用其它命名空间的函数">如何在REPL里使用其它命名空间的函数</a></h1>
<p>ns宏是你经常需要使用的,它引入其它命名空间的函数.但是它在REPL里不太方便.这里可以直接使用require:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure"><span class="co">;; Will be available as clojure.set, e.g. clojure.set/difference.</span>
          (<span class="kw">require</span> &#39;clojure.<span class="kw">set</span>)
          
          <span class="co">;; Will be available as io, e.g. io/resource.</span>
          (<span class="kw">require</span> &#39;[clojure.java.io <span class="kw">:as</span> io])
          It takes a quoted libspec. The libspec <span class="kw">is</span> either a <span class="kw">namespace</span> <span class="kw">name</span> <span class="kw">or</span> a collection (typically a <span class="kw">vector</span>) of [<span class="kw">name</span> <span class="kw">:as</span> <span class="kw">alias</span>] <span class="kw">or</span> [<span class="kw">name</span> <span class="kw">:refer</span> [fns]]:
          
          (<span class="kw">require</span> &#39;[clojure.<span class="kw">set</span> <span class="kw">:refer</span> [<span class="kw">difference</span>]])
          
          (<span class="kw">difference</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>})  <span class="co">; ⇒ #{1 2}</span></code></pre>
<p>:as和:refer可以一起使用</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">require</span> &#39;[clojure.<span class="kw">set</span> <span class="kw">:as</span> cs <span class="kw">:refer</span> [<span class="kw">difference</span>]])
          
          (<span class="kw">difference</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>})  <span class="co">; ⇒ #{1 2}</span>
          (cs/union #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>})    <span class="co">; ⇒ #{1 2 3 4 5 6}</span></code></pre>
<p>clojure.core/use可以做和clojure.core/require一样的事情,但是不推荐使用了.</p>
<h1 id="命名空间和编译"><a href="#命名空间和编译">命名空间和编译</a></h1>
<p>Clojure是一个需要编译的语言:代码在被加载的时候进行编译.</p>
<p>命名空间可以包含var或者去继承协议,添加多重方法实现或载入其它库.所以为了完成编译,你需要引入需要的命名空间.</p>
<h1 id="私有vars"><a href="#私有vars">私有Vars</a></h1>
<p>Vars(包括defn宏定义的函数)可以设为私有的.有两种方法可以来做这件事情:使用元数据或者defn-宏</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.superlib)
          
          <span class="co">;;</span>
          <span class="co">;; Implementation</span>
          <span class="co">;;</span>
          
          (<span class="kw">def</span><span class="fu"> </span>^{<span class="kw">:private</span> true}
            source-name <span class="st">&quot;supersource&quot;</span>)
          
          (<span class="kw">defn-</span><span class="fu"> data-stream</span>
            [source]
            (<span class="kw">comment</span> ...))</code></pre>
<h1 id="常量vars"><a href="#常量vars">常量Vars</a></h1>
<p>Vars可以设为常量,通过:const元数据来设置.这将会促使Clojure编译器将其编译为常量:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">ns</span> megacorp.epicgame)
          
          <span class="co">;;</span>
          <span class="co">;; Implementation</span>
          <span class="co">;;</span>
          
          (<span class="kw">def</span><span class="fu"> </span>^{<span class="kw">:const</span> true}
            default-score <span class="dv">100</span>)</code></pre>
<h1 id="如何通过名称来查找和执行函数"><a href="#如何通过名称来查找和执行函数">如何通过名称来查找和执行函数</a></h1>
<p>可以通过clojure.core/resolve在制定的命名空间里通过名字查找函数.名字需要使用引号修饰.返回值可以直接当做函数使用,比如,当做参数传递给高阶函数:</p>
<pre class="sourceCode clojure"><code class="sourceCode clojure">(<span class="kw">resolve</span> &#39;clojure.<span class="kw">set</span> &#39;difference)  <span class="co">; ⇒ #&#39;clojure.set/difference</span>
          
          (<span class="kw">let</span> [f (<span class="kw">resolve</span> &#39;clojure.<span class="kw">set</span> &#39;difference)]
             (f #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>}))  <span class="co">; ⇒ #{1 2}</span></code></pre>
<h1 id="编译异常"><a href="#编译异常">编译异常</a></h1>
<p>本节讨论一些常见的编译错误.</p>
<h2 id="classnotfoundexception"><a href="#classnotfoundexception">ClassNotFoundException</a></h2>
<p>这个异常的意思是JVM无法加载类.可能是因为拼写错误,或者在classpath上没有这个类.可能是你的项目没有很好的处理依赖关系.</p>
<pre><code>user=&gt; (import java.uyil.concurrent.TimeUnit)
          ClassNotFoundException java.uyil.concurrent.TimeUnit  java.net.URLClassLoader$1.run (URLClassLoader.java:366)</code></pre>
<p>在上面的例子中,java.uyil.concurrent.TimeUnit拼写错误,应该是java.util.concurrent.TimeUnit</p>
<h2 id="compilerexception-java.lang.runtimeexception-no-such-var"><a href="#compilerexception-java.lang.runtimeexception-no-such-var">CompilerException java.lang.RuntimeException: No such var</a></h2>
<p>这个错误的意思是,使用了一个不存在的var.这可能是拼写错误,或者不正确的宏展开等类似问题.</p>
<pre><code>user=&gt; (clojure.java.io/resouce &quot;thought_leaders_quotes.csv&quot;)
          CompilerException java.lang.RuntimeException: No such var: clojure.java.io/resouce, compiling:(NO_SOURCE_PATH:1)</code></pre>
<p>在上面的例子中,clojure.java.io/resouce应该写成clojure.java.io/resource.NO_SOURCE_PATH的意思是编译是在repl里触发的,而不是一个Clojure源文件.</p>
</p></div>
</p></div>
</p></div>
</p></div>



            <a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b%25e5%2591%25bd%25e5%2590%258d%25e7%25a9%25ba%25e9%2597%25b4-4.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/%E5%BB%BA%E7%AB%99%E6%97%A5%E8%AE%B0/%25e5%259c%25a8github%25e9%2583%25a8%25e7%25bd%25b2octopress.html">在GitHub部署OctoPress</a></h2>

            <p class="post-meta">By 06月14日  2014  



 
<a class="post-categorybut " href="/type/#建站日记"><i class="fa fa-folder-open"></i> 建站日记 (7)</a>


  

  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 简介</a></li>
<li><a href="#sec-2">2. 环境</a></li>
<li><a href="#sec-3">3. 步骤</a>
<ul>
<li><a href="#sec-3-1">3.1. 安装ruby</a></li>
<li><a href="#sec-3-2">3.2. 安装Octopress</a></li>
<li><a href="#sec-3-3">3.3. 配置Octopress</a></li>
<li><a href="#sec-3-4">3.4. 初始化博客</a></li>
<li><a href="#sec-3-5">3.5. 安装第三方主题</a></li>
<li><a href="#sec-3-6">3.6. 部署博客到Github上</a></li>
<li><a href="#sec-3-7">3.7. 提交源码到source分支</a></li>
<li><a href="#sec-3-8">3.8. 写博客</a></li>
<li><a href="#sec-3-9">3.9. 添加多说评论</a></li>
<li><a href="#sec-3-10">3.10. 使用org-mode生成markdown</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 简介</h2>
<div class="outline-text-2" id="text-1">
<p>
本文记录本人使用Octopress,Github搭建博客的流程.具体方案都是从网上搜索<br />
得到.只记录操作流程,方便后续使用!<br />
浏览地址:<a href="http://ivanpig.github.io/">http://ivanpig.github.io/</a></p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 环境</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>Linux Mint 16
</li>
<li>ruby 1.9.3
</li>
<li>Octopress
</li>
<li>emacs
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 步骤</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 安装ruby</h3>
<div class="outline-text-3" id="text-3-1">
<p>
需要ruby版本1.9.3,执行如下命令,安装ruby1.9.3</p>
<div class="org-src-container">
<pre class="src src-sh">sudo apt-get install ruby1.9.3
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 安装Octopress</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<pre class="src src-sh">git clone git://github.com/imathis/octopress.git octopress  
<span style="color: #859900;">cd</span> octopress
gem install bundler
bundle install
rake install
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 配置Octopress</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>修改<sub>config</sub>.yml的url,title,subtitle,author,email等信息.其中url为在<br />
github创建的仓库地址我的就是:<a href="https://github.com/ivanpig/ivanpig.github.com">https://github.com/ivanpig/ivanpig.github.com</a>
</li>
<li>删除source/<sub>include</sub>/custom/head.html和source/<sub>include</sub>/head.html中的<br />
谷歌字体.否则大陆访问速度超慢
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 初始化博客</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Octopress生成的博客文件在<sub>deploy目录下</sub>,所以需要将此目录作为github仓库<br />
的master路径.执行如下命令:</p>
<div class="org-src-container">
<pre class="src src-sh">git clone https://github.com/ivanpig/ivanpig.github.com _deploy
<span style="color: #859900;">cd</span> _deploy
git checkout
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 安装第三方主题</h3>
<div class="outline-text-3" id="text-3-5">
<p>
第三方主题可以到这里下载:<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes</a><br />
我使用的是greyshade</p>
<div class="org-src-container">
<pre class="src src-sh">git clone  https://github.com/shashankmehta/greyshade.git .themes/greyshade
rake install[<span style="color: #2aa198;">'greyshade'</span>]
rake generate
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 部署博客到Github上</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>生成的文件发布到master上,源文件发布到source分支上
</li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">rake setup_github_pages
</pre>
</div>
<p>
上面的命令最主要的作用就是创建一个<sub>deploy目录，目录用来存放部署到master分支的内容。期间会要求你输入仓库的url，根据提示，进行输入即可。</sub></p>
<div class="org-src-container">
<pre class="src src-sh">rake generate  
rake deploy
</pre>
</div>
<p>
上面的命令进行部署.在deploy之前,你可以</p>
<div class="org-src-container">
<pre class="src src-sh">rake preview
</pre>
</div>
<p>
访问<a href="http://localhost:4000">http://localhost:4000</a> 进行预览</p>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> 提交源码到source分支</h3>
<div class="outline-text-3" id="text-3-7">
<div class="org-src-container">
<pre class="src src-sh">git add .  
git commit -m <span style="color: #2aa198;">'Initial source commit'</span>  
git push origin source
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> 写博客</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">
<pre class="src src-sh">rake new_post[<span style="color: #2aa198;">"title"</span>]
</pre>
</div>
<p>
其中title为博文的文件名，创建出来的文件默认是markdown格式。上面的命令会创建出这样一个文件：source/<sub>posts</sub>/2013-08-03-title.markdown。<br />
打开这个文件，可以看到里面有如下一些内容了(告诉Jekyll博客引擎如何处理博文和页面)：</p>
<div class="org-src-container">
<pre class="src src-md">---  
layout: post  
title: "title"  
date: 2014-06-15 16:36  
comments: true  
categories:   
---
</pre>
</div>
<p>
在此文件中编写markdown即可.<br />
整体流程如下:</p>
<div class="org-src-container">
<pre class="src src-sh">rake new_post[<span style="color: #2aa198;">"New Post"</span>]  
rake generate  
git add .  
git commit -am <span style="color: #2aa198;">"Some comment here."</span>   
git push origin source  
rake deploy
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> 添加多说评论</h3>
<div class="outline-text-3" id="text-3-9">
<p>
在<sub>config</sub>.yml中添加</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #93a1a1; font-style: italic;"># </span><span style="color: #93a1a1; font-style: italic;">duoshuo comments</span>
duoshuo_comments: true
duoshuo_short_name: yourname
</pre>
</div>
<p>
在 source/<sub>layouts</sub>/post.html 中的 disqus代码<br />
下方添加 多说评论 模块</p>
<div class="org-src-container">
<pre class="src src-html">
</pre>
</div>
<p>
然后就按路径创建一个 source/<sub>includes</sub>/post/duoshuo.html</p>
<div class="org-src-container">
<pre class="src src-html"><span style="color: #93a1a1; font-style: italic;">&lt;!-- </span><span style="color: #93a1a1; font-style: italic;">Duoshuo Comment BEGIN </span><span style="color: #93a1a1; font-style: italic;">--&gt;</span>
&lt;<span style="color: #268bd2;">div</span> <span style="color: #268bd2;">class</span>=<span style="color: #2aa198;">"ds-thread"</span> <span style="color: #268bd2;">data-title</span>=<span style="color: #2aa198;">""</span>&gt;&lt;/<span style="color: #268bd2;">div</span>&gt;
&lt;<span style="color: #268bd2;">script</span> <span style="color: #268bd2;">type</span>=<span style="color: #2aa198;">"text/javascript"</span>&gt;
  var duoshuoQuery = {short_name:<span style="color: #2aa198;">""</span>};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
&lt;/<span style="color: #268bd2;">script</span>&gt;
<span style="color: #93a1a1; font-style: italic;">&lt;!-- </span><span style="color: #93a1a1; font-style: italic;">Duoshuo Comment END </span><span style="color: #93a1a1; font-style: italic;">--&gt;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10"><span class="section-number-3">3.10</span> 使用org-mode生成markdown</h3>
<div class="outline-text-3" id="text-3-10">
<p>
本人习惯使用emacs的org-mode来写文档.org-mode可以直接生成markdown文件.只<br />
需要执行M-X org-md-export-to-md 即可<br />
本文即使用org-mode编写.</p>
</div>
</div>
</div>



            <a href="/%E5%BB%BA%E7%AB%99%E6%97%A5%E8%AE%B0/%25e5%259c%25a8github%25e9%2583%25a8%25e7%25bd%25b2octopress.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e8%25bf%259b%25e9%2598%25b6%25e4%25bd%25bf%25e7%2594%25a8clojure%25e7%25bc%2596%25e5%2586%2599%25e6%2596%2587%25e5%25ad%2597%25e5%2586%2592%25e9%2599%25a9%25e6%25b8%25b8%25e6%2588%258f.html">Clojure进阶:使用Clojure编写文字冒险游戏</a></h2>

            <p class="post-meta">By 05月16日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  

  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 准备</a></li>
<li><a href="#sec-2">2. 语法和语义</a></li>
<li><a href="#sec-3">3. 为我们的游戏世界定义数据</a></li>
<li><a href="#sec-4">4. 环顾我们的游戏世界</a></li>
<li><a href="#sec-5">5. 函数式编码风格</a></li>
<li><a href="#sec-6">6. 环游我们的游戏世界</a></li>
<li><a href="#sec-7">7. 构建SPELs</a></li>
<li><a href="#sec-8">8. 创建特殊操作</a></li>
<li><a href="#sec-9">9. 附录</a></li>
<li><a href="#sec-10">10. 为什么没有使用"宏"这个词</a></li>
<li><a href="#sec-11">11. 译者感想</a></li>
</ul>
</div>
</div>
<p>
本文翻译自:<a href="http://www.lisperati.com/clojure-spels/casting.html">Casting SPELs in Clojure</a><br />
<img src="assets/wpid-cs_016.jpg" alt="cs_01.jpg" /></p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 准备</h2>
<div class="outline-text-2" id="text-1">
<p>
任何学过Lisp的人都会说List和其它语言有很大的不同.它有很多不可思议的地<br />
方.本文将告诉你它有哪些独特之处!<br />
本文适用于Clojure,它是一个运行在JVM上的Lisp方言.Clojure的API和语法和<br />
Common Lisp很类似,但是还是有足够多的区别,需要单独为其写个教程.<br />
在大部分情况下,我们会说Lisp而不是Clojure,因为大部分的概念在Lisp中是通<br />
用的.我们会指出Clojure特有的内容.<br />
<img src="assets/wpid-cs_026.jpg" alt="cs_02.jpg" /><br />
Clojure是运行在JVM之上的,所以你需要先安装JVM.如果你是MAC机,那么Java已<br />
经被安装过了.如果是Linux或者Windows系统,你需要到<a href="http://java.sun.com/javase/downloads/index.jsp">Oracle Java官网</a>下载对<br />
应版本的Java.而Clojure,你可以从它的<a href="http://clojure.org/">官网</a>获得最新版本.<br />
下载完成后,你只需要解压缩,打开命令行,切换到解压缩目录,输入:</p>
<div class="org-src-container">
<pre class="src src-sh">java -jar clojure.jar
</pre>
</div>
<p>
如果没有问题,那么你将会看到Clojure输出提示</p>
<div class="org-src-container">
<pre class="src src-sh">Clojure 1.6.0
<span style="color: #268bd2;">user</span>=&gt;
</pre>
</div>
<p>
教程中有很多Clojure代码片段,类似下面的样子:</p>
<div class="org-src-container">
<pre class="src src-clojure">'<span style="color: #8c8c8c;">(</span>these kinds of boxes<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
你只需要将这些代码片段拷贝到Clojure REPL中运行就可以了!当你学习完此教<br />
程,你将会有一个你自己的文字冒险游戏了!</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 语法和语义</h2>
<div class="outline-text-2" id="text-2">
<p>
每一个编程语言是由语法和语义组成的.语法是组成你的程序的骨架,你必须要<br />
遵循它们,这样编译器才能知道你的程序里什么是什么,比如说什么是函数,什么<br />
是变量,等等!而语义是个比较"随便"的东西,例如你的程序里有哪些不同的命令,<br />
或者在程序的哪个部分能访问到哪些变量!这里Lisp比较特别的地方就是,Lisp的<br />
语法笔其它任何语言都要简单.</p>
<p>
首先,Lisp语法规定,所有传递给Lisp编译器的文本需要是个list,当然这个list<br />
可以无限嵌套.每个list都必须使用括号包裹.<br />
<img src="assets/wpid-cs_036.jpg" alt="cs_03.jpg" /></p>
<p>
另外,Lisp编译器使用两种模式来读取你的代码:代码模式和数据模式.当你在数<br />
据模式下,你可以将任何东西塞到你的list中.但是在代码模式下,你的list需要<br />
是叫做form的特殊类型.<br />
<img src="assets/wpid-cs_046.jpg" alt="cs_04.jpg" /></p>
<p>
form也是个list,不过它的第一个符号被lisp编译器特殊对待了&#x2014;一般被当做函<br />
数的名字.在这种情况下,编译器会将list中的其它元素作为函数参数传递给这个<br />
函数.默认情况下,编译器运行在代码模式下,除非你特意告诉它进入数据模式.</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 为我们的游戏世界定义数据</h2>
<div class="outline-text-2" id="text-3">
<p>
为了进一步的学习form,让我们来创建一些form,来定义我们游戏世界里的数据.首<br />
先,我们的游戏有一些对象,玩家可以使用他们&#x2013;让我们来定义吧:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">objects</span> '<span style="color: #8c8c8c;">(</span>whiskey-bottle bucket frog chain<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
让我们来看看这行代码是什么意思:Lisp编译器总是使用代码模式来读取内容,所<br />
以第一个符号(这里是def),肯定是个命令.在这里,它的作用就是给某个变量设<br />
值:这里变量就是objects,而值是一个包含四个对象的list.这个list是数据(我<br />
们可不想编译器去调用一个叫做whiskey-bottle的函数),所以在读取这个list时<br />
我们需要将其设值为数据模式.在list前面的哪个单引号就是干这个的:<br />
<img src="assets/wpid-cs_056.jpg" alt="cs_05.jpg" /><br />
def命令就是用来设值的(如果你学过Common Lisp,你应该会知道它和Common<br />
Lisp中的setf命令等价,但是Clojure中没有setf命令)<br />
现在我们在游戏里定义了一些对象,现在让我们来定义一下游戏地图.下面是我们<br />
的游戏世界:<br />
<img src="assets/wpid-cs_066.jpg" alt="cs_06.jpg" /><br />
在这个简单的游戏里,只有三个地点:一个房子,它包含起居室,阁楼和花园.让我<br />
们来定义一个新变量,叫做game-map来描述这个游戏地图:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">game-map</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">hash-map</span>
   'living-room '<span style="color: #8c8c8c;">((</span>you are in the living room
                   of a wizards house - there is a wizard
                   snoring loudly on the couch -<span style="color: #8c8c8c;">)</span>
                  <span style="color: #8c8c8c;">(</span>west door garden<span style="color: #8c8c8c;">)</span>
                  <span style="color: #8c8c8c;">(</span>upstairs stairway attic<span style="color: #8c8c8c;">))</span>
   'garden '<span style="color: #8c8c8c;">((</span>you are in a beautiful garden -
              there is a well in front of you -<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span>east door living-room<span style="color: #8c8c8c;">))</span>
   'attic '<span style="color: #8c8c8c;">((</span>you are in the attic of the
             wizards house - there is a giant
             welding torch in the corner -<span style="color: #8c8c8c;">)</span>
            <span style="color: #8c8c8c;">(</span>downstairs stairway living-room<span style="color: #8c8c8c;">))))</span>
</pre>
</div>
<p>
这个map包含了三个地点的所有重要信息:每个地点都有个独立的名字,一个简短<br />
的描述,描述了我们能在这些地点看到什么,以及如何进入此处或从此处出去.请<br />
注意这个包含了丰富信息的变量是如何定义的&#x2014;Lisp程序员更喜欢用小巧的代<br />
码片段而不是一大片代码,因为小代码更容易理解.</p>
<p>
现在我们有了一个地图和一组对象,让我们来创建另一个变量,来描述这些对象在<br />
地图的哪些地方.</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">object-locations</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">hash-map</span>
                       'whiskey-bottle 'living-room
                       'bucket 'living-room
                       'chain 'garden
                       'frog 'garden<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
这里我们将每个对象和地点进行了关联.Clojure提供了Map这个数据结构.Map使<br />
用hash-map函数来创建,它需要一组参数类似(key1 value1 keys value2&#x2026;).我<br />
们的game-map变量也是个Map&#x2014;三个key分别是living-room,garden和attic.</p>
<p>
我们定义了游戏世界,以及游戏世界中的对象,现在就剩下一件事了,就是描述玩<br />
家的地点!</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">location</span> 'living-room<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
搞定,现在让我们来定义游戏操作吧!<br />
<img src="assets/wpid-cs_076.jpg" alt="cs_07.jpg" /></p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 环顾我们的游戏世界</h2>
<div class="outline-text-2" id="text-4">
<p>
我们想要的第一个命令能够告诉我们该地点的描述.那么我们该怎么定义这个函<br />
数呢?它要知道我们想要描述的地点以及能够从map中查找地点的描述.如下:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">describe-location</span> [location game-map]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> <span style="color: #8c8c8c;">(</span>location game-map<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
defn定义了一个函数.函数的名字叫做describe-location,它需要两个参数:地点<br />
和游戏地图.这两个变量在函数定义的括号内,所以它们是局部变量,因此对于全<br />
局的location和game-map没有关系.注意到了吗?Lisp中的函数与其它语言中的函<br />
数定义相比,更像是数学中的函数:它不打印信息或者弹出消息框:它所作的就是<br />
返回结果.我们假设现在我们在起居室里!<br />
<img src="assets/wpid-cs_086.jpg" alt="cs_08.jpg" /><br />
为了能找到起居室的描述,describe-locatin函数首先需要从地图中找到起居<br />
室.(location game-map)就是进行从game-map中查找内容的,并返回起居室的描<br />
述.然后first命令来处理返回值,取得返回的list的第一个元素,这个就是起居室<br />
的描述了.<br />
现在我们来测试一下</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>describe-location 'living-room game-map<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (describe-location 'living-room game-map)
(you are in the living-room of a wizard's house -
there is a wizard snoring loudly on the couch -)
</pre>
<p>
很完美!这就是我们要的结果!请注意我们在living-room前添加了一个单引号,因<br />
为这个符号是地点map的一个名称!但是,为什么我们没有在game-map前面添加单<br />
引号呢?这是因为我们需要编译器去查询这个符号所指向的数据(就是那个map)</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 函数式编码风格</h2>
<div class="outline-text-2" id="text-5">
<p>
你可能已经发现了describe-location函数有几个让人不太舒服的地方.第一,为<br />
什么要传递位置和map参数,而不是直接使用已经定义的全局变量?原因是Lisp程<br />
序员喜欢写函数式风格的代码.函数式风格的代码,主要遵循下面三条规则:</p>
<ul class="org-ul">
<li>只读取函数传递的参数或在函数内创建的变量
</li>
<li>不改变已经被设值的变量的值
</li>
<li>除了返回值,不去影响函数外的任何内容
</li>
</ul>
<p>
你也许会怀疑在这种限制下你还能写代码吗?答案是:可以!为什么很多人对这些<br />
规则感到疑惑呢?一个很重要的原因是:遵循此种风格的代码更加的引用透明<br />
(referential transparency):这意味着,对于给定的代码,你传入相同的参数,永<br />
远返回相同的结果&#x2014;这能减少程序的错误,也能提高程序的生产力!</p>
<p>
当然了,你也会有一些非函数式风格的代码,因为不这么做,你无法和其它用户或<br />
外部内容进行交互.教程后面会有这些函数,他们不遵循上面的规则.</p>
<p>
describe-location函数的另一个问题是,它没告诉我们怎么进入一个位置或者怎<br />
么从某个位置出来.让我们来编写这样的函数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">describe-path</span> [path]
  `<span style="color: #8c8c8c;">(</span>there is a ~<span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> path<span style="color: #8c8c8c;">)</span> going ~<span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> path<span style="color: #8c8c8c;">)</span> from here -<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
这个函数看起来很明了:它看起来更像是数据而不是函数.我们先来尝试调用它,看<br />
它做了些什么:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>describe-path '<span style="color: #8c8c8c;">(</span>west door garden<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<pre class="example">
user=&gt; (describe-path '(west door garden))
(user/there user/is user/a door user/going west user/from user/here clojure.core/-)
</pre>
<p>
这是什么?!结果看起来很乱,包含了很多的/和一些其它的文字!这是因为Clojure<br />
会将命名空间的名字添加到表达式的前面.我们这里不深究细节,只给你提供消除<br />
这些内容的函数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">spel-print</span> [list] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">symbol</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">name</span> x<span style="color: #8c8c8c;">)))</span> list<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
修改调用方式</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>spel-print <span style="color: #8c8c8c;">(</span>describe-path '<span style="color: #8c8c8c;">(</span>west door garden<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<pre class="example">
user=&gt; (spel-print (describe-path '(west door garden)))
(there is a door going west from here -)
</pre>
<p>
现在结果很清晰了:这个函数接收一个描述路径的list然后将其解析到一个句子<br />
里面.我们回过头来看这个函数,这个函数和它产生的数据非常的像:它就是拼接<br />
第一个和第二个list的元素到语句中!它是怎么做到的?使用语法quote!</p>
<p>
还记得我们使用quote来从代码模式切换到数据模式吗?语法quote的功能类似,但<br />
是还不只这样.在语法quote里,我们还能使用'~'再次从数据模式切换回代码模式.<br />
<img src="assets/wpid-cs_096.png" alt="cs_09.png" /><br />
语法quote是List的一个很强大的功能!它能使我们的代码看起来像它创建的数据.这<br />
在函数式编码中很常见:创建这种样子的函数,使得我们的代码更易读也更稳健:<br />
只要数据不变,函数就不需要修改.想象一下,你能否在VB或C中编写类似的代码?<br />
你可能需要将文字切成小块,然后在一点点的组装-这和数据本身看起来差距很大,更<br />
别说代码的稳健性了!</p>
<p>
现在我们能描述一个路径,但是一个地点可能会有多个路径,所以让我们来创建一<br />
个函数叫做describe-paths:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">describe-paths</span> [location game-map]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> concat <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> describe-path <span style="color: #8c8c8c;">(</span><span style="color: #859900;">rest</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> game-map location<span style="color: #8c8c8c;">)))))</span>
</pre>
</div>
<p>
这个函数使用了另一个在函数式编程中很常用的技术:高阶函数.apply和map这两<br />
个函数能将其它的函数作为参数.map函数将另一个函数分别作用到list中的每个<br />
对象上,这里是调用describe-path函数.apply concat是为了减少多余的括号,没<br />
有多少功能性操作!我们来试试新函数</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>spel-print <span style="color: #8c8c8c;">(</span>describe-paths 'living-room game-map<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<pre class="example">
user=&gt; (spel-print (describe-paths 'living-room game-map))
(there is a door going west from here -
there is a stairway going upstairs from here -)
</pre>
<p>
漂亮!<br />
最后,我们还剩下一件事要做:描述某个地点的某个对象!我们先写个帮助函数来<br />
告诉我们在某个地方是否有某个对象!</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">is-at?</span> [obj loc obj-loc] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span>obj obj-loc<span style="color: #8c8c8c;">)</span> loc<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
=也是个函数,它判断对象的地点是否和当前地点相同!<br />
<img src="assets/wpid-cs_096.jpg" alt="cs_09.jpg" /><br />
我们来尝试一下:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>is-at? 'whiskey-bottle 'living-room object-locations<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (is-at? 'whiskey-bottle 'living-room object-locations)
true
</pre>
<p>
返回结果是true,意味着whiskey-bottle在起居室.</p>
<p>
现在让我们来使用这个函数描述地板:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">describe-floor</span> [loc objs obj-loc]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> concat <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x]
                       `<span style="color: #8c8c8c;">(</span>you see a ~x on the floor -<span style="color: #8c8c8c;">))</span>
                     <span style="color: #8c8c8c;">(</span><span style="color: #859900;">filter</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x] 
                               <span style="color: #8c8c8c;">(</span>is-at? x loc obj-loc<span style="color: #8c8c8c;">))</span> objs<span style="color: #8c8c8c;">))))</span>
</pre>
</div>
<p>
这个函数包含了很多新事物:首先,它有匿名函数(fn定义的函数).第一个fn干的<br />
事,和下面的函数做的事情是一样的:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">blabla</span> [x] `<span style="color: #8c8c8c;">(</span>you see a ~x on the floor.<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
然后将这个blabla函数传递给map函数.filter函数是过滤掉那些在当前位置没有<br />
出现的物体.我们来试一下新函数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>spel-print <span style="color: #8c8c8c;">(</span>describe-floor 'living-room objects object-locations<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<pre class="example">
user=&gt; (spel-print (describe-floor 'living-room objects object-locations))
(you see a whiskey-bottle on the floor - you see a bucket on the floor -)
</pre>
<p>
现在,让我们来将这些函数串联起来,定义一个叫look的函数,使用全局变量(这个<br />
函数就不是函数式的了!)来描述所有的内容:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">look</span> []
  <span style="color: #8c8c8c;">(</span>spel-print <span style="color: #8c8c8c;">(</span><span style="color: #859900;">concat</span> <span style="color: #8c8c8c;">(</span>describe-location location game-map<span style="color: #8c8c8c;">)</span>
          <span style="color: #8c8c8c;">(</span>describe-paths location game-map<span style="color: #8c8c8c;">)</span>
          <span style="color: #8c8c8c;">(</span>describe-floor location objects object-locations<span style="color: #8c8c8c;">))))</span>
</pre>
</div>
<p>
<img src="assets/wpid-cs_106.jpg" alt="cs_10.jpg" /><br />
我们来试一下:</p>
<pre class="example">
user=&gt; (look)
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)
</pre>
<p>
很酷吧!</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 环游我们的游戏世界</h2>
<div class="outline-text-2" id="text-6">
<p>
好了,现在我们能看我们的世界了,让我们来写一些代码来环游我们的世<br />
界.walk-direction包含了一些方向可以使我们走到那里:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">walk-direction</span> [direction]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [next <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">filter</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> direction <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> x<span style="color: #8c8c8c;">)))</span>
                            <span style="color: #8c8c8c;">(</span><span style="color: #859900;">rest</span> <span style="color: #8c8c8c;">(</span>location game-map<span style="color: #8c8c8c;">))))</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> next <span style="color: #8c8c8c;">(</span><span style="color: #859900;">do</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">location</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">nth</span> next 2<span style="color: #8c8c8c;">))</span> <span style="color: #8c8c8c;">(</span>look<span style="color: #8c8c8c;">))</span>
          <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>you cannot go that way -<span style="color: #8c8c8c;">))))</span>
</pre>
</div>
<p>
这里的let用来创建局部变量next,用来描述玩家的方向.rest返回一个list,包含<br />
原list中除了第一个元素外的全部元素.如果用户输入了错误的方向,next会返回<br />
().cond类似于if-then条件:每个cond都包含一个值,lisp检查该值是否为真,如<br />
果为真则执行其后的动作.在这里,如果下一个位置不是nil,则会定义玩家的<br />
location到新位置,然后告诉玩家该位置的描述!如果next是nil,则告诉玩家,无<br />
法到达,请重试:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>walk-direction 'west<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (walk-direction 'west)
(you are in a beautiful garden -
there is a well in front of you -
there is a door going east from here -
you see a frog on the floor -
you see a chain on the floor -)
</pre>
<p>
现在,我们通过创建look函数来简化描述.walk-direction也是类似的功能.但是<br />
它需要输入方向,而且还有个quote.我们能否告诉编译器west仅仅是个数据,而不是<br />
代码呢?</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 构建SPELs</h2>
<div class="outline-text-2" id="text-7">
<p>
现在我们开始学习Lisp中一个很强大的功能:创建SPELs!<br />
SPEL是"语义增强逻辑"的简称,它能够从语言级别,按照我们的需求定制,对我们的代码添加新的行为-这<br />
是Lisp最为强大的一部分.为了开启SPELs,我们需要先激活Lisp编译器的SPEL</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmacro</span> <span style="color: #268bd2;">defspel</span> [&amp; rest] `<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmacro</span> <span style="color: #268bd2;">~@rest</span><span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
现在,我们来编写我们的SPEL,叫做walk:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defspel</span> <span style="color: #268bd2;">walk</span> [direction] `<span style="color: #8c8c8c;">(</span>walk-direction '~direction<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
这段代码干了什么?它告诉编译器walk不是实际的名称,实际的名字叫<br />
walk-direction,并且direction前面有个quote.SPEL的主要功能就是能在我们的<br />
代码被编译器编译之前插入一些内容!<br />
<img src="assets/wpid-cs_116.jpg" alt="cs_11.jpg" /><br />
注意到了吗?这段代码和我们之前写的describe-path很类似:在Lisp中,不只是代<br />
码和数据看起来很像,代码和特殊形式对于编译器来说也是一样的-高度的统一带<br />
来简明的设计!我们来试试新代码:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #b58900;">walk</span> east<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (walk east)                                             
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)
</pre>
<p>
感觉好多了!<br />
现在我们来创建一个命令来收集游戏里的物品</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">pickup-object</span> [object]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> <span style="color: #8c8c8c;">(</span>is-at? object location object-locations<span style="color: #8c8c8c;">)</span>
        <span style="color: #8c8c8c;">(</span><span style="color: #859900;">do</span>
          <span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">object-locations</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">assoc</span> object-locations object 'body<span style="color: #8c8c8c;">))</span>
          `<span style="color: #8c8c8c;">(</span>you are now carrying the ~object<span style="color: #8c8c8c;">))</span>
        <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>you cannot get that.<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
这个函数检查物品是否在当前地点的地上-如果在,则将它放到list里面,并返回<br />
成功提示!否则提示失败!<br />
现在我们来创建另一个SPEL来简化这条命令:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defspel</span> <span style="color: #268bd2;">pickup</span> [object] `<span style="color: #8c8c8c;">(</span>spel-print <span style="color: #8c8c8c;">(</span>pickup-object '~object<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
调用</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>pickup whiskey-bottle<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (pickup whiskey-bottle)
(you are now carrying the whiskey-bottle)
</pre>
<p>
现在我们来添加更多有用的命令-首先,一个能让我们查看我们捡到的物品的函<br />
数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">inventory</span> []
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">filter</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x] <span style="color: #8c8c8c;">(</span>is-at? x 'body object-locations<span style="color: #8c8c8c;">))</span> objects<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
以及一个检查我们是否有某个物品的函数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">have?</span> [object]
   <span style="color: #8c8c8c;">(</span><span style="color: #859900;">some</span> #{object} <span style="color: #8c8c8c;">(</span>inventory<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 创建特殊操作</h2>
<div class="outline-text-2" id="text-8">
<p>
现在我们只剩下一件事情需要做了:添加一些特殊动作,使得玩家能够赢得游戏.第<br />
一条命令是让玩家在阁楼里给水桶焊接链条.</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">chain-welded</span> false<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">weld</span> [subject object]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">and</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> location 'attic<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> subject 'chain<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> object 'bucket<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span>have? 'chain<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span>have? 'bucket<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">not</span> chain-welded<span style="color: #8c8c8c;">))</span>
        <span style="color: #8c8c8c;">(</span><span style="color: #859900;">do</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">chain-welded</span> true<span style="color: #8c8c8c;">)</span>
            '<span style="color: #8c8c8c;">(</span>the chain is now securely welded to the bucket -<span style="color: #8c8c8c;">))</span>
        <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>you cannot weld like that -<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
首先我们创建了一个新的全局变量来进行判断,我们是否进行了此操作.然后我们<br />
创建了一个weld函数,来确认此操作的条件是否完成,如果已完成则进行此操作.<br />
<img src="assets/wpid-cs_126.jpg" alt="cs_12.jpg" /><br />
来试一下:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>weld 'chain 'bucket<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (weld 'chain 'bucket)
(you cannot weld like that -)
</pre>
<p>
Oops&#x2026;我们没有水桶,也没有链条,是吧?周围也没有焊接的机器!<br />
现在,让我们创建一条命令来将链条和水桶放到井里:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">bucket-filled</span> false<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">dunk</span> [subject object]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">and</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> location 'garden<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> subject 'bucket<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> object 'well<span style="color: #8c8c8c;">)</span>
             <span style="color: #8c8c8c;">(</span>have? 'bucket<span style="color: #8c8c8c;">)</span>
             chain-welded<span style="color: #8c8c8c;">)</span>
        <span style="color: #8c8c8c;">(</span><span style="color: #859900;">do</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">bucket-filled</span> true<span style="color: #8c8c8c;">)</span>
            '<span style="color: #8c8c8c;">(</span>the bucket is now full of water<span style="color: #8c8c8c;">))</span>
        <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>you cannot dunk like that -<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
注意到了吗?这个命令和weld命令看起来好像!两条命令都需要检查位置,物体和<br />
对象!但是它们还是有不同,以至于我们不能将它们抽到一个函数里.太可惜了!<br />
但是&#x2026;这可是Lisp.我们不止能写函数,还能写SPEL!我们来创建了SPEL来处理:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defspel</span> <span style="color: #268bd2;">game-action</span> [command subj obj place &amp; args]
  `<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defspel</span> <span style="color: #268bd2;">~command</span> [subject# object#]
     `<span style="color: #8c8c8c;">(</span>spel-print <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">and</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> location '~'~place<span style="color: #8c8c8c;">)</span>
                             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> '~subject# '~'~subj<span style="color: #8c8c8c;">)</span>
                             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> '~object# '~'~obj<span style="color: #8c8c8c;">)</span>
                             <span style="color: #8c8c8c;">(</span>have? '~'~subj<span style="color: #8c8c8c;">))</span>
                        ~@'~args
                        <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>i cannot ~'~command like that -<span style="color: #8c8c8c;">)))))</span>
</pre>
</div>
<p>
非常复杂的SPEL!它有很多怪异的quote,语法quote,逗号以及很多怪异的符号!更<br />
重要的是他是一个构建SPEL的SPEL!!即使是很有经验的Lisp程序员,也需要费下<br />
脑细胞才能写出这么个玩样!!(这里我们不管)<br />
<img src="assets/wpid-cs_135.jpg" alt="cs_13.jpg" /><br />
这个SPEL的只是向你展示,你是否够聪明来理解这么复杂的SPEL.而且,即使这段<br />
代码很丑陋,如果它只需要写依次,并且能生成几百个命令,那么也是可以接受的!<br />
让我们使用这个新的SPEL来替换我们的weld命令:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>game-action weld chain bucket attic
   <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">and</span> <span style="color: #8c8c8c;">(</span>have? 'bucket<span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">chain-welded</span> true<span style="color: #8c8c8c;">))</span>
              '<span style="color: #8c8c8c;">(</span>the chain is now securely welded to the bucket -<span style="color: #8c8c8c;">)</span>
         <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>you do not have a bucket -<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
现在我们来看看这条命令变得多容易理解- game-action这个SPEL使得我们能编<br />
写我们想要的核心代码,而不需要额外的信息.这就像我们创建了我们自己的专门<br />
创建游戏命令的编程语言.使用SPEL创建伪语言称为领域特定语言编程(DSL),它<br />
使得你的编码更加的快捷优美!</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>weld chain bucket<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<pre class="example">
user=&gt; (weld chain bucket)
(you do not have a chain -)
</pre>
<p>
&#x2026;我们还没有做好焊接前的准备工作,但是这条命令生效了!<br />
<img src="assets/wpid-cs_144.jpg" alt="cs_14.jpg" /><br />
下面我们重写dunk命令:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>game-action dunk bucket well garden
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> chain-welded 
                   <span style="color: #8c8c8c;">(</span><span style="color: #859900;">do</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">bucket-filled</span> true<span style="color: #8c8c8c;">)</span>
                       '<span style="color: #8c8c8c;">(</span>the bucket is now full of water<span style="color: #8c8c8c;">))</span>
                   <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>the water level is too low to reach -<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
注意weld命令需要检验我们是否有物体,但是dunk不需要.我们的game-action这<br />
个SPEL使得这段代码易写易读.<br />
<img src="assets/wpid-cs_153.jpg" alt="cs_15.jpg" /><br />
最后,就是将水泼到巫师身上:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>game-action splash bucket wizard living-room
             <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">not</span> bucket-filled<span style="color: #8c8c8c;">)</span> '<span style="color: #8c8c8c;">(</span>the bucket has nothing in it -<span style="color: #8c8c8c;">)</span>
                   <span style="color: #8c8c8c;">(</span>have? 'frog<span style="color: #8c8c8c;">)</span> '<span style="color: #8c8c8c;">(</span>the wizard awakens and sees that you stole
                                       his frog -
                                       he is so upset he banishes you to the
                                       netherworlds - you lose! the end -<span style="color: #8c8c8c;">)</span>
                   <span style="color: #2aa198;">:else</span> '<span style="color: #8c8c8c;">(</span>the wizard awakens from his slumber and greets you
                               warmly -
                               he hands you the magic low-carb donut - you win!
                               the end -<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
<img src="assets/wpid-cs_162.jpg" alt="cs_16.jpg" /><br />
现在你已经编写完成了一个文字冒险游戏了!<br />
点击<a href="http://www.lisperati.com/clojure-spels/cheat.html">这里</a>是完整的游戏.<br />
点击<a href="http://www.lisperati.com/clojure-spels/code.html">这里</a>是代码.<br />
为了使教程尽可能的简单,很多Lisp的执行细节被忽略了,所以最后,让我们来看<br />
看这些细节!</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 附录</h2>
<div class="outline-text-2" id="text-9">
<p>
现在,我们来聊一聊被忽略的细节!<br />
首先,Clojure有一套很成熟的定义变量以及改变变量值的系统.在此教程中,我们<br />
只使用了def来设置和改变全局变量的值.而在真正的Clojure代码里,你不会这么<br />
做.取而代之,你会使用<a href="http://clojure.org/refs">Refs</a>,<a href="http://clojure.org/atoms">Atoms和</a><a href="http://clojure.org/agents">Agents</a>,它们提供了更清晰,以及线程安全的<br />
方式来管理数据.</p>
<p>
另一个问题就是我们在代码中大量使用了符号(symbol)</p>
<div class="org-src-container">
<pre class="src src-clojure">'<span style="color: #8c8c8c;">(</span>this is not how <span style="color: #cb4b16;">Lispers</span> usually write text<span style="color: #8c8c8c;">)</span>
<span style="color: #2aa198;">"Lispers write text using double quotes"</span>
</pre>
</div>
<p>
符号在Clojure有特殊含义,主要是用来持有函数,变量或其它内容的.所以,在<br />
Lisp中将符号作为文本信息描述是很奇怪的事情!使用字符串来显示文本信息可<br />
以避免这样的尴尬!不过,使用字符串的话,在教程里就没法讲很多关于符号的内<br />
容了!</p>
<p>
还有就是SPEL在Lisp里面更普遍的叫法是"宏",使用defmacro来定义,但是这个名<br />
字不易于教学,所以没有提及.你可以阅读<a href="http://www.lisperati.com/clojure-spels/no_macros.html">此文</a>,这是我为什么没有使用"宏"这个<br />
名字的原因.最后,在编写类似game-action这样的SPEL的时候,很可能会发生命名<br />
重复的问题.当你编写了足够多的lisp的时候,你会越来越能体会到这个问题了.</p>
<p>
Q. 后面我该阅读哪些内容来扩充我的Lisp知识?<br />
A. 在<a href="http://www.cliki.net/Lisp%2520books">cliki网站</a>有很多Lisp书籍可以下载.</p>
<p>
如果你对于理论上的内容很感兴趣,那么我推荐Paul Graham的<br />
<a href="http://www.paulgraham.com/onlisp.html">On Lisp</a>电子书,它是免费的.他网站上的一些短文也很精彩.<br />
如果你对实际应用比较感兴趣,那么大多数Lisp程序员对Perter Seibel编写的"Practical Common<br />
Lisp"这本书推崇有加,你可以从<a href="http://www.gigamonkeys.com/book/">这里</a>获得</p>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 为什么没有使用"宏"这个词</h2>
<div class="outline-text-2" id="text-10">
<p>
编写这个教程的一个意图是使用宏来解决真实的难题.而经常的,当我向没有Lisp<br />
经验的人解释宏这个概念的时候,我得到的答复往往是,"哦!C++里也有宏".当发<br />
生这种事情的时候,我就很难去解释宏的概念了.的确,Lisp中的宏和C++中的宏的<br />
确有几分相似,它们都是为了能通过编译器来改进代码的编写&#x2026;</p>
<p>
&#x2026;所以,假设一下,如果John McCarthy使用了"add"而不是"cons"这个词来将元<br />
素添加到list中:我就真的很难解释cons是如何工作的了!</p>
<p>
所以,我决定在此文中使用一个新的词汇:SPEL,语义增强逻辑的简称,它更易理解<br />
一些:</p>
<ul class="org-ul">
<li>它解释了Lisp宏的核心功能,能改变Lisp运行环境的行为
</li>
<li>SPEL这个术语可以被用来很高雅的解释很多语言上观念.
</li>
<li>这个术语不会导致Lisp中的宏与其它的宏被混为一谈
</li>
<li>SPEL这个词重复的可能性非常低.Google搜索"macro 或者 macros 程序 -lisp<br />
-scheme"返回大概1150000条结果.而搜索"spel 或者 spels 程序 -lisp<br />
-scheme"值返回28400条结果.
</li>
</ul>
<p>
所以,我希望,作为一个Lisp程序员,你能接受这个术语-当然了,像这样的新词汇<br />
会被接受的可能性非常低.</p>
<p>
如果你有一个库或者是一个Lisp实现者,请先放下你手头上的工作,先在你的库里,添<br />
加下面这行代码:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmacro</span> <span style="color: #268bd2;">defspel</span> [&amp; rest] `<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmacro</span> <span style="color: #268bd2;">~@rest</span><span style="color: #8c8c8c;">))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 译者感想</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>本人对Lisp的宏还是有些了解的,所以个人无法接受SPEL这个新词汇
</li>
<li>且SPEL使得代码不易阅读,就game-action这个SPEL来说,使用了两层,而使用宏<br />
只需要一层
</li>
<li>附录中是我使用Clojure的惯用法重新改写的代码,且文字翻译成了中文.以及<br />
使用了宏而不是SPEL.各位可比较,自行选择
</li>
</ul>
<p>
<a href="http://www.ivanpig.com/blog/wp-content/uploads/2014/05/wpid-game.zip">源代码</a></p>
</div>
</div>



            <a href="/clojure/clojure%25e8%25bf%259b%25e9%2598%25b6%25e4%25bd%25bf%25e7%2594%25a8clojure%25e7%25bc%2596%25e5%2586%2599%25e6%2596%2587%25e5%25ad%2597%25e5%2586%2592%25e9%2599%25a9%25e6%25b8%25b8%25e6%2588%258f.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258brecord%25e5%2592%258cprotocol.html">Clojure教程:Record和Protocol</a></h2>

            <p class="post-meta">By 05月11日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  

  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 总结</a></li>
<li><a href="#sec-2">2. 个人感受</a></li>
</ul>
</div>
</div>
<p>
本文翻译自:<a href="http://www.jayway.com/2013/02/05/learn-clojure-using-records-and-protocols/">Learn Clojure using records and protocols</a></p>
<p>
当我对Clojure的括号不再疑惑后,另一个让我质疑为何要学习Clojure的问题是<br />
使用REPL很爽,但是我怎么来构建大型项目?".实际上,由于我的面向对象编程经<br />
验,我其实要问的是"我怎么才能将函数封装到类似class的东西里面去?".在本文<br />
中,我将会介绍一种类似于Java的方式来构建大型的Clojure项目.通过这种方式,<br />
希望你在学习Clojure的时候不会有太大的差异感!</p>
<p>
在Java中,我们出于各种目的而使用类.例如典型的使用Spring的web应用,你会看<br />
到类似下面的结构:</p>
<ul class="org-ul">
<li>Data transfer objects(DTO)
</li>
<li>Services(REST API,controllers,DAO)
</li>
<li>Rich object
</li>
</ul>
<p>
DTO实际上就是个结构体,他没有任何的行为(即方法).为了最小化样板代码,我趋<br />
向于使用pulibc final属性去实现DTO.我认为DTO就是个模板(schema),它就像<br />
一个REST服务输出的文件.但是我发现很多客户端开发人员可不关注这个,<br />
而只关注代码形式.有时你会看到DTO被作为数据库访问的一部分.这些DTO被称为<br />
贫血模型.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup></p>
<p>
Service实际上是包含了方法和注入了辅助Service的单例对象.不同的辅助<br />
Service提供了不同的服务.除了实现了接口外,Service只是包含了方法,和占位符很类似.单例模式导致的一个问题就是,新手无法预见到多线程里共享相同的实例出现意外的结果.他们将状态保存到私有属性里,而不需要从一个对象传递到另一个对象.很方便,但是是错误的做法.</p>
<p>
Rich object是面向对象语言中的思想.即将数据及和数据相关的操作封装到一个<br />
类里面.我可没说getter和setter是相关操作!但是,rich object类在项目中用得<br />
较少.取而代之的是使用DTO作为Service的输入和输出.使用DAO来访问数据库,然<br />
后返回DTO.我没说这种方法是错误的,我好奇的是,既然对于目前的Java架构是好<br />
是坏我们都无法确认,那为什么还要强求使用Clojure去实现类似的东西呢?</p>
<p>
先不管这么多,我们先看怎么在Clojure中做类似的事情?我直接给出如何做!</p>
<p>
首先,DTO就是数据,而Clojure擅长数据处理,例如map,list和set.但是如果你想<br />
要类似结构体的东西,Clojure里提供了record.如果你了解Scala你会发现这玩样<br />
和case class很像.定义record的方式如下:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defrecord</span> <span style="color: #268bd2;">Person</span> [<span style="color: #cb4b16;">firstName</span> <span style="color: #cb4b16;">lastName</span>]<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
这实际上创建了一个叫Person的Java类,它包含两个不可变的属性以及实现了<br />
hashCode和equals方法.record的行为模式和map很像,所以大部分适用于map的方<br />
法都适用与record!需要注意的是,虽然Clojure是动态类型,但是你可以使用类型<br />
提示来标示特定类型:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defrecord</span> <span style="color: #268bd2;">Person</span> [<span style="color: #cb4b16;">^String</span> <span style="color: #cb4b16;">firstName</span> <span style="color: #cb4b16;">^String</span> <span style="color: #cb4b16;">lastName</span>]<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
好,那现在我们来看看如何定义Service!让我们将问题分解为组织相关函数,定义<br />
接口及依赖注入!</p>
<p>
和Java不同,Clojure提供了多种组织相关函数的方法.使用哪种方式完全取决于<br />
你想做什么.首先,在Clojure中,函数不需要定义到一个类里面.取而代之的是,他<br />
们通过命名空间类管理,命名空间类似于Java中的包.如果你没有任何特别的要求,那么建议使用命名空间来管理函数.</p>
<p>
如果你想定义类似class的东西,你需要先定义接口!那你需要使用protocol!你可<br />
以把它当做和Java中的接口类似的东西.实际上,除了使用protocol你也可以直接<br />
使用Java的接口,因为Clojure可以直接访问Java代码!创建protocol的方式如下:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defprotocol</span> <span style="color: #268bd2;">Greet</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">sayHello</span> [this]<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
这和下面的代码功能相同:</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #859900;">public</span> <span style="color: #859900;">interface</span> <span style="color: #b58900;">Greet</span>{
    <span style="color: #b58900;">Object</span> <span style="color: #268bd2;">sayHello</span>();
}
</pre>
</div>
<p>
有两点需要注意:</p>
<ul class="org-ul">
<li>你需要将this包含在参数列表中!在面向对象语言中默认都包含了this,在类内<br />
部调用时默认包含了this.而在外部调用方法时,是使用对象名称.方法名,比如<br />
person.sayHello().而Clojure是函数式的,方法在前,调用方式如下(sayHello<br />
person)
</li>
<li>方法返回的是Object.这是因为Clojure是函数式的,我们努力使其没有副作用.返<br />
回值为void的方法,实际上大部分是为了其副作用的!
</li>
</ul>
<p>
实现protocol可以使用如下代码:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defrecord</span> <span style="color: #268bd2;">Person</span> [<span style="color: #cb4b16;">firstName</span> <span style="color: #cb4b16;">lastName</span>]
    <span style="color: #cb4b16;">Greet</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">sayHello</span> [this] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">print</span> <span style="color: #2aa198;">"Hello,my name is "</span> <span style="color: #cb4b16;">firstName</span><span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
最后就是依赖注入了!结论是:依赖注入对与Clojure来说不是必要的!可以看看下<br />
面两篇文章!</p>
<ul class="org-ul">
<li><a href="http://tech.puredanger.com/2010/03/01/dependency-injection-clojure/">Dependency injection in Clojure</a>
</li>
<li><a href="http://stackoverflow.com/questions/13085370/what-is-the-clojure-equivalent-to-google-guice">What is the Clojure equivalent to Google Guice?</a>
</li>
</ul>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 总结</h2>
<div class="outline-text-2" id="text-1">
<p>
从Java过渡到Scala相对来说比较简单,因为你可以在Scala中编写类Java的代码,<br />
然后再慢慢过渡到函数式代码编写上.但是对于Clojure来说,没有这个过渡过程,<br />
所以比较难于适应!但是通过使用record和protocol可以使你能在Clojure中做类<br />
似Java的事情,从而简化你的过渡难度!</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 个人感受</h2>
<div class="outline-text-2" id="text-2">
<p>
不知道是英文不行,还是作者行文有问题!感觉作者的文字不够流畅!按照原文直<br />
译,总感觉不通顺!故做了删减调整!<br />
对于依赖注入提供的两篇文章,评论比文章好得多!特别是第二篇的第一个评论!<br />
其实本文就简单介绍了Clojure的record和protocol入门而已!</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup>
<p class="footpara">
译者注:猜测作者的意思是,有些开发人员不管类是DTO还是DAO,只要结构<br />
相同就随便用!</p>
</div>
</div>
</div>



            <a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258brecord%25e5%2592%258cprotocol.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/emacs-vim/%25e6%2589%258b%25e5%258a%25a8%25e5%25ae%2589%25e8%25a3%2585org-mode.html">手动安装Org-mode</a></h2>

            <p class="post-meta">By 04月26日  2014  



 
<a class="post-categorybut " href="/type/#emacs-vim"><i class="fa fa-folder-open"></i> emacs-vim (25)</a>


  

  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Org-mode安装文件下载</a></li>
<li><a href="#sec-2">2. 安装</a></li>
</ul>
</div>
</div>
<p>
Emacs自带的Org-mode版本偏旧,对于有强迫症的我来说比较纠结,想升级到最新<br />
版本.不过使用list-packages命令来升级有bug,升级后无法正常使用.故手动升<br />
级.</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Org-mode安装文件下载</h2>
<div class="outline-text-2" id="text-1">
<p>
<a href="http://orgmode.org/">官方网站</a>直接下载zip包</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 安装</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>将zip包解压缩到本地
</li>
<li>修改local.mk文件.将prefix,lispdir,datadir,infodir这些变量配置为你的emacs安装的对应目录
</li>
<li>sudo make install
</li>
</ul>
<p>
搞定</p>
</div>
</div>



            <a href="/emacs-vim/%25e6%2589%258b%25e5%258a%25a8%25e5%25ae%2589%25e8%25a3%2585org-mode.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/%E5%BB%BA%E7%AB%99%E6%97%A5%E8%AE%B0/%25e5%25bc%2580%25e9%2580%259a%25e4%25ba%2586%25e5%25be%25ae%25e4%25bf%25a1%25e5%2585%25ac%25e4%25bc%2597%25e8%25b4%25a6%25e5%258f%25b7.html">开通了微信公众账号</a></h2>

            <p class="post-meta">By 03月23日  2014  



 
<a class="post-categorybut " href="/type/#建站日记"><i class="fa fa-folder-open"></i> 建站日记 (7)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> PigCode (1)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> 公共账号 (1)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> 微信 (1)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p>
	开通了微信公众账号,<span style="line-height: 1.6em;">欢迎大家关注: &nbsp;<strong>PigCode</strong></span></p>
<p>
	不定期推送博客文章,及编程相关内容.方便手机阅读.</p>
<p>
	1. n (最新文章)<br />
	2. r (随机文章)<br />
	3. h (热门文章)<br />
	4. help(帮助信息)<br />
	5. 其它字符进行关键字搜索.<br />
	推荐关键字<br />
	(Java,Clojure,Luminus,Scala,Tomcat,设计模式,Maven,Vim,Emacs)</p>
<p>
	<a href="http://www.ivanpig.com/blog/wp-content/uploads/2014/03/qrcode_for_gh_e7c2a64f8d46_4301.jpg"><img alt="qrcode_for_gh_e7c2a64f8d46_430" class="alignnone size-full wp-image-746" height="430" src="assets/qrcode_for_gh_e7c2a64f8d46_4301.jpg" width="430" /></a></p>



            <a href="/%E5%BB%BA%E7%AB%99%E6%97%A5%E8%AE%B0/%25e5%25bc%2580%25e9%2580%259a%25e4%25ba%2586%25e5%25be%25ae%25e4%25bf%25a1%25e5%2585%25ac%25e4%25bc%2597%25e8%25b4%25a6%25e5%258f%25b7.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>


<div class="pure-g pagination">
    
    <span class=" pure-u-1-2 pagination-item"><p>← Newer</p></span>
    


    
    <a class=" pure-u-1-2 pagination-item" href="/page/2"><p>Older →</p></a>
    
</div>








            </div>
            </div>
        <div class="footer">
                <a href="/love/welcome-my-blog.html">About</a>
                 <a href="/1">Collecting</a>
                <a href="tencent://message/?uin=561802774">QQ</a>
                <a href="https://github.com/ivanpig">GitHub</a>
            <script src="/js/min/nprogress.min.js"></script>
            <script src="/js/index.js"></script>
        </div>
        <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

    </div>

</div>

</body>

</html>
