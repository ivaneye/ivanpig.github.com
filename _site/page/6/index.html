<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="keywords" content=""/>
        <meta name="author" content="ivanpig.github.io"> 
        <link rel="canonical" href="http://ivanpig.github.io/page/6/index.html">
        <link href="http://ivanpig.github.io/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
        <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
        <title>IvanPig's Blog</title>
        <link rel="stylesheet" href="/css/min/pure-min.css">
        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
<![endif]-->
        <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
        <!--<![endif]-->

        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
<![endif]-->
        <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="/css/JekyllPure.css">
        <!--<![endif]-->

        <link href="/css/min/font-awesome.min.css" rel="stylesheet">
        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
<![endif]-->
        <script src="/js/min/jquery-1.7.2.min.js"></script>
        <link rel="stylesheet" href="/css/themes/my.css"/>
        <script src="/js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>

    <body>

        <div id="layout" class="pure-g">
            <div class="sidebar pure-u-1 pure-u-md-1-4">
                <div class="header">
                    <div class="headerpic">
                        <a href="/">
                            <img src="/img/head.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                        </a>
                    </div>
                    <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
                    <h2 id="_tagline" class="brand-tagline">IvanPig's Blog</h2>
<!--                     <br class="newline"/><br class="newline"/> -->

                    <nav class="nav">
                        <ul class="nav-list">
                            <li class="nav-item">
                                <a class="pure-button" href="/Timing">时间轴</a>
                            </li>
                            <li class="nav-item">
                                <a class="pure-button" href="/tag">标签库</a>
                            </li>
                            <li class="nav-item">
                                <a class="pure-button" href="/type">分类库</a>
                            </li>
                        </ul>
                    </nav>
                    <div class="search">
                        <form action="/search">
                            <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                        </form>
                    </div>

                    <div id="toc"></div>
                    <div id="toc1"></div>
                    <nav id="nav">
                        <ul class="nav-list">
                            <li class="nav-link">
                                <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                            </li>
                            <li class="nav-link">
                                <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                            </li>
                            <li class="nav-link">
                                <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>

            <div class="content pure-u-1 pure-u-md-3-4">
                <!--[if lt IE 8]>
<i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
<![endif]-->
                <div>
                    <div class="posts">

                        


<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/12/scala_exercises_10.html">快学Scala习题解答—第十章 特质</a></h2>

        <p class="post-meta">By 03月12日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>特质</h1>

<h2>java.awt.Rectangle类有两个很有用的方法translate和grow,但可惜的是像java.awt.geom.Ellipse2D这样的类没有。在Scala中，你可以解决掉这个问题。定义一个RenctangleLike特质,加入具体的translate和grow方法。提供任何你需要用来实现的抽象方法,以便你可以像如下代码这样混入该特质:</h2>

<pre><code class="{.scala}">val egg = new java.awt.geom.Ellipse2D.Double(5,10,20,30) with RectangleLike
egg.translate(10,-10)
egg.grow(10,20)
</code></pre>

<p>使用自身类型使得trait可以操作x,y</p>

<pre><code class="{.scala}">import java.awt.geom.Ellipse2D


trait RectangleLike{
  this:Ellipse2D.Double=&gt;
  def translate(x:Double,y:Double){
    this.x = x
    this.y = y
  }
  def grow(x:Double,y:Double){
    this.x += x
    this.y += y
  }
}

object Test extends App{
  val egg = new Ellipse2D.Double(5,10,20,30) with RectangleLike
  println("x = " + egg.getX + " y = " + egg.getY)
  egg.translate(10,-10)
  println("x = " + egg.getX + " y = " + egg.getY)
  egg.grow(10,20)
  println("x = " + egg.getX + " y = " + egg.getY)
}
</code></pre>

<h2>通过把scala.math.Ordered[Point]混入java.awt.Point的方式，定义OrderedPoint类。按辞典编辑方式排序，也就是说，如果x\&lt;x'或者x=x'且y\&lt;y'则(x,y)\&lt;(x',y')</h2>

<pre><code class="{.scala}">import java.awt.Point

class OrderedPoint extends Point with Ordered[Point]{
  def compare(that: Point): Int = if (this.x &lt;= that.x &amp;&amp; this.y &lt; that.y) -1
                                   else if(this.x == that.x &amp;&amp; this.y == that.y) 0
                                   else 1
}
</code></pre>

<h2>查看BitSet类,将它的所有超类和特质绘制成一张图。忽略类型参数([...]中的所有内容)。然后给出该特质的线性化规格说明</h2>

<p>这个略</p>

<h2>提供一个CryptoLogger类，将日志消息以凯撒密码加密。缺省情况下密匙为3，不过使用者也可以重写它。提供缺省密匙和-3作为密匙是的使用示例</h2>

<pre><code class="{.scala}">trait Logger{
  def log(str:String,key:Int = 3):String
}

class CryptoLogger extends Logger{

  def log(str: String, key:Int): String = {
    for ( i &lt;- str) yield if (key &gt;= 0) (97 + ((i - 97 + key)%26)).toChar else (97 + ((i - 97 + 26 + key)%26)).toChar
  }
}

object Test extends App{
    val plain = "chenzhen";
    println("明文为：" + plain);
    println("加密后为：" + new CryptoLogger().log(plain));
    println("加密后为：" + new CryptoLogger().log(plain,-3));
}
</code></pre>

<h2>JavaBean规范里有一种提法叫做属性变更监听器(property change listener)，这是bean用来通知其属性变更的标准方式。PropertyChangeSupport类对于任何想要支持属性变更通知其属性变更监听器的bean而言是个便捷的超类。但可惜已有其他超类的类---比如JComponent---必须重新实现相应的方法。将PropertyChangeSupport重新实现为一个特质,然后将它混入到java.awt.Point类中</h2>

<pre><code class="{.scala}">import java.awt.Point
import java.beans.PropertyChangeSupport

trait PropertyChange extends PropertyChangeSupport

val p = new Point() with PropertyChange
</code></pre>

<h2>在Java AWT类库中,我们有一个Container类，一个可以用于各种组件的Component子类。举例来说,Button是一个Component,但Panel是Container。这是一个运转中的组合模式。Swing有JComponent和JContainer,但如果你仔细看的话，你会发现一些奇怪的细节。尽管把其他组件添加到比如JButton中毫无意义,JComponent依然扩展自Container。Swing的设计者们理想情况下应该会更倾向于图10-4中的设计。但在Java中那是不可能的。请解释这是为什么？Scala中如何用特质来设计出这样的效果?</h2>

<p><img src="file:scala/01.jpg" alt="" />
Java只能单继承,JContainer不能同时继承自Container和JComponent。Scala可以通过特质解决这个问题.</p>

<h2>市面上有不下数十种关于Scala特质的教程,用的都是些"在叫的狗"啦，"讲哲学的青蛙"啦之类的傻乎乎的例子。阅读和理解这些机巧的继承层级很乏味且对于理解问题没什么帮助,但自己设计一套继承层级就不同了,会很有启发。做一个你自己的关于特质的继承层级，要求体现出叠加在一起的特质,具体的和抽象的方法，以及具体的和抽象的字段</h2>

<pre><code class="{.scala}">

trait Fly{
  def fly(){
    println("flying")
  }

  def flywithnowing()
}

trait Walk{
  def walk(){
    println("walk")
  }
}

class Bird{
  var name:String = _
}

class BlueBird extends Bird with Fly with Walk{
  def flywithnowing() {
    println("BlueBird flywithnowing")
  }
}

object Test extends App{
  val b = new BlueBird()
  b.walk()
  b.flywithnowing()
  b.fly()
}
</code></pre>

<h2>在java.io类库中，你可以通过BufferedInputStream修饰器来给输入流增加缓冲机制。用特质来重新实现缓冲。简单起见，重写read方法</h2>

<p>后续JavaIO详细讨论</p>

<h2>使用本章的日志生成器特质,给前一个练习中的方案增加日志功能，要求体现缓冲的效果</h2>

<p>同上</p>

<h2>实现一个IterableInputStream类，扩展java.io.InputStream并混入Iterable[Byte]特质</h2>

<pre><code class="{.scala}">import java.io.InputStream

class IterableInputStream extends InputStream with Iterable[Byte]{
  def read(): Int = 0

  def iterator: Iterator[Byte] = null
}
</code></pre>



    <a href="/2013/03/12/scala_exercises_10.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/11/scala_exercises_09.html">快学Scala习题解答—第九章 文件和正则表达式</a></h2>

        <p class="post-meta">By 03月11日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>文件和正则表达式</h1>

<h2>编写一小段Scala代码，将某个文件中的行倒转顺序(将最后一行作为第一行,依此类推)</h2>

<pre><code class="{.scala}">import io.Source
import java.io.PrintWriter

val path = "test.txt"

val reader = Source.fromFile(path).getLines()

val result = reader.toArray.reverse

val pw = new PrintWriter(path)

result.foreach(line =&gt; pw.write(line + "\n"))

pw.close()
</code></pre>

<h2>编写Scala程序,从一个带有制表符的文件读取内容,将每个制表符替换成一组空格,使得制表符隔开的n列仍然保持纵向对齐,并将结果写入同一个文件</h2>

<pre><code class="{.scala}">import io.Source
import java.io.PrintWriter

val path = "test.txt"

val reader = Source.fromFile(path).getLines()

val result = for ( t &lt;- reader) yield t.replaceAll("\\t","    ")

val pw = new PrintWriter(path)

result.foreach(line =&gt; pw.write(line + "\n"))

pw.close()
</code></pre>

<h2>编写一小段Scala代码,从一个文件读取内容并把所有字符数大于12的单词打印到控制台。如果你能用单行代码完成会有额外奖励</h2>

<pre><code class="{.scala}">import io.Source

Source.fromFile("test.txt").mkString.split("\\s+").foreach(arg =&gt; if(arg.length &gt; 12) println(arg))
</code></pre>

<h2>编写Scala程序，从包含浮点数的文本文件读取内容，打印出文件中所有浮点数之和，平均值，最大值和最小值</h2>

<pre><code class="{.scala}">import io.Source

val nums = Source.fromFile("test.txt").mkString.split("\\s+")

var total = 0d

nums.foreach(total += _.toDouble)

println(total)
println(total/nums.length)
println(nums.max)
println(nums.min)
</code></pre>

<h2>编写Scala程序，向文件中写入2的n次方及其倒数，指数n从0到20。对齐各列:</h2>

<pre><code class="{.example}">   1         1
   2         0.5
   4         0.25
 ...         ...
</code></pre>

<pre><code class="{.scala}">import java.io.PrintWriter

val pw = new PrintWriter("test.txt")

for ( n &lt;- 0 to 20){
  val t = BigDecimal(2).pow(n)
  pw.write(t.toString())
  pw.write("\t\t")
  pw.write((1/t).toString())
  pw.write("\n")
}

pw.close()
</code></pre>

<p>编写正则表达式,匹配Java或C++程序代码中类似"like this,maybe with " or\</p>

<h2>"这样的带引号的字符串。编写Scala程序将某个源文件中所有类似的字符串打印出来</h2>

<pre><code class="{.scala}">import io.Source

val source = Source.fromFile("test.txt").mkString

val pattern = "\\w+\\s+\"".r

pattern.findAllIn(source).foreach(println)
</code></pre>

<h2>编写Scala程序，从文本文件读取内容，并打印出所有的非浮点数的词法单位。要求使用正则表达式</h2>

<pre><code class="{.scala}">import io.Source

val source = Source.fromFile("test.txt").mkString

val pattern = """[^((\d+\.){0,1}\d+)^\s+]+""".r

pattern.findAllIn(source).foreach(println)
</code></pre>

<h2>编写Scala程序打印出某个网页中所有img标签的src属性。使用正则表达式和分组</h2>

<pre><code class="{.scala}">import io.Source

val source = Source.fromFile("D:\\ProgramCodes\\ScalaTest\\src\\test.txt").mkString
val pattern = """&lt;img[^&gt;]+(src\s*=\s*"[^&gt;^"]+")[^&gt;]*&gt;""".r

for (pattern(str) &lt;- pattern.findAllIn(source)) println(str)
</code></pre>

<h2>编写Scala程序，盘点给定目录及其子目录中总共有多少以.class为扩展名的文件</h2>

<pre><code class="{.scala}">import java.io.File

val path = "."

val dir = new File(path)


def subdirs(dir:File):Iterator[File]={
  val children = dir.listFiles().filter(_.getName.endsWith("class"))
  children.toIterator ++ dir.listFiles().filter(_.isDirectory).toIterator.flatMap(subdirs _)
}

val n = subdirs(dir).length

println(n)
</code></pre>

<h2>扩展那个可序列化的Person类，让它能以一个集合保存某个人的朋友信息。构造出一些Person对象，让他们中的一些人成为朋友，然后将Array[Person]保存到文件。将这个数组从文件中重新读出来，校验朋友关系是否完好</h2>

<p>注意,请在main中执行。脚本执行无法序列化。</p>

<pre><code class="{.scala}">import collection.mutable.ArrayBuffer
import java.io.{ObjectInputStream, FileOutputStream, FileInputStream, ObjectOutputStream}

class Person(var name:String) extends Serializable{

  val friends = new ArrayBuffer[Person]()

  def addFriend(friend : Person){
    friends += friend
  }

  override def toString() = {
    var str = "My name is " + name + " and my friends name is "
    friends.foreach(str += _.name + ",")
    str
  }
}


object Test extends App{
  val p1 = new Person("Ivan")
  val p2 = new Person("F2")
  val p3 = new Person("F3")

  p1.addFriend(p2)
  p1.addFriend(p3)
  println(p1)

  val out = new ObjectOutputStream(new FileOutputStream("test.txt"))
  out.writeObject(p1)
  out.close()

  val in =  new ObjectInputStream(new FileInputStream("test.txt"))
  val p = in.readObject().asInstanceOf[Person]
  println(p)
}
</code></pre>



    <a href="/2013/03/11/scala_exercises_09.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/10/scala_exercises_08.html">快学Scala习题解答—第八章 继承</a></h2>

        <p class="post-meta">By 03月10日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>继承</h1>

<h2>扩展如下的BankAccount类，新类CheckingAccount对每次存款和取款都收取1美元的手续费</h2>

<pre><code class="{.scala}">class BankAccount(initialBalance:Double){
    private var balance = initialBalance
    def deposit(amount:Double) = { balance += amount; balance}
    def withdraw(amount:Double) = {balance -= amount; balance}
}
</code></pre>

<p>继承语法的使用。代码如下</p>

<pre><code class="{.scala}">class CheckingAccount(initialBalance:Double) extends BankAccount(initialBalance){
  override def deposit(amount: Double): Double = super.deposit(amount - 1)

  override def withdraw(amount: Double): Double = super.withdraw(amount + 1)
}
</code></pre>

<h2>扩展前一个练习的BankAccount类，新类SavingsAccount每个月都有利息产生(earnMonthlyInterest方法被调用)，并且有每月三次免手续费的存款或取款。在earnMonthlyInterest方法中重置交易计数。</h2>

<pre><code class="{.scala}">class SavingsAccount(initialBalance:Double) extends BankAccount(initialBalance){
  private var num:Int = _

  def earnMonthlyInterest()={
    num = 3
    super.deposit(1)
  }

  override def deposit(amount: Double): Double = {
    num -= 1
    if(num &lt; 0) super.deposit(amount - 1) else super.deposit(amount)
  }

  override def withdraw(amount: Double): Double = {
    num -= 1
    if (num &lt; 0) super.withdraw(amount + 1) else super.withdraw(amount)
  }
}
</code></pre>

<h2>翻开你喜欢的Java或C++教科书，一定会找到用来讲解继承层级的实例，可能是员工，宠物，图形或类似的东西。用Scala来实现这个示例。</h2>

<p>Thinking in Java中的代码</p>

<pre><code class="{.java}">class Art{
    Art(){System.out.println("Art constructor");}
}

class Drawing extends Art{
    Drawing() {System.out.println("Drawing constructor");}
}

public class Cartoon extends Drawing{
    public Cartoon() { System.out.println("Cartoon constructor");}
}
</code></pre>

<p>使用Scala改写如下</p>

<pre><code class="{.scala}">class Art{
  println("Art constructor")
}

class Drawing extends Art{
  println("Drawing constructor")
}

class Cartoon extends Drawing{
  println("Cartoon constructor")
}
</code></pre>

<h2>定义一个抽象类Item,加入方法price和description。SimpleItem是一个在构造器中给出价格和描述的物件。利用val可以重写def这个事实。Bundle是一个可以包含其他物件的物件。其价格是打包中所有物件的价格之和。同时提供一个将物件添加到打包当中的机制，以及一个适合的description方法</h2>

<pre><code class="{.scala}">import collection.mutable.ArrayBuffer


abstract class Item{
  def price():Double
  def description():String

  override def toString():String={
    "description:" + description() + "  price:" + price()
  }
}

class SimpleItem(val price:Double,val description:String) extends Item{

}

class Bundle extends Item{

  val items = new ArrayBuffer[Item]()

  def addItem(item:Item){
    items += item
  }

  def price(): Double = {
    var total = 0d
    items.foreach(total += _.price())
    total
  }

  def description(): String = {
    items.mkString(" ")
  }
}
</code></pre>

<h2>设计一个Point类，其x和y坐标可以通过构造器提供。提供一个子类LabeledPoint，其构造器接受一个标签值和x,y坐标,比如:new LabeledPoint("Black Thursday",1929,230.07)</h2>

<pre><code class="{.scala}">class Point(x:Int,y:Int){
}

class LabeledPoint(label:String,x:Int,y:Int) extends Point(x,y){
}
</code></pre>

<h2>定义一个抽象类Shape，一个抽象方法centerPoint，以及该抽象类的子类Rectangle和Circle。为子类提供合适的构造器，并重写centerPoint方法</h2>

<pre><code class="{.scala}">abstract class Shape{
  def centerPoint()
}

class Rectangle(startX:Int,startY:Int,endX:Int,endY:Int) extends Shape{
  def centerPoint() {}
}

class Circle(x:Int,y:Int,radius:Double) extends Shape{
  def centerPoint() {}
}
</code></pre>

<h2>提供一个Square类，扩展自java.awt.Rectangle并且是三个构造器：一个以给定的端点和宽度构造正方形，一个以(0,0)为端点和给定的宽度构造正方形，一个以(0,0)为端点,0为宽度构造正方形</h2>

<pre><code class="{.scala}">import java.awt.{Point, Rectangle}


class Square(point:Point,width:Int) extends Rectangle(point.x,point.y,width,width){

  def this(){
    this(new Point(0,0),0)
  }

  def this(width:Int){
    this(new Point(0,0),width)
  }
}
</code></pre>

<h2>编译8.6节中的Person和SecretAgent类并使用javap分析类文件。总共有多少name的getter方法？它们分别取什么值？(提示：可以使用-c和-private选项)</h2>

<p>总共两个。Person中取得的是传入的name,而SecretAgent中取得的是默认的"secret"</p>

<h2>在8.10节的Creature类中，将val range替换成一个def。如果你在Ant子类中也用def的话会有什么效果？如果在子类中使用val又会有什么效果？为什么？</h2>

<p>在Ant中使用def没有问题。但是如果使用val则无法编译。因为val只能重写不带参数的def。这里的def是带参数的</p>

<h2>文件scala/collection/immutable/Stack.scala包含如下定义:</h2>

<pre><code class="{.scala}">class Stack[A] protected (protected val elems: List[A])
</code></pre>

<p>请解释protected关键字的含义。(提示：回顾我们在第5章中关于私有构造器的讨论)
此构造方法只能被其子类来调用,而不能被外界直接调用</p>



    <a href="/2013/03/10/scala_exercises_08.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/09/scala_exercises_07.html">快学Scala习题解答—第七章 包和引入</a></h2>

        <p class="post-meta">By 03月09日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>包和引入</h1>

<h2>编写示例程序，展示为什么</h2>

<pre><code class="{.scala}">package com.horstmann.impatient
</code></pre>

<p>不同于</p>

<pre><code class="{.scala}">package com
package horstmann
package impatient
</code></pre>

<p>分别使用package的效果如下</p>

<pre><code class="{.scala}">package com {
  class T1() {}

  package horstmann {
    class T2(t: T1) {}

    package impatient {
      class T3(t1: T1, t2: T2) {}
    }
  }
}
</code></pre>

<p>子包里的类可以使用父包里的类。但是第一种方式不可以</p>

<pre><code class="{.scala}">package com.horstmann.impatient{
  class T4(t1:T1,t3:T3)      //无法找到T1
}
</code></pre>

<h2>编写一段让你的Scala朋友们感到困惑的代码，使用一个不在顶部的com包</h2>

<p>这样可以吗？</p>

<pre><code class="{.scala}">package com {
  class T1() {}

  package horstmann {
    class T2(t: T1) {}

    package impatient {
      class T3(t1: T1, t2: T2) {}
    }
  }
}

import com._

class TT(t1:T1){

}
</code></pre>

<h2>编写一个包random,加入函数nextInt():Int,nextDouble():Double,setSeed(seed:Int):Unit。生成随机数的算法采用线性同余生成器:</h2>

<pre><code class="{.example}">后值 = (前值 * a + b)mod 2^n
其中,a = 1664525,b=1013904223,n = 32,前值的初始值为seed
</code></pre>

<pre><code class="{.scala}">package random{
package object random{

  var seed:Int = _
  val a = BigDecimal(1664525)
  val b = BigDecimal(1013904223)
  val n = 32


  def nextInt():Int={
    val temp = (seed * a + b) % BigDecimal(2).pow(n)
    seed = temp.toInt
    seed
  }

  def nextDouble():Double={
    val temp = (seed * a + b) % BigDecimal(2).pow(n)
    seed = temp.toInt
    temp.toDouble
  }
}
}

package test {
import random.random

object Test extends App {
  random.seed = 4
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextDouble())
  println(random.nextInt())
  println(random.nextInt())
  println(random.nextInt())
  println(random.nextInt())
}

}
</code></pre>

<h2>在你看来Scala的设计者为什么要提供package object语法而不是简单的让你将函数和变量添加到包中呢？</h2>

<p>JVM不支持。。。</p>

<h2>private[com] def giveRaise(rate:Double)的含义是什么？有用吗？</h2>

<p>除了com包可访问，其他包都不能访问。</p>

<h2>编写一段程序,将Java哈希映射中的所有元素拷贝到Scala哈希映射。用引入语句重命名这两个类。</h2>

<pre><code class="{.scala}">import java.util.{HashMap =&gt; JavaHashMap}
import scala.collection.mutable.HashMap

object Test extends App{

  val map = new JavaHashMap[String,String]()
  map.put("1","a")
  map.put("2","b")
  map.put("3","c")

  val smap = new HashMap[String,String]()

  for(key &lt;- map.keySet().toArray){
    smap += (key.toString -&gt; map.get(key))
  }

  println(smap.mkString)
}
</code></pre>

<h2>在前一个练习中，将所有引入语句移动到尽可能小的作用域里</h2>

<pre><code class="{.scala}">object Test extends App{

  import java.util.{HashMap =&gt; JavaHashMap}

  val map = new JavaHashMap[String,String]()
  map.put("1","a")
  map.put("2","b")
  map.put("3","c")

  import scala.collection.mutable.HashMap

  val smap = new HashMap[String,String]()

  for(key &lt;- map.keySet().toArray){
    smap += (key.toString -&gt; map.get(key))
  }

  println(smap.mkString)
}
</code></pre>

<h2>以下代码的作用是什么？这是个好主意吗？</h2>

<pre><code class="{.scala}">import java._
import javax._
</code></pre>

<p>导入java和javax下的所有类。而java和javax下是没有类的。所以此代码无用</p>

<h2>编写一段程序，引入java.lang.System类，从user.name系统属性读取用户名，从Console对象读取一个密码,如果密码不是"secret"，则在标准错误流中打印一个消息；如果密码是"secret"，则在标准输出流中打印一个问候消息。不要使用任何其他引入，也不要使用任何限定词(带句点的那种)</h2>

<pre><code class="{.scala}">import java.lang.System

object Test extends App{
  var password = Console.readLine()

  if (password equals "secret") System.out.println("Hello " + System.getProperty("user.name"))
  else System.err.println("password error!")
}
</code></pre>

<h2>除了StringBuilder,还有哪些java.lang的成员是被scala包覆盖的？</h2>

<p>直接比对java.lang下的类和scala包下的类即可</p>



    <a href="/2013/03/09/scala_exercises_07.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/08/scala_exercises_06.html">快学Scala习题解答—第六章 对象</a></h2>

        <p class="post-meta">By 03月08日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>对象</h1>

<h2>编写一个Conversions对象，加入inchesToCentimeters,gallonsToLiters和milesToKilometers方法</h2>

<pre><code class="{.scala}">object Conversions{
    def inchesToCentimeters(){}
    def gallonsToLiters(){}
    def milesToKilometers(){}
}
</code></pre>

<h2>前一个练习不是很面向对象。提供一个通用的超类UnitConversion并定义扩展该超类的InchesToCentimeters,GallonsToLiters和MilesToKilometers对象</h2>

<pre><code class="{.scala}">abstract class UnitConversion{

  def inchesToCentimeters(){}
  def gallonsToLiters(){}
  def milesToKilometers(){}

}

object InchesToCentimeters extends UnitConversion{
  override def inchesToCentimeters() {}
}

object GallonsToLiters extends UnitConversion{
  override def gallonsToLiters() {}
}

object MilesToKilometers extends UnitConversion{
  override def milesToKilometers() {}
}
</code></pre>

<h2>定义一个扩展自java.awt.Point的Origin对象。为什么说这实际上不是个好主意？(仔细看Point类的方法)</h2>

<p>Point中的getLocation方法返回的是Point对象，如果想返回Origin对象，需要Origin类才行</p>

<pre><code class="{.scala}">object Origin extends Point with App{

  override def getLocation: Point = super.getLocation

  Origin.move(2,3)
  println(Origin.toString)

}
</code></pre>

<h2>定义一个Point类和一个伴生对象,使得我们可以不用new而直接用Point(3,4)来构造Point实例</h2>

<p>apply方法的使用</p>

<pre><code class="{.scala}">class Point(x:Int,y:Int){
  override def toString: String = "x = " + x + " y = " + y
}

object Point extends App{
  def apply(x:Int,y:Int)={
    new Point(x,y)
  }

  val p = Point(1,2)
  println(p)
}
</code></pre>

<h2>编写一个Scala应用程序,使用App特质,以反序打印命令行参数,用空格隔开。举例来说,scala Reverse Hello World应该打印World Hello</h2>

<pre><code class="{.scala}">object Reverse extends App{
  args.reverse.foreach(arg =&gt; print(arg  + " "))
}
</code></pre>

<h2>编写一个扑克牌4种花色的枚举,让其toString方法分别返回♣,@\<span style="color:red"\>♦@\&lt;/span>,@\<span style="color:red"\>♥@\&lt;/span>,♠</h2>

<pre><code class="{.scala}">object Card extends Enumeration with App{
  val M = Value("♣")
  val T = Value("♠")
  val H = Value("♥")
  val F = Value("♦")

  println(Card.M)
  println(Card.T)
  println(Card.H)
  println(Card.F)
}
</code></pre>

<h2>实现一个函数,检查某张牌的花色是否为红色</h2>

<pre><code class="{.scala}">object Card extends Enumeration with App{
  val M = Value("♣")
  val T = Value("♠")
  val H = Value("♥")
  val F = Value("♦")

  def color(c:Card.Value){
    if(c == Card.M || c == Card.T) print("Black")
    else print("Red")
  }

  color(Card.H)
}
</code></pre>

<h2>编写一个枚举,描述RGB立方体的8个角。ID使用颜色值(例如:红色是0xff0000)</h2>

<pre><code class="{.scala}">object RGB extends Enumeration with App{
  val RED = Value(0xff0000,"Red")
  val BLACK = Value(0x000000,"Black")
  val GREEN = Value(0x00ff00,"Green")
  val CYAN = Value(0x00ffff,"Cyan")
  val YELLOW = Value(0xffff00,"Yellow")
  val WHITE = Value(0xffffff,"White")
  val BLUE = Value(0x0000ff,"Blue")
  val MAGENTA = Value(0xff00ff,"Magenta")
}
</code></pre>



    <a href="/2013/03/08/scala_exercises_06.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/07/scala_exercises_05.html">快学Scala习题解答—第五章 类</a></h2>

        <p class="post-meta">By 03月07日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>类</h1>

<h2>改进5.1节的Counter类,让它不要在Int.MaxValue时变成负数</h2>

<p>加个判断就OK了</p>

<pre><code class="{.scala}">class Count{
  private var value = Int.MaxValue
  def increment(){if(value &lt; Int.MaxValue) value + 1 else value }
  def current = value
}
</code></pre>

<h2>编写一个BankAccount类，加入deposit和withdraw方法，和一个只读的balance属性</h2>

<pre><code class="{.scala}">class BankAccount(val balance:Int = 0){
  def deposit(){}
  def withdraw(){}
}
</code></pre>

<h2>编写一个Time类，加入只读属性hours和minutes，和一个检查某一时刻是否早于另一时刻的方法before(other:Time):Boolean。Time对象应该以new Time(hrs,min)方式构建。其中hrs以军用时间格式呈现(介于0和23之间)</h2>

<pre><code class="{.scala}">class Time(val hours:Int,val minutes:Int){

   def before(other:Time):Boolean={
     hours &lt; other.hours || (hours == other.hours &amp;&amp; minutes &lt; other.minutes)
   }

   override def toString():String={
     hours + " : " + minutes
   }
}
</code></pre>

<h2>重新实现前一个类中的Time类，将内部呈现改成午夜起的分钟数(介于0到24*60-1之间)。不要改变公有接口。也就是说，客户端代码不应因你的修改而受影响</h2>

<pre><code class="{.scala}"> class Time(val hours:Int,val minutes:Int){

   def before(other:Time):Boolean={
     hours &lt; other.hours || (hours == other.hours &amp;&amp; minutes &lt; other.minutes)
   }

   override def toString():String={
      hours * 60 + minutes
   }
 }
</code></pre>

<h2>创建一个Student类，加入可读写的JavaBeans属性name(类型为String)和id(类型为Long)。有哪些方法被生产？(用javap查看。)你可以在Scala中调用JavaBeans的getter和setter方法吗？应该这样做吗？</h2>

<p>生成了name(),name_=(),id(),id_=(),setName(),getName(),setId(),getId()
编写代码如下</p>

<pre><code class="{.scala}">import scala.reflect.BeanProperty

class Student{

    @BeanProperty var name:String = _
    @BeanProperty var id:Long = _
}
</code></pre>

<p>javap -c Student 后显示如下</p>

<pre><code class="{.example}">Compiled from "Student.scala"
public class Student extends java.lang.Object implements scala.ScalaObject{
public java.lang.String name();
  Code:
   0:   aload_0
   1:   getfield        #13; //Field name:Ljava/lang/String;
   4:   areturn

public void name_$eq(java.lang.String);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #13; //Field name:Ljava/lang/String;
   5:   return

public void setName(java.lang.String);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #13; //Field name:Ljava/lang/String;
   5:   return

public long id();
  Code:
   0:   aload_0
   1:   getfield        #19; //Field id:J
   4:   lreturn

public void id_$eq(long);
  Code:
   0:   aload_0
   1:   lload_1
   2:   putfield        #19; //Field id:J
   5:   return

public void setId(long);
  Code:
   0:   aload_0
   1:   lload_1
   2:   putfield        #19; //Field id:J
   5:   return

public long getId();
  Code:
   0:   aload_0
   1:   invokevirtual   #25; //Method id:()J
   4:   lreturn

public java.lang.String getName();
  Code:
   0:   aload_0
   1:   invokevirtual   #28; //Method name:()Ljava/lang/String;
   4:   areturn

public Student();
  Code:
   0:   aload_0
   1:   invokespecial   #34; //Method java/lang/Object."&lt;init&gt;":()V
   4:   return

}
</code></pre>

<h2>在5.2节的Person类中提供一个主构造器,将负年龄转换为0</h2>

<pre><code class="{.scala}">class Person(var age:Int){
  age = if(age &lt; 0) 0 else age
}
</code></pre>

<h2>编写一个Person类，其主构造器接受一个字符串，该字符串包含名字，空格和姓，如new Person("Fred Smith")。提供只读属性firstName和lastName。主构造器参数应该是var,val还是普通参数？为什么？</h2>

<p>必须为val。如果为var，则对应的此字符串有get和set方法，而Person中的firstName和lastName为只读的,所以不能重复赋值。如果为var则会重复赋值而报错</p>

<h2>创建一个Car类，以只读属性对应制造商，型号名称，型号年份以及一个可读写的属性用于车牌。提供四组构造器。每个构造器fc都要求制造商和型号为必填。型号年份和车牌可选，如果未填，则型号年份为-1，车牌为空串。你会选择哪一个作为你的主构造器？为什么？</h2>

<p>这个没太明白题意。。。</p>

<pre><code class="{.scala}">class Car(val maker:String,val typeName:String,val year:Int = -1,var carLice:String = ""){
}
</code></pre>

<h2>在Java,C#或C++重做前一个练习。Scala相比之下精简多少？</h2>

<p>这个就不写了。</p>

<h2>考虑如下的类</h2>

<pre><code class="{.scala}">class Employ(val name:String,var salary:Double){
    def this(){this("John Q. Public",0.0)}
}
</code></pre>

<p>重写该类,使用显示的字段定义，和一个缺省主构造器。你更倾向于使用哪种形式？为什么？</p>

<pre><code class="{.scala}">class Employ{
    val name:String = "John Q. Public"
    var salary:Double = 0.0
}
</code></pre>

<p>个人更喜欢第二种方式，简单明了。</p>



    <a href="/2013/03/07/scala_exercises_05.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/06/scala_exercises_04.html">快学Scala习题解答—第四章 映射和元组</a></h2>

        <p class="post-meta">By 03月06日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>映射和元组</h1>

<h2>设置一个映射,其中包含你想要的一些装备，以及它们的价格。然后构建另一个映射，采用同一组键，但是价格上打9折</h2>

<p>映射的简单操作</p>

<pre><code class="{.example}">scala&gt; val map = Map("book"-&gt;10,"gun"-&gt;18,"ipad"-&gt;1000)
map: scala.collection.immutable.Map[java.lang.String,Int] = Map(book -&gt; 10, gun -&gt; 18, ipad -&gt; 1000)

scala&gt; for((k,v) &lt;- map) yield (k,v * 0.9)
res3: scala.collection.immutable.Map[java.lang.String,Double] = Map(book -&gt; 9.0, gun -&gt; 16.2, ipad -&gt; 900.0)
</code></pre>

<h2>编写一段程序，从文件中读取单词。用一个可变映射来清点每个单词出现的频率。读取这些单词的操作可以使用java.util.Scanner:</h2>

<p>val in = new java.util.Scanner(new java.io.File("myfile.txt"))
while(in.hasNext()) 处理 in.next() 或者翻到第9章看看更Scala的做法。
最后，打印出所有单词和它们出现的次数。
@\&lt;p>当然使用Scala的方法啦。参考第9章@\&lt;/p>
首先，创建一个文件myfile.txt。输入如下内容</p>

<pre><code class="{.example}">test test ttt test ttt t test sss s
</code></pre>

<p>Scala代码如下</p>

<pre><code class="{.scala}">import scala.io.Source
import scala.collection.mutable.HashMap

//val source = Source.fromFile("myfile.txt")
//val tokens = source.mkString.split("\\s+")  //此写法tokens为空，不知为何

val source = Source.fromFile("myfile.txt").mkString

val tokens = source.split("\\s+")

val map = new HashMap[String,Int]

for(key &lt;- tokens){
    map(key) = map.getOrElse(key,0) + 1
}

println(map.mkString(","))
</code></pre>

<h2>重复前一个练习，这次用不可变的映射</h2>

<p>不可变映射与可变映射的区别就是，每次添加元素，都会返回一个新的映射</p>

<pre><code class="{.scala}">import scala.io.Source

val source = Source.fromFile("myfile.txt").mkString

val tokens = source.split("\\s+")

var map = Map[String,Int]()

for(key &lt;- tokens){
  map += (key -&gt; (map.getOrElse(key,0) + 1))
}

println(map.mkString(","))
</code></pre>

<h2>重复前一个练习，这次使用已排序的映射，以便单词可以按顺序打印出来</h2>

<p>和上面的代码没有什么区别，只是将映射修改为SortedMap</p>

<pre><code class="{.scala}">import scala.io.Source
import scala.collection.SortedMap

val source = Source.fromFile("myfile.txt").mkString

val tokens = source.split("\\s+")

var map = SortedMap[String,Int]()

for(key &lt;- tokens){
  map += (key -&gt; (map.getOrElse(key,0) + 1))
}

println(map.mkString(","))
</code></pre>

<h2>重复前一个练习，这次使用java.util.TreeMap并使之适用于Scala API</h2>

<p>主要涉及java与scala的转换类的使用</p>

<pre><code class="{.scala}">import scala.io.Source
import scala.collection.mutable.Map
import scala.collection.JavaConversions.mapAsScalaMap
import java.util.TreeMap

val source = Source.fromFile("myfile.txt").mkString

val tokens = source.split("\\s+")

val map:Map[String,Int] = new TreeMap[String,Int]

for(key &lt;- tokens){
  map(key) = map.getOrElse(key,0) + 1
}

println(map.mkString(","))
</code></pre>

<h2>定义一个链式哈希映射,将"Monday"映射到java.util.Calendar.MONDAY,依次类推加入其他日期。展示元素是以插入的顺序被访问的</h2>

<p>LinkedHashMap的使用</p>

<pre><code class="{.scala}">import scala.collection.mutable.LinkedHashMap
import java.util.Calendar

val map = new LinkedHashMap[String,Int]

map += ("Monday"-&gt;Calendar.MONDAY)
map += ("Tuesday"-&gt;Calendar.TUESDAY)
map += ("Wednesday"-&gt;Calendar.WEDNESDAY)
map += ("Thursday"-&gt;Calendar.THURSDAY)
map += ("Friday"-&gt;Calendar.FRIDAY)
map += ("Saturday"-&gt;Calendar.SATURDAY)
map += ("Sunday"-&gt;Calendar.SUNDAY)


println(map.mkString(","))
</code></pre>

<h2>打印出所有Java系统属性的表格，</h2>

<p>属性转scala map的使用</p>

<pre><code class="{.scala}">import scala.collection.JavaConversions.propertiesAsScalaMap

val props:scala.collection.Map[String,String] = System.getProperties()

val keys = props.keySet

val keyLengths = for( key &lt;- keys ) yield key.length

val maxKeyLength = keyLengths.max

for(key &lt;- keys) {
  print(key)
  print(" " * (maxKeyLength - key.length))
  print(" | ")
  println(props(key))
}
</code></pre>

<h2>编写一个函数minmax(values:Array[Int]),返回数组中最小值和最大值的对偶</h2>

<pre><code class="{.scala}">def minmax(values:Array[Int])={
  (values.max,values.min)
}
</code></pre>

<h2>编写一个函数Iteqgt(values:Array[int],v:Int),返回数组中小于v,等于v和大于v的数量，要求三个值一起返回</h2>

<pre><code class="{.scala}">def iteqgt(values:Array[Int],v:Int)={
  val buf = values.toBuffer
  (values.count(_ &lt; v),values.count(_ == v),values.count(_ &gt; v))
}
</code></pre>

<h2>当你将两个字符串拉链在一起，比如"Hello".zip("World")，会是什么结果？想出一个讲得通的用例</h2>

<pre><code class="{.example}">scala&gt; "Hello".zip("World")
res0: scala.collection.immutable.IndexedSeq[(Char, Char)] = Vector((H,W), (e,o), (l,r), (l,l), (o,d))
</code></pre>

<p>StringOps中的zip定义如下</p>

<pre><code class="{.example}">abstract def zip[B](that: GenIterable[B]): StringOps[(A, B)]
</code></pre>

<p>GenIterable是可遍历对象需要包含的trait，对于String来说，它是可遍历的。但是它的遍历是遍历单个字母。
所以拉链就针对每个字母来进行。</p>



    <a href="/2013/03/06/scala_exercises_04.html" class="post-categorybut">阅读全文</a>
</div>
</section>


<div class="pure-g pagination">
    
    
    <a class=" pure-u-1-2 pagination-item" href="/page/5"><p>← Newer</p></a>
    
    


    
    <a class=" pure-u-1-2 pagination-item" href="/page/7"><p>Older →</p></a>
    
</div>








                    </div>
                </div>
                <div class="footer">
                    <a href="/love/welcome-my-blog.html">About</a>
                    <a href="/1">Collecting</a>
                    <a href="tencent://message/?uin=561802774">QQ</a>
                    <a href="https://github.com/ivanpig">GitHub</a>
                    <script src="/js/min/nprogress.min.js"></script>
                    <script src="/js/index.js"></script>
                </div>
                <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

            </div>

        </div>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F2278992c92bf7ea162797e107e900616' type='text/javascript'%3E%3C/script%3E"));
</script>

    </body>

</html>
