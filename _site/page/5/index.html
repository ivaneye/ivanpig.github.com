<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="keywords" content=""/>
        <meta name="author" content="ivanpig.github.io"> 
        <link rel="canonical" href="http://ivanpig.github.io/page/5/index.html">
        <link href="http://ivanpig.github.io/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
        <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
        <title>IvanPig's Blog</title>
        <link rel="stylesheet" href="/css/min/pure-min.css">
        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
<![endif]-->
        <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
        <!--<![endif]-->

        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
<![endif]-->
        <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="/css/JekyllPure.css">
        <!--<![endif]-->

        <link href="/css/min/font-awesome.min.css" rel="stylesheet">
        <!--[if lte IE 8]>
<link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
<![endif]-->
        <script src="/js/min/jquery-1.7.2.min.js"></script>
        <link rel="stylesheet" href="/css/themes/my.css"/>
        <script src="/js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>

    <body>

        <div id="layout" class="pure-g">
            <div class="sidebar pure-u-1 pure-u-md-1-4">
                <div class="header">
                    <div class="headerpic">
                        <a href="/">
                            <img src="/img/head.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                        </a>
                    </div>
                    <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
                    <h2 id="_tagline" class="brand-tagline">IvanPig's Blog</h2>
<!--                     <br class="newline"/><br class="newline"/> -->

                    <nav class="nav">
                        <ul class="nav-list">
                            <li class="nav-item">
                                <a class="pure-button" href="/Timing">时间轴</a>
                            </li>
                            <li class="nav-item">
                                <a class="pure-button" href="/tag">标签库</a>
                            </li>
                            <li class="nav-item">
                                <a class="pure-button" href="/type">分类库</a>
                            </li>
                        </ul>
                    </nav>
                    <div class="search">
                        <form action="/search">
                            <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                        </form>
                    </div>

                    <div id="toc"></div>
                    <div id="toc1"></div>
                    <nav id="nav">
                        <ul class="nav-list">
                            <li class="nav-link">
                                <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                            </li>
                            <li class="nav-link">
                                <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                            </li>
                            <li class="nav-link">
                                <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                            </li>
                        </ul>
                    </nav>
                </div>
            </div>

            <div class="content pure-u-1 pure-u-md-3-4">
                <!--[if lt IE 8]>
<i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
<![endif]-->
                <div>
                    <div class="posts">

                        


<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/09/15/application_profile.html">Luminus手册-应用配置</a></h2>

        <p class="post-meta">By 09月15日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#luminus"><i class="fa fa-folder-open">luminus (19)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">clojure (30)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">luminus (19)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>Profiles</h1>

<p>使用lein new luminus myapp命令会创建一个新的luminus应用，它使用的是默认的配置。如果你想使用其他的特性，你可以修改相应的配置参数。</p>

<p>下面就是各个配置：</p>

<ul>
<li>+cljs - 添加ClojureScript支持</li>
<li>+cucumber - 提供通过clj-webdriver配置cucumber</li>
<li>+h2 - 添加models.db并提供H2数据库依赖</li>
<li>+postgres - 添加models.db并提供PostreSQL数据库依赖</li>
<li>+mysql - 添加models.db并提供mysql依赖</li>
<li>+mongodb - 添加db.core并提供MongoDB依赖</li>
<li>+site - 创建一个包含注册和验证框架的应用。使用bootstrap和h2</li>
<li>+dailycred -
添加dailycred支持，当和+site参数配合使用时，它使用dailycred作为验证框架</li>
<li>+http-kit - 添加HTTP Kit支持</li>
</ul>


<p>要添加配置，只需要简单的添加到你的应用的名字后面，比如:</p>

<pre><code class="{.bash}">lein new luminus myapp +cljs
</code></pre>

<p>可以多个参数一起使用:</p>

<pre><code class="{.bash}">lein new luminus myapp +site +postgres
</code></pre>

<p>如果两个参数会生成相同的文件，则后面参数所生成的文件会覆盖前面参数所生
成的文件。</p>




    <a href="/2013/09/15/application_profile.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/09/14/your_first_application.html">Luminus手册-第一个应用</a></h2>

        <p class="post-meta">By 09月14日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#luminus"><i class="fa fa-folder-open">luminus (19)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">clojure (30)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">luminus (19)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>Guestbook应用</h1>

<p>此文使用Luminus构建一个简单的guestbook应用。guestbook可以保存信息，展示信息。此应用将涉及到简单的HTML模板，数据库访问和项目结构.</p>

<h1>安装Leiningen</h1>

<p>首先你需要安装Leiningen才能使用Luminus。安装Leiningen非常的简单:</p>

<ul>
<li>下载脚本</li>
<li>将其设置为可执行权限(chmod +x lein)</li>
<li>将脚本放到你的PATH下面</li>
<li>运行lein self-install ，然后等待安装结束</li>
</ul>


<pre><code class="sh">wget https://raw.github.com/technomancy/leiningen/stable/bin/lein
chmod +x lein
mv lein ~/bin
lein self-install
</code></pre>

<h1>创建一个新应用</h1>

<p>安装完Leiningen后，你就可以在命令行中输入如下的命令</p>

<pre><code class="sh">lein new luminus guestbook +h2
cd guestbook
</code></pre>

<p>上面的命令将会创建一个使用了H2嵌入式数据库的模板项目。现在我们就可以运行这个项目了.</p>

<pre><code class="sh">lein ring server
guestbook started successfully...
2013-03-01 19:05:30.389:INFO:oejs.Server:jetty-7.6.1.v20120215
Started server on port 3000
2013-03-01 19:05:30.459:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:3000
</code></pre>

<p>浏览器会自动打开，你将能看到运行的应用。如果你不想浏览器自动打开，你可以用下面的命令来启动项目.</p>

<pre><code class="sh">lein ring server-headless
</code></pre>

<p>你也可以自定义端口号，命令如下:</p>

<pre><code class="sh">lein ring server-headless 8000
</code></pre>




    <a href="/2013/09/14/your_first_application.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/17/scala_exercises_15.html">快学Scala习题解答—第十五章 注解</a></h2>

        <p class="post-meta">By 03月17日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>注解</h1>

<h2>编写四个JUnit测试用例，分别使用带或不带某个参数的@Test注解。用JUnit执行这些测试</h2>

<pre><code class="{.scala}">import org.junit.Test

class ScalaTest {

  @Test
  def test1(){
    print("test1")
  }

  @Test(timeout = 1L)
  def test2(){
    print("test2")
  }
}
</code></pre>

<h2>创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。</h2>

<pre><code class="{.scala}">@deprecated
class Test{

  @deprecated
  val t = _;

  @deprecated(message = "unuse")
  def hello(){
    println("hello")
  }
}

@deprecated
object Test extends App{
  val t = new Test()
  t.hello()
  t.t
}
</code></pre>

<h2>Scala类库中的哪些注解用到了元注解@param,@field,@getter,@setter,@beanGetter或@beanSetter?</h2>

<p>看Scala注解的源码就OK了</p>

<h2>编写一个Scala方法sum,带有可变长度的整型参数，返回所有参数之和。从Java调用该方法。</h2>

<pre><code class="{.scala}">import annotation.varargs

class Test{

  @varargs
  def sum(n : Int*)={
    n.sum
  }
}
</code></pre>

<pre><code class="{.java}">public class Hello {

    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.sum(1,2,3));
    }
}
</code></pre>

<h2>编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法。</h2>

<pre><code class="{.scala}">import io.Source

class Test{

  def read()={
    Source.fromFile("test.txt").mkString
  }
}
</code></pre>

<pre><code class="{.java}">public class Hello {
    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.read());
    }
}
</code></pre>

<h2>编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true，打印消息，然后退出。而另一个线程不停的检查该字段是否为true。如果是，它将打印一个消息并退出。如果不是，则它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？</h2>

<p>这里只有一个线程修改Boolean字段，所以字段是否为volatile应该是没有区别的</p>

<pre><code class="{.scala}">import scala.actors.Actor

class T1(obj:Obj) extends Actor{
  def act() {
    println("T1 is waiting")
    Thread.sleep(5000)
    obj.flag = true
    println("T1 set flag = true")
  }
}

class T2(obj:Obj) extends Actor{
  def act() {
    var f = true
    while (f){
      if(obj.flag){
        println("T2 is end")
        f = false
      }else{
        println("T2 is waiting")
        Thread.sleep(1000)
      }
    }
  }
}

class Obj{
//  @volatile
  var flag : Boolean = false
}

object Test{
  def main(args: Array[String]) {
    val obj = new Obj()
    val t1 = new T1(obj)
    val t2 = new T2(obj)
    t1.start()
    t2.start()
  }
}
</code></pre>

<h2>给出一个示例，展示如果方法可被重写，则尾递归优化为非法</h2>

<pre><code class="{.scala}">import annotation.tailrec

class Test{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }
}
</code></pre>

<p>编译报错,修改如下</p>

<pre><code class="{.scala}">import annotation.tailrec

object Test extends App{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }

  println(sum2(1 to 1000000,0))
}
</code></pre>

<h2>将allDifferent方法添加到对象，编译并检查字节码。@specialized注解产生了哪些方法?</h2>

<pre><code class="{.scala}">object Test{
  def allDifferent[@specialized T](x:T,y:T,z:T) = x != y &amp;&amp; x!= z &amp;&amp; y != z
}
</code></pre>

<p>javap Test$得到</p>

<h1>+begin_src java</h1>

<p>public final class Test$ extends java.lang.Object{ public static final
Test\$ MODULE\$; public static {}; public boolean
allDifferent(java.lang.Object, java.lang.Object, java.lang.Ob ject);
public boolean allDifferent\$mZc\$sp(boolean, boolean, boolean); public
boolean allDifferent\$mBc\$sp(byte, byte, byte); public boolean
allDifferent\$mCc\$sp(char, char, char); public boolean
allDifferent\$mDc\$sp(double, double, double); public boolean
allDifferent\$mFc\$sp(float, float, float); public boolean
allDifferent\$mIc\$sp(int, int, int); public boolean
allDifferent\$mJc\$sp(long, long, long); public boolean
allDifferent\$mSc\$sp(short, short, short); public boolean
allDifferent\$mVc\$sp(scala.runtime.BoxedUnit, scala.runtime.Bo xedUnit,
scala.runtime.BoxedUnit); }</p>

<p>#+end~src~</p>

<h2>Range.foreach方法被注解为@specialized(Unit)。为什么？通过以下命令检查字节码:</h2>

<pre><code class="{.example}">javap -classpath /path/to/scala/lib/scala-library.jar scala.collection.immutable.Range
</code></pre>

<p>并考虑Function1上的@specialized注解。点击Scaladoc中的Function1.scala链接进行查看
首先来看Function1的源码</p>

<pre><code class="{.scala}">......
trait Function1[@specialized(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/) -T1, @specialized(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/) +R] extends AnyRef { self =&gt;
  /** Apply the body of this function to the argument.
   *  @return   the result of function application.
   */
  def apply(v1: T1): R
......
</code></pre>

<p>可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double
再来看Range.foreach的源码</p>

<pre><code class="{.scala}">......
@inline final override def foreach[@specialized(Unit) U](f: Int =&gt; U) {
    if (validateRangeBoundaries(f)) {
      var i = start
      val terminal = terminalElement
      val step = this.step
      while (i != terminal) {
        f(i)
        i += step
      }
    }
  }
......
</code></pre>

<p>首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double
如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值</p>

<h2>添加assert(n >= 0)到factorial方法。在启用断言的情况下编译并校验factorial(-1)会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用</h2>

<pre><code class="{.scala}">object Test {
  def factorial(n: Int): Int = {
    assert(n &gt; 0)
    n
  }

  def main(args: Array[String]) {
    factorial(-1)
  }
}
</code></pre>

<p>编译报错</p>

<pre><code class="{.example}">Exception in thread "main" java.lang.AssertionError: assertion failed
    at scala.Predef$.assert(Predef.scala:165)
    at Test$.factorial(Test.scala:6)
    at Test$.main(Test.scala:11)
    at Test.main(Test.scala)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
</code></pre>

<p>禁用assert</p>

<pre><code class="{.example}">-Xelide-below 2011
</code></pre>

<p>反编译此类javap -c Test\$ 得到</p>

<pre><code class="{.java}">......
public int factorial(int);
  Code:
   0:   getstatic       #19; //Field scala/Predef$.MODULE$:Lscala/Predef$;
   3:   iload_1
   4:   iconst_0
   5:   if_icmple       12
   8:   iconst_1
   9:   goto    13
   12:  iconst_0
   13:  invokevirtual   #23; //Method scala/Predef$.assert:(Z)V
   16:  iload_1
   17:  ireturn
......
</code></pre>



    <a href="/2013/03/17/scala_exercises_15.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/16/scala_exercises_14.html">快学Scala习题解答—第十四章 模式匹配和样例类</a></h2>

        <p class="post-meta">By 03月16日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>模式匹配和样例类</h1>

<h2>JDK发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签(用正则表达式case [^:]+:)。然后查找以//开头并包含[Ff]alls?thr的注释，捕获类似// Falls through或// just fall thru这样的注释。假定JDK的程序员们遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？</h2>

<p>没读懂题意。。。。</p>

<h2>利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶</h2>

<pre><code class="{.scala}">def swap[S,T](tup: (S,T)) = {
    tup match {
        case (a ,b) =&gt; (b,a)
    }
}

println(swap[String,Int](("1",2)))
</code></pre>

<h2>利用模式匹配，编写一个swap函数，交换数组中的前两个元素的位置，前提条件是数组长度至少为2</h2>

<pre><code class="{.scala}">def swap(arr: Array[String]) = {
  arr match {
    case Array(a,b, ar @ _*) =&gt; Array(b,a) ++ ar
    case _ =&gt; arr
  }
}

println(swap(Array("1","2","3","4")).mkString)
</code></pre>

<h2>添加一个样例类Multiple，作为Item的子类。举例来说，Multiple(10,Article("Blackwell Toster",29.95))描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item，无论是Bundle还是另一个Multiple。扩展price函数以应对新的样例。</h2>

<pre><code class="{.scala}">abstract class Item

case class Multiple(num : Int,item : Item) extends Item

case class Article(description : String , price : Double) extends Item
case class Bundle(description : String , discount : Double , item : Item*) extends Item

object Test extends App{

  def price(it : Item) : Double = it match {
      case Article(_,p) =&gt; p
      case Bundle(_,disc,its @ _*) =&gt; its.map(price _).sum - disc
      case Multiple(n,it) =&gt; n * price(it)
  }

  val p = price(Multiple(10,Article("Blackwell Toster",29.95)))
  println(p)
}
</code></pre>

<h2>我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5))描述的是如下这样一棵树:</h2>

<pre><code class="{.example}">      *
    / | \
   *  2  *
 /  \    |
3   8    5
</code></pre>

<p>不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。</p>

<pre><code class="{.scala}">val l: List[Any] = List(List(3, 8), 2, List(5))

def leafSum(list: List[Any]): Int = {

  var total = 0

  list.foreach {
    lst =&gt;
      lst match {
        case l: List[Any] =&gt; total += leafSum(l)
        case i: Int =&gt; total += i
      }
  }
  total
}

println(leafSum(l))
</code></pre>

<h2>制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。</h2>

<pre><code class="{.scala}">sealed abstract class BinaryTree
case class Leaf(value : Int) extends BinaryTree
case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree
</code></pre>

<p>编写一个函数计算所有叶子节点中的元素之和。</p>

<pre><code class="{.scala}">sealed abstract class BinaryTree
case class Leaf(value : Int) extends BinaryTree
case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree

val r = Node(Leaf(3),Node(Leaf(3),Leaf(9)))

def leafSum(tree: BinaryTree): Int = {

      tree match {
        case Node(a,b) =&gt; leafSum(a) + leafSum(b)
        case Leaf(v) =&gt; v
      }

}

println(leafSum(r))
</code></pre>

<h2>扩展前一个练习中的树，使得每个节点可以有任意多的后代，并重新实现leafSum函数。第五题中的树应该能够通过下述代码表示：</h2>

<pre><code class="{.scala}">Node(Node(Leaf(3),Leaf(8)),Leaf(2),Node(Leaf(5)))
</code></pre>

<pre><code class="{.scala}">sealed abstract class BinaryTree
case class Leaf(value: Int) extends BinaryTree
case class Node(tr: BinaryTree*) extends BinaryTree

object Test extends App {

  val r = Node(Node(Leaf(3), Leaf(8)), Leaf(2), Node(Leaf(5)))

  def leafSum(tree: BinaryTree): Int = {
    tree match {
      case Node(r @ _*) =&gt; r.map(leafSum).sum
      case Leaf(v) =&gt; v
    }
  }

  println(leafSum(r))

}
</code></pre>

<h2>扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：</h2>

<pre><code class="{.example}">      +
    / | \
   *  2  -
 /  \    |
3   8    5
</code></pre>

<p>上面这棵树的值为(3 * 8) + 2 + (-5) = 21</p>

<pre><code class="{.scala}">sealed abstract class BinaryTree
case class Leaf(value: Int) extends BinaryTree
case class Node(ch : Char , tr: BinaryTree*) extends BinaryTree

object Test extends App {

  val r = Node('+' , Node('*',Leaf(3), Leaf(8)), Leaf(2), Node('-' , Leaf(5)))


  def eval(tree: BinaryTree): Int = {
    tree match {
      case Node(c : Char , r @ _*) =&gt; if( c == '+') r.map(eval).sum else if (c == '*') r.map(eval).reduceLeft(_ * _) else r.map(eval).foldLeft(0)(_ - _)
      case Leaf(v) =&gt; v
    }
  }

println(eval(r))

}
</code></pre>

<h2>编写一个函数，计算List[Option[Int]]中所有非None值之和。不得使用match语句。</h2>

<pre><code class="{.scala}">val l : List[Option[Int]] = List(Option(-1),None,Option(2))
println(l.map(_.getOrElse(0)).sum)
</code></pre>

<h2>编写一个函数，将两个类型为Double=>Option[Double]的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：</h2>

<pre><code class="{.scala}">def f(x : Double) = if ( x &gt;= 0) Some(sqrt(x)) else None
def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None
val h = compose(f,g)
</code></pre>

<p>h(2)将得到Some(1)，而h(1)和h(0)将得到None</p>

<pre><code class="{.scala}">import scala.math.sqrt

def f(x : Double) = if ( x &gt;= 0) Some(sqrt(x)) else None
def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None
val h = compose(f,g)

def compose(f : (Double =&gt; Option[Double]), g : (Double =&gt; Option[Double])):(Double =&gt; Option[Double])={
  (x : Double) =&gt;
    if (f(x) == None || g(x) == None) None
    else g(x)
}

println(h(2))
</code></pre>



    <a href="/2013/03/16/scala_exercises_14.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/15/scala_exercises_13.html">快学Scala习题解答—第十三章 集合</a></h2>

        <p class="post-meta">By 03月15日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>集合</h1>

<h2>编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说：indexes("Mississippi")应返回一个映射，让'M'对应集{0}，'i'对应集{1,4,7,10}，依此类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？</h2>

<p>更新scala到版本2.10.0。有可变的可排序的Set，实际上还是TreeSet</p>

<pre><code class="{.scala}">import collection.mutable.{Map,HashMap,SortedSet}

def indexs(str:String):Map[Char,SortedSet[Int]]={
  var map = new HashMap[Char, SortedSet[Int]]();
  var i = 0;
  str.foreach{
    c=&gt;
      map.get(c) match{
        case Some(result) =&gt; map(c) = result + i
        case None =&gt; map += (c-&gt; SortedSet{i})
      }
      i += 1
  }
  map
}

println(indexs("Mississippi"))
</code></pre>

<h2>重复前一个练习，这次用字符到列表的不可变映射。</h2>

<pre><code class="{.scala}">import collection.immutable.HashMap
import collection.mutable.ListBuffer

def indexs(str:String):Map[Char,ListBuffer[Int]]={
  var map = new HashMap[Char, ListBuffer[Int]]()
  var i = 0
  str.foreach{
    c=&gt;
      map.get(c) match{
        case Some(result) =&gt; result += i
        case None =&gt; map += (c-&gt; ListBuffer{i})
      }
      i += 1
  }
  map
}

println(indexs("Mississippi"))
</code></pre>

<h2>编写一个函数，从一个整型链表中去除所有的零值。</h2>

<pre><code class="{.scala}">def removeZero(nums : List[Int]):List[Int]={
  nums.filter(_ != 0)
}

println(removeZero(List(3,5,0,2,7,0)))
</code></pre>

<h2>编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。返回整型的集合，其值为能和集合中某个字符串相对应的映射的值。举例来说，给定Array("Tom","Fred","Harry")和Map("Tom"->3,"Dick"->4,"Harry"->5)，返回Array(3,5)。提示：用flatMap将get返回的Option值组合在一起</h2>

<pre><code class="{.scala}">def strMap(strArr : Array[String],map : Map[String,Int]) : Array[Int] = {
  strArr.flatMap(map.get(_))
}

val a = Array("Tom","Fred","Harry")
val m = Map("Tom"-&gt;3,"Dick"-&gt;4,"Harry"-&gt;5)
println(strMap(a,m).mkString(","))
</code></pre>

<h2>实现一个函数，作用与mkString相同，使用reduceLeft。</h2>

<pre><code class="{.scala}">import collection.mutable

trait MyMkString{
  this:mutable.Iterable[String]=&gt;
  def myMkString = if( this != Nil) this.reduceLeft(_ + _)
}

var a = new mutable.HashSet[String] with MyMkString

a += "1"
a += "2"
a += "3"

println(a.myMkString)
</code></pre>

<h2>给定整型列表lst,(lst : List<a href="">Int</a>)(_ :: _ )得到什么?(List<a href="">Int</a> /: lst)(_ :+ _)又得到什么？如何修改它们中的一个，以对原列表进行反向排序？</h2>

<p>得到的结果和lst相同</p>

<pre><code class="{.scala}">val lst = List(1,2,3,4,5)

println((lst :\ List[Int]())(_ :: _))

println((List[Int]() /: lst)((a,b) =&gt; b :: a))
</code></pre>

<h2>在13.11节中，表达式(prices zip quantities) map { p => p._1 * p._2}有些不够优雅。我们不能用(prices zip quantities) map { _ * _}，因为 _ * _ 是一个带两个参数的函数，而我们需要的是一个带单个类型为元组的参数的函数，Function对象的tupled方法可以将带两个参数的函数改为以元俎为参数的函数。将tupled应用于乘法函数，以使我们可以用它来映射由对偶组成的列表。</h2>

<pre><code class="{.scala}">val prices = List(5.0,20.0,9.95)
val quantities = List(10,2,1)

println((prices zip quantities) map { Function.tupled(_ * _) })
</code></pre>

<h2>编写一个函数。将Double数组转换成二维数组。传入列数作为参数。举例来说，Array(1,2,3,4,5,6)和三列，返回Array(Array(1,2,3),Array(4,5,6))。用grouped方法。</h2>

<pre><code class="{.scala}">def divArr(arr:Array[Double],i:Int)={
  arr.grouped(i).toArray
}

val arr = Array(1.0,2,3,4,5,6)

divArr(arr,3).foreach(a =&gt; println(a.mkString(",")))
</code></pre>

<h2>Harry Hacker写了一个从命令行接受一系列文件名的程序。对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：</h2>

<pre><code class="{.scala}">val frequencies = new scala.collection.multable.HashMap[Char,Int]
                  with scala.collection.mutable.SynchronizedMap[Char,Int]
</code></pre>

<p>当读到字母c时，他调用</p>

<pre><code class="{.scala}">frequencies(c) = frequencies.getOrElse(c,0) + 1
</code></pre>

<p>为什么这样做得不到正确答案？如果他用如下方式实现呢：</p>

<pre><code class="{.scala}">import scala.collection.JavaConversions.asScalaConcurrentMap
val frequencies:scala.collection.mutable.ConcurrentMap[Char,Int] =
               new java.util.concurrent.ConcurrentHashMap[Char,Int]
</code></pre>

<p>并发问题，并发修改集合不安全.修改后的代码和修改前的代码没有什么太大的区别.</p>

<h2>Harry Hacker把文件读取到字符串中，然后想对字符串的不同部分用并行集合来并发地更新字母出现频率映射。他用了如下代码：</h2>

<pre><code class="{.scala}">val frequencies = new scala.collection.mutable.HashMap[Char,Int]
for(c &lt;- str.par) frequencies(c) = frequencies.getOrElse(c,0) + 1
</code></pre>

<p>为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate）
并行修改共享变量，结果无法估计。</p>

<pre><code class="{.scala}">
import scala.collection.immutable.HashMap

val str = "abcabcac"

val frequencies = str.par.aggregate(HashMap[Char,Int]())(
    {
        (a,b) =&gt;
        a + (b -&gt; (a.getOrElse(b,0) + 1))
    }
    ,
    {
    (map1,map2) =&gt;
    (map1.keySet ++ map2.keySet).foldLeft( HashMap[Char,Int]() ) {
         (result,k) =&gt;
           result + ( k -&gt; ( map1.getOrElse(k,0 ) + map2.getOrElse(k,0) ) )
       }
    }
)

println(frequencies)
</code></pre>



    <a href="/2013/03/15/scala_exercises_13.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/14/scala_exercises_12.html">快学Scala习题解答—第十二章 高阶函数</a></h2>

        <p class="post-meta">By 03月14日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>高阶函数</h1>

<h2>编写函数values(fun:(Int)=>Int,low:Int,high:Int),该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=>x*x,-5,5)应该产出一个对偶的集合(-5,25),(-4,16),(-3,9),...,(5,25)</h2>

<pre><code class="{.scala}">object Test extends App {
  def values(fun: (Int) =&gt; Int, low: Int, high: Int) = {
    var arr = List[(Int,Int)]()
    low to high foreach {
      num =&gt;
      arr = (num, fun(num)) :: arr
    }
    arr
  }

  println(values(x =&gt; x * x, -5, 5).mkString)
}
</code></pre>

<h2>如何用reduceLeft得到数组中的最大元素?</h2>

<pre><code class="{.scala}">object Test extends App {
  val arr = Array(3,2,6,8,4,6,9,3,6,7,1,2)
  print(arr.reduceLeft((a,b)=&gt;if (a&gt;b) a else b))
}
</code></pre>

<h2>用to和reduceLeft实现阶乘函数,不得使用循环或递归</h2>

<pre><code class="{.scala}">println(1 to 10 reduceLeft(_ * _))
</code></pre>

<h2>前一个实现需要处理一个特殊情况，即n\&lt;1的情况。展示如何用foldLeft来避免这个需要。</h2>

<pre><code class="{.scala}">println((1 to -10).foldLeft(1)(_ * _))
</code></pre>

<h2>编写函数largest(fun:(Int)=>Int,inputs:Seq[Int]),输出在给定输入序列中给定函数的最大值。举例来说，largest(x=>10*x-x*x,1 to 10)应该返回25.不得使用循环或递归</h2>

<pre><code class="{.scala}">object Test extends App {

  def largest(fun:(Int)=&gt;Int,inputs:Seq[Int])={
    val s = inputs.reduceLeft((a,b)=&gt;if (fun(a) &gt; fun(b)) a else b)
    fun(s)
  }

  println(largest(x=&gt;10*x-x*x,1 to 10))
}
</code></pre>

<h2>修改前一个函数，返回最大的输出对应的输入。举例来说,largestAt(fun:(Int)=>Int,inputs:Seq[Int])应该返回5。不得使用循环或递归</h2>

<pre><code class="{.scala}">object Test extends App {

  def largest(fun:(Int)=&gt;Int,inputs:Seq[Int])={
    inputs.reduceLeft((a,b)=&gt;if (fun(a) &gt; fun(b)) a else b)
  }

  println(largest(x=&gt;10*x-x*x,1 to 10))
}
</code></pre>

<h2>要得到一个序列的对偶很容易，比如:</h2>

<pre><code class="{.scala}">val pairs = (1 to 10) zip (11 to 20)
</code></pre>

<p>假定你想要对这个序列做某中操作---比如，给对偶中的值求和，但是你不能直接使用:</p>

<pre><code class="{.scala}">pairs.map(_ + _)
</code></pre>

<p>函数_ + _
接受两个Int作为参数，而不是(Int,Int)对偶。编写函数adjustToPair,该函数接受一个类型为(Int,Int)=>Int的函数作为参数，并返回一个等效的,
可以以对偶作为参数的函数。举例来说就是:adjustToPair(_ *
_)((6,7))应得到42。然后用这个函数通过map计算出各个对偶的元素之和</p>

<pre><code class="{.scala}">object Test extends App {

  var list = List[Int]()

  def adjustToPair(fun:(Int,Int)=&gt;Int)(tup:(Int, Int))={
     list = fun(tup._1,tup._2) :: list
     this
  }

  def map(fun:(Int,Int)=&gt;Int):Int={
    list.reduceLeft(fun)
  }

  val pairs = (1 to 10) zip (11 to 20)
  for ((a,b) &lt;- pairs){
    adjustToPair(_ * _)((a,b))
  }
  println(map(_ + _))
}
</code></pre>

<h2>在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个对该方法的调用，让它帮我们判断某个字符串数组里的所有元素的长度是否和某个给定的整数数组相对应</h2>

<pre><code class="{.scala}">object Test extends App {

  val a = Array("asd","df","aadc")
  val b = Array(3,2,4)
  val c = Array(3,2,1)

  println(a.corresponds(b)(_.length == _))
  println(a.corresponds(c)(_.length == _))
}
</code></pre>

<h2>不使用柯里化实现corresponds。然后尝试从前一个练习的代码来调用。你遇到了什么问题？</h2>

<p>没有柯里化则不能使用前一个练习里的代码方式来调用</p>

<h2>实现一个unless控制抽象，工作机制类似if,但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？</h2>

<pre><code class="{.scala}">object Test extends App {

  def unless(condition: =&gt;Boolean)(block: =&gt;Unit){
    if (!condition){
      block
    }
  }

  var x = 10
  unless(x == 0){
    x -= 1
    println(x)
  }
}
</code></pre>

<p>需要换名和柯里化</p>



    <a href="/2013/03/14/scala_exercises_12.html" class="post-categorybut">阅读全文</a>
</div>
</section>




<section class="post">
    <header class="post-header">
        
        <img class="post-avatar" height="48" width="48"
             src="/img/head.jpg">
        

        <h2 class="post-title"><a href="/2013/03/13/scala_exercises_11.html">快学Scala习题解答—第十一章 操作符</a></h2>

        <p class="post-meta">By 03月13日  2013
            
            
            
            
            <a class="post-categorybut " href="/type/#scala"><i class="fa fa-folder-open">scala (15)</i></a>
            
            
            

            
            
            
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">java (15)</i></a>
            
            <a class="post-category " href="/tag/#"><i class="fa fa-tags">scala (15)</i></a>
            
            
        
        

    </p>
</header>

<div class="post-description">
    <h1>操作符</h1>

<h2>根据优先级规则,3 + 4 -> 5和3 -> 4 + 5是如何被求值的？</h2>

<p>在REPL中执行即可得到结果。都是从左至右执行</p>

<h2>BigInt类有一个pow方法,但没有用操作符字符。Scala类库的设计者为什么没有选用**(像Fortran那样)或者^(像Pascal那样)作为乘方操作符呢？</h2>

<p>Scala中的操作符就是方法，其优先级是根据首字母来判断的，优先级如下</p>

<pre><code class="{.example}">最高优先级:除以下字符外的操作符字符
 * / %
+ -
:
= !
&lt; &gt;
&amp;
ˆ
|
非操作符
最低优先级:赋值操作符
</code></pre>

<p>一般乘方的操作符是优于乘法操作的，如果使用**作为乘方的话，那么其优先级则与*相同，而如果使用^<em>的</em>话，则优先级低于*操作。优先级都是有问题的。故没有使用这两种操作符</p>

<h2>实现Fraction类，支持+~*~/操作。支持约分，例如将15/-6变为-5/2。除以最大公约数,像这样:</h2>

<pre><code class="{.scala}">class Fraction(n:Int,d:Int){
    private val num:Int = if(d==0) 1 else n * sign(d)/gcd(n,d);
    private val den:Int = if(d==0) 0 else d * sign(d)/gcd(n,d);
    override def toString = num + "/" + den
    def sign(a:Int) = if(a &gt; 0) 1 else if (a &lt; 0) -1 else 0
    def gcd(a:Int,b:Int):Int = if(b==0) abs(a) else gcd(b,a%b)
    ...
}
</code></pre>

<pre><code class="{.scala}">import scala.math.abs

class Fraction(n: Int, d: Int) {
  private val num: Int = if (d == 0) 1 else n * sign(d) / gcd(n, d);
  private val den: Int = if (d == 0) 0 else d * sign(d) / gcd(n, d);

  override def toString = num + "/" + den

  def sign(a: Int) = if (a &gt; 0) 1 else if (a &lt; 0) -1 else 0

  def gcd(a: Int, b: Int): Int = if (b == 0) abs(a) else gcd(b, a % b)

  def +(other:Fraction):Fraction={
    newFrac((this.num * other.den) + (other.num * this.den),this.den * other.den)
  }

  def -(other:Fraction):Fraction={
    newFrac((this.num * other.den) - (other.num * this.den),this.den * other.den)
  }

  def *(other:Fraction):Fraction={
    newFrac(this.num * other.num,this.den * other.den)
  }

  def /(other:Fraction):Fraction={
    newFrac(this.num * other.den,this.den * other.num)
  }

  private def newFrac(a:Int,b:Int):Fraction={
    val x:Int = if (b == 0) 1 else a * sign(b) / gcd(a, b);
    val y:Int = if (b == 0) 0 else b * sign(b) / gcd(a, b);
    new Fraction(x,y)
  }
}

object Test extends App{
  val f = new Fraction(15,-6)
  val p = new Fraction(20,60)
  println(f)
  println(p)
  println(f + p)
  println(f - p)
  println(f * p)
  println(f / p)
}
</code></pre>

<h2>实现一个Money类,加入美元和美分字段。提供+,-操作符以及比较操作符==和\&lt;。举例来说，Money(1,75)+Money(0,50)==Money(2,25)应为true。你应该同时提供*和/操作符吗？为什么？</h2>

<pre><code class="{.scala}">
class Money(val dollar:BigInt,val cent:BigInt){

  def +(other:Money):Money={
    val (a,b) = (this.cent + other.cent) /% 100
    new Money(this.dollar + other.dollar + a,b)
  }

  def -(other:Money):Money={
    val (d,c) = (this.toCent() - other.toCent()) /% 100
    new Money(d,c)
  }

  private def toCent()={
    this.dollar * 100 + this.cent
  }

  def ==(other:Money):Boolean = this.dollar == other.dollar &amp;&amp; this.cent == other.cent

  def &lt;(other:Money):Boolean = this.dollar &lt; other.dollar || (this.dollar == other.dollar &amp;&amp; this.cent &lt; other.cent)

  override def toString = "dollar = " + dollar + " cent = " + cent
}

object Money{
  def apply(dollar:Int,cent:Int):Money={
    new Money(dollar,cent)
  }

  def main(args:Array[String]){

    val m1 = Money(1,200)
    val m2 = Money(2,2)
    println(m1 + m2)
    println(m1 - m2)
    println(m1 == m2)
    println(m1 &lt; m2)
    println(Money(1,75)+Money(0,50))
    println(Money(1,75)+Money(0,50)==Money(2,25))

  }
}
</code></pre>

<p>不需要提供*和/操作。对于金额来说没有乘除操作</p>

<h2>提供操作符用于构造HTML表格。例如:Table() | "Java" | "Scala" || "Gosling" | "Odersky" || "JVM" | "JVM,.NET"应产出:\&lt;table>\&lt;tr>\&lt;td>Java\&lt;/td>\&lt;/tr>\&lt;td>Scala\&lt;/td>\&lt;/tr>\&lt;tr>\&lt;td>Gosling...</h2>

<pre><code class="{.scala}">class Table{

  var s:String = ""

  def |(str:String):Table={
    val t = Table()
    t.s = this.s + "&lt;td&gt;" + str + "&lt;/td&gt;"
    t
  }

  def ||(str:String):Table={
    val t = Table()
    t.s = this.s + "&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;" + str + "&lt;/td&gt;"
    t
  }

  override def toString():String={
    "&lt;table&gt;&lt;tr&gt;" + this.s + "&lt;/tr&gt;&lt;/table&gt;"
  }
}

object Table{

  def apply():Table={
    new Table()
  }

  def main(args: Array[String]) {
    println(Table() | "Java" | "Scala" || "Gosling" | "Odersky" || "JVM" | "JVM,.NET")
  }
}
</code></pre>

<h2>提供一个ASCIIArt类，其对象包含类似这样的图形:</h2>

<pre><code class="{.example}"> /\_/\
( ' ' )
(  -  )
 | | |
(__|__)
提供将两个ASCIIArt图形横向或纵向结合的操作符。选用适当优先级的操作符命名。纵向结合的实例
 /\_/\     -----
( ' ' )  / Hello \
(  -  ) &lt;  Scala |
 | | |   \ Coder /
(__|__)    -----
</code></pre>

<pre><code class="{.scala}">import collection.mutable.ArrayBuffer

class ASCIIArt(str:String){
  val arr:ArrayBuffer[ArrayBuffer[String]] = new ArrayBuffer[ArrayBuffer[String]]()

  if (str != null &amp;&amp; !str.trim.eq("")){
    str.split("[\r\n]+").foreach{
      line =&gt;
      val s = new ArrayBuffer[String]()
      s += line
      arr += s
    }
  }

  def this(){
    this("")
  }

  def +(other:ASCIIArt):ASCIIArt={
    val art = new ASCIIArt()
    val length = if (this.arr.length &gt;= other.arr.length) this.arr.length else other.arr.length
    for(i &lt;- 0 until length){
      val s = new ArrayBuffer[String]()
      val thisArr:ArrayBuffer[String] = if (i &lt; this.arr.length) this.arr(i) else new ArrayBuffer[String]()
      val otherArr:ArrayBuffer[String] = if (i &lt; other.arr.length) other.arr(i) else new ArrayBuffer[String]()
      thisArr.foreach(s += _)
      otherArr.foreach(s += _)
      art.arr += s
    }
    art
  }

  def *(other:ASCIIArt):ASCIIArt={
    val art = new ASCIIArt()
    this.arr.foreach(art.arr += _)
    other.arr.foreach(art.arr += _)
    art
  }

  override def toString()={
    var ss:String = ""
    arr.foreach{
      ss += _.mkString(" ") + "\n"
    }
    ss
  }
}

object Test extends App{
  val a = new ASCIIArt(""" /\_/\
                         |( ' ' )
                         |(  -  )
                         | | | |
                         |(__|__)
                         |""".stripMargin)
  val b = new ASCIIArt( """    -----
                          |  / Hello \
                          | &lt;  Scala |
                          |  \ Coder /
                          |    -----
                          |""".stripMargin)
  println(a + b * b)
  println((a + b) * b)
  println(a * b)
}
</code></pre>

<h2>实现一个BigSequence类,将64个bit的序列打包在一个Long值中。提供apply和update操作来获取和设置某个具体的bit</h2>

<pre><code class="{.scala}">class BigSequence{
  var num = new Array[Int](64)

  for (i &lt;- 0 until num.length){
    num(i) = -1
  }

  def pack():Long={
    num.filter(_ &gt;= 0).mkString.toLong
  }
}

object BigSequence{

  def apply(num:Int):BigSequence={
    val b = new BigSequence
    var i = 0
    num.toString.foreach{
      n=&gt;
      b.num(i) = n.getNumericValue
      i+=1
    }
    b
  }

  def main(args: Array[String]) {
    val b = BigSequence(10100)
    println(b.pack())
  }
}
</code></pre>

<h2>提供一个Matrix类---你可以选择需要的是一个2*2的矩阵，任意大小的正方形矩阵，或m*n的矩阵。支持+和*操作。*操作应同样适用于单值，例如mat*2。单个元素可以通过mat(row,col)得到</h2>

<pre><code class="{.scala}">class Matrix(val x:Int,val y:Int){

  def +(other:Matrix):Matrix={
    Matrix(this.x + other.x,this.y + other.y)
  }

  def +(other:Int):Matrix={
    Matrix(this.x + other,this.y + other)
  }

  def *(other:Matrix):Matrix={
    Matrix(this.x * other.x,this.y * other.y)
  }

  def *(other:Int):Matrix={
    Matrix(this.x * other,this.y * other)
  }

  override def toString()={
    var str = ""
    for(i &lt;- 1 to x){
      for(j &lt;- 1 to y){
        str += "*"
      }
      str += "\n"
    }
    str
  }
}

object Matrix{
  def apply(x:Int,y:Int):Matrix= new Matrix(x,y)

  def main(args: Array[String]) {
    val m = Matrix(2,2)
    val n = Matrix(3,4)
    println(m)
    println(n)
    println(m + n)
    println()
    println(m * n)
    println()
    println(m + 2)
    println()
    println(n * 2)
    println()
  }
}
</code></pre>

<h2>为RichFile类定义unapply操作，提取文件路径，名称和扩展名。举例来说，文件/home/cay/readme.txt的路径为/home/cay,名称为readme,扩展名为txt</h2>

<pre><code class="{.scala}">class RichFile(val path:String){}

object RichFile{
  def apply(path:String):RichFile={
    new RichFile(path)
  }

  def unapply(richFile:RichFile) = {
    if(richFile.path == null){
      None
    } else {
      val reg = "([/\\w+]+)/(\\w+)\\.(\\w+)".r
      val reg(r1,r2,r3) = richFile.path
      Some((r1,r2,r3))
    }
  }

  def main(args: Array[String]) {
    val richFile = RichFile("/home/cay/readme.txt")
    val RichFile(r1,r2,r3) = richFile
    println(r1)
    println(r2)
    println(r3)
  }
}
</code></pre>

<h2>为RichFile类定义一个unapplySeq，提取所有路径段。举例来说，对于/home/cay/readme.txt，你应该产出三个路径段的序列:home,cay和readme.txt</h2>

<pre><code class="{.scala}">class RichFile(val path:String){}

object RichFile{
  def apply(path:String):RichFile={
    new RichFile(path)
  }

  def unapplySeq(richFile:RichFile):Option[Seq[String]]={
    if(richFile.path == null){
      None
    } else {
      Some(richFile.path.split("/"))
    }
  }

  def main(args: Array[String]) {
    val richFile = RichFile("/home/cay/readme.txt")
    val RichFile(r @ _*) = richFile
    println(r)
  }
}
</code></pre>



    <a href="/2013/03/13/scala_exercises_11.html" class="post-categorybut">阅读全文</a>
</div>
</section>


<div class="pure-g pagination">
    
    
    <a class=" pure-u-1-2 pagination-item" href="/page/4"><p>← Newer</p></a>
    
    


    
    <a class=" pure-u-1-2 pagination-item" href="/page/6"><p>Older →</p></a>
    
</div>








                    </div>
                </div>
                <div class="footer">
                    <a href="/love/welcome-my-blog.html">About</a>
                    <a href="/1">Collecting</a>
                    <a href="tencent://message/?uin=561802774">QQ</a>
                    <a href="https://github.com/ivanpig">GitHub</a>
                    <script src="/js/min/nprogress.min.js"></script>
                    <script src="/js/index.js"></script>
                </div>
                <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

            </div>

        </div>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F2278992c92bf7ea162797e107e900616' type='text/javascript'%3E%3C/script%3E"));
</script>

    </body>

</html>
