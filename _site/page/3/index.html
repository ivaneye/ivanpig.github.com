<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="keywords" content=""/>
    <meta name="author" content="liyouhai.com"> 
    <link rel="canonical" href="http://liyouhai.com/page/3/index.html">
    <link href="http://liyouhai.com/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
    <title>IvanPig's Blog</title>
    <link rel="stylesheet" href="/css/min/pure-min.css">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
    <!--<![endif]-->

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/JekyllPure.css">
    <!--<![endif]-->

    <link href="/css/min/font-awesome.min.css" rel="stylesheet">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
    <![endif]-->
    <script src="/js/min/jquery-1.7.2.min.js"></script>
    <!--
     /\_ \    __                         /\ \                __
     \//\ \  /\_\  __  __    ___   __  __\ \ \___      __   /\_\
       \ \ \ \/\ \/\ \/\ \  / __`\/\ \/\ \\ \  _ `\  /'__`\ \/\ \
        \_\ \_\ \ \ \ \_\ \/\ \L\ \ \ \_\ \\ \ \ \ \/\ \L\.\_\ \ \
        /\____\\ \_\/`____ \ \____/\ \____/ \ \_\ \_\ \__/.\_\\ \_\
        \/____/ \/_/`/___/> \/___/  \/___/   \/_/\/_/\/__/\/_/ \/_/
                       /\___/
                       \/__/
     图像可以到http://asciigen.com/  生成..记得翻墙才能正常生成.如不方便可以博客留言我帮你生成
     -->
</head>

<body>







<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
        <div class="header">
            <div class="headerpic">
                <a href="/">
                    <img src="/img/op.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                </a>
            </div>
            <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
            <h2 class="brand-tagline">IvanPig's Blog</h2>

            <nav class="nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a class="pure-button" href="/Timing">时间轴</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/tag">标签库</a>
                    </li>
                    <!--<li class="nav-item">
                        <a class="pure-button" href="/1">收藏站</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/1">音乐屋</a>-->

                </ul>
            </nav>
            <div class="search">
                <form action="/search">
                    <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                </form>
            </div>
            <div id="toc"></div>
            <nav id="nav">
                <ul class="nav-list">
                    <li class="nav-link">
                    <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <!--[if lt IE 8]>
        <i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
        <![endif]-->
        <div>
            <div class="posts">

                


    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b-%25e5%259f%25ba%25e6%259c%25ac%25e8%25af%25ad%25e6%25b3%2595-01.html">Clojure教程-基本语法-01</a></h2>

            <p class="post-meta">By 12月20日  2013  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 简介</a></li>
<li><a href="#sec-2">2 核心语法</a></li>
<li><a href="#sec-3">3 代码功能</a>
<ul>
<li><a href="#sec-3-1">3.1 读取简繁字典</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">简介</h2>
<div class="outline-text-2" id="text-1">
<p>学习一门语言最好的方法就是去使用它。我们就从一个小例子来学习 Clojure语法.</p>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="target">核心语法</span></h2>
<div class="outline-text-2" id="text-2">
<p>首先先来看一下Clojure的核心语法。<br />
Clojure的使用的是Lisp语法,又叫S表达式。核心语法非常的简单。但是对于熟悉c系语法(c,c++,java)的朋友来说，第一次接触会非常的不习惯。</p>
<ul>
<li>所有代码以"("开始,")"结束。即所有的代码都被()包裹
</li>
<li>"("后的第一个数据被当作函数或者宏来调用
</li>
<li>接着的数据被当作参数传递
</li>
<li>如果想原样返回数据，在"("前面添加"'"。此写法是(quote (&hellip;))的简写
</li>
</ul>
<p>以前面的hello world程序为例。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"Hello World"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
它以"("开始，后面跟的是函数println，接着空格跟的是参数"Hello World"，最后")"结尾。了解了如上规则，你就基本学会了Clojure的大部分语法。下面比较一下Clojure,Java,Python,Ruby的一些语法.</p>
<table border="1" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left" />
<col class="left" />
<col class="left" />
<col class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Clojure 表达式</th>
<th scope="col" class="left">对应的 Java 语法</th>
<th scope="col" class="left">对应的 Python 语法</th>
<th scope="col" class="left">对应的 Ruby 语法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">(not k)</td>
<td class="left">!k</td>
<td class="left">not k</td>
<td class="left">not k or !k</td>
</tr>
<tr>
<td class="left">(inc a)</td>
<td class="left">a++、++a、a += 1、a + 1<sup>a</sup></td>
<td class="left">a += 1、a + 1</td>
<td class="left">a += 1</td>
</tr>
<tr>
<td class="left">(/ (+ x y) 2)</td>
<td class="left">(x + y) / 2</td>
<td class="left">(x + y) / 2</td>
<td class="left">(x + y) / 2</td>
</tr>
<tr>
<td class="left">(instance? java. util.List al)</td>
<td class="left">al instanceof java.util.List</td>
<td class="left">isinstance(al,list)</td>
<td class="left">al.is<sub>a</sub>? Array</td>
</tr>
<tr>
<td class="left">(if (not a) (inc b) (dec b))</td>
<td class="left">!a ? b + 1 : b - 1</td>
<td class="left">b + 1 if not a else b-1</td>
<td class="left">!a ? b + 1 : b - 1</td>
</tr>
<tr>
<td class="left">(Math/pow 2 10)<sup>c</sup></td>
<td class="left">Math.pow(2, 10)</td>
<td class="left">pow(2, 10)</td>
<td class="left">2 ** 10</td>
</tr>
<tr>
<td class="left">(.someMethod someObj "foo" (.otherMethod otherObj 0))</td>
<td class="left">someObj.someMethod("foo" , otherObj.otherMethod(0))</td>
<td class="left">someObj.someMethod("foo" , otherObj.otherMethod(0))</td>
<td class="left">someObj.someMethod("foo" , otherObj.otherMethod(0))</td>
</tr>
</tbody>
</table>
<p>可以看出Clojure的语法有高度的一致性，即使你不熟悉S表达式，但是依据上面的原则，可以看懂它想表达的是一个什么意思。而对于其他三门语言，如果你没有一个个的学习相应的语法，你还是比较难理解它的意思的。
</p></div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">代码功能</h2>
<div class="outline-text-2" id="text-3">
<p>了解了核心语法，我们就可以来编写代码了。我们要编写的代码功能很简单，进行简繁翻译，其中过滤不需要翻译的文字。我们将分几步来完成:</p>
<ul>
<li>读取简繁字典
</li>
<li>进行简繁翻译
</li>
<li>读取不需要翻译的文字
</li>
<li>过滤不翻译的文字
</li>
<li>多线程执行
</li>
<li>提供给Java调用
</li>
<li>打包
</li>
</ul>
</div>
<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">读取简繁字典</h3>
<div class="outline-text-3" id="text-3-1">
<ul>
<li>语法点
<ul>
<li>查看Clojure API
</li>
<li>第一个函数的编写
</li>
<li>Namespace的引入
</li>
<li>正则表达式
</li>
<li>Clojure字面量
</li>
</ul>
</li>
</ul>
<p>
我们先看第一个功能。我们要读取简繁字典。简繁字典其实就是简繁对照的文件，我这里叫jfmap.clj<br />
格式如下:</p>
<pre class="example">万 萬 与 與 丑 醜 专 專 业 業 丛 叢 东 東 丝 絲 丢 丟 两 兩 严 嚴 丧 喪 个 個 丬 爿 
</pre>
<p>
这里只是简单的列了一点。具体内容请见附件。有了这个文件，我们如何把内容读出来呢？熟悉Java的都知道，我们要创建文件流来读取，然后要打开流，循环读取，最后关闭流，还要抓异常。很繁琐。在Clojure中如何处理呢？Clojure提供了slurp函数，可以根据提供的路径将文件内容读入。API如下:</p>
<pre class="src src-clojure">clojure.core/slurp
<span style="color: #8c8c8c;">(</span>[f &amp; opts]<span style="color: #8c8c8c;">)</span>
  <span style="color: #cb4b16;">Opens</span> a reader on f and reads all its contents, returning a string.
  <span style="color: #cb4b16;">See</span> clojure.java.io/reader for a complete list of supported arguments.
</pre>
<p>
OK。我们知道了要用什么函数。那么根据API和上面说的总规则，我们来写代码.</p>
<ul>
<li>首先是"("
</li>
<li>然后是函数名slurp
</li>
<li>空格，参数。这里是要读取的文件路径
</li>
<li>最后")"
</li>
</ul>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
你可以在REPL里面去实验这行代码的执行结果。执行此行代码，clojure会将jfmap.clj的内容以字符串的形式全部读入。接着呢？要做简繁翻译，字符串肯定不方便我们的操作。很明显map才是最适合的数据结构。那么我们如何将字符串变成map呢？<br />
我们只能求助于API了，你可以在<a href="http://clojure.github.io/clojure/api-index.html">Clojure的Index页面</a>搜索map,可以找到hash-map函数。它的API说明如下:</p>
<pre class="example">hash-map
function
Usage: (hash-map)
       (hash-map &amp; keyvals)
keyval =&gt; key val
Returns a new hash map with supplied mappings.  If any keys are
equal, they are handled as if by repeated uses of assoc.
</pre>
<p>
根据提供的映射关系返回一个新的hashmap。而这里我们是一个字符串，如何提供映射关系呢？按照空格将文字切开就行了嘛！！继续找API。Java里有split方法，Clojure里有没有相应的函数呢？试试再说。。有了！在clojure.string的Namespace<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>中，我们找到了叫split的函数！</p>
<pre class="example">split
function
Usage: (split s re)
       (split s re limit)
Splits string on a regular expression.  Optional argument limit is
the maximum number of splits. Not lazy. Returns vector of the splits.
</pre>
<p>
通过正则表达式来切割字符串。看着挺像，先用再说！我们有repl嘛！直接在repl里面输入</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
执行!Oops,报错了！</p>
<pre class="example">CompilerException java.lang.RuntimeException: Unable to resolve symbol: split in this context
</pre>
<p>
找不到split?!如果在Java中报类似的错误，你会想到什么？没有引入包阿！这里也是。在Java中会默认引入java.lang包，同理在Clojure中会引入clojure.core包。其他包则要自己引入，这里split在clojure.string包中。所以你需要引入clojure.string包。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> 'clojure.string<span style="color: #8c8c8c;">)</span>
</pre>
<p>
这也就是调用了require函数来进行引入！为什么clojure.string前面有个单引号呢？想想核心语法！这里暂不展开说！给大家留个思考题！！后续会专门对NameSpace引入做详细介绍！光引入还没用！调用代码也需要修改！</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>clojure.string/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
你可能要吐槽了！既然引入了，为什么还要加包名前缀？！我们可以和Java作个比较！如果这里是Java的话，那么我们在调用split的时候，实际上是需要一个类作为前缀的，比如StringUtils.split()!但是在clojure中并没有类的概念！包(Clojure叫NameSpace)下面只有函数，所以它使用NameSpace来确保函数的唯一性引用！<br />
当然了每次都要写这么长的NameSpace的名字也是挺烦人的。Clojure提供了简写.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> ['clojure.stirng <span style="color: #2aa198;">:as</span> 'cstr]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
:as是Keyword,是Clojure字面量的一种。它和String很类似，不过有些区别，它比String有更多的功能。下表是Clojure所包含的字面量。</p>
<table border="1" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left" />
<col class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Example(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Boolean</td>
<td class="left">true,false</td>
</tr>
<tr>
<td class="left">Character</td>
<td class="left">\a</td>
</tr>
<tr>
<td class="left">Keyword</td>
<td class="left">:tag,:doc</td>
</tr>
<tr>
<td class="left">List</td>
<td class="left">(1 2 3),(println "foo")</td>
</tr>
<tr>
<td class="left">Map</td>
<td class="left">{:name "Bill",:age 42}</td>
</tr>
<tr>
<td class="left">Nil</td>
<td class="left">nil</td>
</tr>
<tr>
<td class="left">Number</td>
<td class="left">1,4.2</td>
</tr>
<tr>
<td class="left">Set</td>
<td class="left">#{:snap :crackle :pop}</td>
</tr>
<tr>
<td class="left">String</td>
<td class="left">"hello"</td>
</tr>
<tr>
<td class="left">Symbol</td>
<td class="left">user/foo,java.lang.String</td>
</tr>
<tr>
<td class="left">Vector</td>
<td class="left">[1 2 3]</td>
</tr>
</tbody>
</table>
<p>
ok.终于得到了我们要的结果。这里的#" "是正则表达式(这是你遇到的第一个特殊语法，学习方法&mdash;死记！！)，它构建了Java中的Pattern，所以正则表达式内容和Java完全相同，这里就不废话了。你只需要记住其语法就行了。<br />
切开了字符串，我们来生成map吧！如何生成呢？你应该有答案了吧？</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">hash-map</span> <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
又报错了！</p>
<pre class="example">IllegalArgumentException No value supplied for key: ["万" "萬"]  clojure.lang.PersistentHashMap.create (PersistentHashMap.java:77)
</pre>
<p>
不合法的参数！！split得到的是个Vector([]包裹的数据结构是Vector),而hash-map要的参数类似于Java中的可变参数！如何匹配这两者呢？Clojure中提供了apply函数!API如下</p>
<pre class="src src-clojure">clojure.core/apply
<span style="color: #8c8c8c;">(</span>[f args] [f x args] [f x y args] [f x y z args] [f a b c d &amp; args]<span style="color: #8c8c8c;">)</span>
  <span style="color: #cb4b16;">Applies</span> fn f to the argument list formed by prepending intervening arguments to args.
</pre>
<p>
此函数有点特别！它的第一个参数是函数，后面是该函数所需要的参数！知道怎么调用吗？</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> hash-map <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
终于成功了！！我们看到了结果</p>
<pre class="src src-clojure">{<span style="color: #2aa198;">"&#19975;"</span> <span style="color: #2aa198;">"&#33836;"</span>}   <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">&#20197;{}&#21253;&#35065;&#30340;&#25968;&#25454;&#32467;&#26500;&#26159;map</span>
</pre>
<p>
最后呢！我们需要对jfmap.clj的内容进行处理！So easy!</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> hash-map <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">)</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
<div id="footnotes">
<h2 class="footnotes">脚注: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> Namespace和Java中的包类似，但是在Clojure中叫Namespace。这里没有将其翻<br />
译为命名空间，主要是怕有误解。</p>
</div>
</div>
</div>
</div>
</div>



            <a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b-%25e5%259f%25ba%25e6%259c%25ac%25e8%25af%25ad%25e6%25b3%2595-01.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/luminus/useful-libraries.html">Luminus手册-Useful Libraries</a></h2>

            <p class="post-meta">By 12月07日  2013  



 
<a class="post-categorybut " href="/type/#luminus"><i class="fa fa-folder-open"></i> luminus (2)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> luminus (2)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p>
Luminus的目标是从细粒度来方便你开发web应用。所以它默认包含了很多库包。<br />
包括lib-noir提供一般工具，Selmer/Hiccup提供HTML模板,Timbre提供日志功能，<br />
Tower提供国际化等等其他包。当然，还有很多的包能给web开发带来便利。这里<br />
我们列出了已经包含在Luminus中的其他包。</p>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Assets</a></li>
<li><a href="#sec-2">2 Async HTTP</a></li>
<li><a href="#sec-3">3 Authentication</a></li>
<li><a href="#sec-4">4 Caching</a></li>
<li><a href="#sec-5">5 ClojureScript</a></li>
<li><a href="#sec-6">6 Database clients</a></li>
<li><a href="#sec-7">7 Database Migrations</a></li>
<li><a href="#sec-8">8 Email Sending</a></li>
<li><a href="#sec-9">9 SVG</a></li>
<li><a href="#sec-10">10 Template Languages</a></li>
<li><a href="#sec-11">11 Web Services</a></li>
<li><a href="#sec-12">12 Miscellaneous</a></li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Assets</h2>
<div class="outline-text-2" id="text-1">
<ul>
<li><a href="https://github.com/edgecase/dieter">Dieter</a> - Asset pipeline ring middleware
</li>
</ul>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Async HTTP</h2>
<div class="outline-text-2" id="text-2">
<ul>
<li><a href="https://github.com/ztellman/aleph">Aleph</a> - Asynchronous communication
</li>
<li><a href="https://github.com/http-kit/http-kit">http-kit</a> - High-performance event-driven HTTP client/server
</li>
</ul>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Authentication</h2>
<div class="outline-text-2" id="text-3">
<ul>
<li><a href="https://github.com/cemerick/friend">Friend</a> - An extensible authentication and authorization library
</li>
<li><a href="https://github.com/brentonashworth/sandbar">Sandbar</a> - A web application library with higher level abstractions for Compojure, Ring
</li>
<li><a href="https://github.com/remvee/ring-basic-authentication">ring-basic-authentication</a> - Ring middleware to enforce basic authentication
</li>
</ul>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Caching</h2>
<div class="outline-text-2" id="text-4">
<ul>
<li><a href="https://github.com/clojurewerkz/spyglass">Spyglass</a> - A Memcached client (also: Couchbase, Kestrel)
</li>
<li><a href="https://github.com/clojure/core.cache">core.cache</a> - A caching library implementing various cache strategies
</li>
</ul>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">ClojureScript</h2>
<div class="outline-text-2" id="text-5">
<ul>
<li><a href="https://github.com/levand/domina">Domina</a> - A jQuery inspired DOM manipulation library
</li>
<li><a href="https://github.com/Prismatic/dommy">Dommy</a> - A no-nonsense templating and (soon) dom manipulation library
</li>
<li><a href="https://github.com/ckirkendall/enfocus">Enfocus</a> - DOM manipulation and templating library inspired by Enlive
</li>
<li><a href="https://github.com/ibdknox/fetch">Fetch</a> - A library for Client/Server interaction
</li>
<li><a href="https://github.com/shoreleave">Shoreleave</a> - A smarter client-side with ClojureScript
</li>
<li><a href="https://github.com/drcode/webfui">Webfui</a> - Client-Side Web Framework
</li>
<li><a href="https://github.com/drcode/webfui">Widje</a> - Templating for ClojureScript
</li>
</ul>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">Database clients</h2>
<div class="outline-text-2" id="text-6">
<ul>
<li><a href="https://github.com/aboekhoff/congomongo">CongoMongo</a> - Wrapper for the mongo-db java api
</li>
<li><a href="http://clojuremongodb.info/">Monger</a> - Monger, a client for MongoDB
</li>
<li><a href="https://github.com/clojure-clutch/clutch">Clutch</a> - A library for Apache CouchDB
</li>
<li><a href="https://github.com/michaelklishin/neocons">Neocons</a> - A feature rich idiomatic client for the Neo4J REST API
</li>
<li><a href="http://clojureriak.info/">Welle</a> - An expressive client for Riak
</li>
<li><a href="https://github.com/clojurewerkz/cassaforte">Cassaforte</a> - A young client for Apache Cassandra 1.2+
</li>
<li><a href="https://github.com/weavejester/rotary">Rotary</a> - DynamoDB API
</li>
<li><a href="https://github.com/cemerick/rummage">Rummage</a> - A client library for Amazon's SimpleDB (SDB)
</li>
<li><a href="https://github.com/ptaoussanis/carmine">Carmine</a> - Clojure Redis client &amp; message queue
</li>
</ul>
</div>
</div>
<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">Database Migrations</h2>
<div class="outline-text-2" id="text-7">
<ul>
<li><a href="https://github.com/macourtney/drift">Drift</a> - A migration library
</li>
<li><a href="http://budu.github.com/lobos/">Lobos</a> - Lobos is a library to help you create and modify database schemas
</li>
<li><a href="https://github.com/pjstadig/migratus">Migratus</a> - A general migration framework
</li>
<li><a href="https://github.com/weavejester/ragtime">Ragtime</a> - Database-independent migration library
</li>
</ul>
</div>
</div>
<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Email Sending</h2>
<div class="outline-text-2" id="text-8">
<ul>
<li><a href="https://github.com/clojurewerkz/mailer">Mailer</a> - An ActionMailer-inspired mailer library
</li>
<li><a href="https://github.com/drewr/postal">Postal</a> - Clojure email support
</li>
<li><a href="https://github.com/MayDaniel/clj-mail">clj-mail</a> - Send and receive emails from Clojure
</li>
</ul>
</div>
</div>
<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">SVG</h2>
<div class="outline-text-2" id="text-9">
<ul>
<li><a href="http://liebke.github.com/analemma/">Analemma</a> - a Clojure-based SVG DSL and charting library
</li>
</ul>
</div>
</div>
<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">Template Languages</h2>
<div class="outline-text-2" id="text-10">
<ul>
<li><a href="https://github.com/kumarshantanu/basil">Basil</a> - A general purpose template library
</li>
<li><a href="https://github.com/fhd/clostache">Clostache</a> -  for Clojure
</li>
<li><a href="https://github.com/cgrand/enlive">Enlive</a> - A selector-based (à la CSS) templating and transformation system
</li>
<li><a href="https://github.com/Flamefork/fleet">Fleet</a> - Templating System for Clojure
</li>
<li><a href="https://github.com/Raynes/laser">Laser</a> - HTML transformation/templating
</li>
<li><a href="https://github.com/davidsantiago/stencil">Stencil</a> - A fast, compliant implementation of Mustache
</li>
<li><a href="https://github.com/davidsantiago/tinsel">Tinsel</a> - Selector-based templates with Hiccup
</li>
</ul>
</div>
</div>
<div id="outline-container-11" class="outline-2">
<h2 id="sec-11">Web Services</h2>
<div class="outline-text-2" id="text-11">
<ul>
<li><a href="http://clojure-liberator.github.com/">Liberator</a> - a library for creating REST services
</li>
<li><a href="https://github.com/brehaut/necessary-evil">necessary-evil</a> - XML RPC library for Clojure
</li>
</ul>
</div>
</div>
<div id="outline-container-12" class="outline-2">
<h2 id="sec-12">Miscellaneous</h2>
<div class="outline-text-2" id="text-12">
<ul>
<li><a href="https://github.com/michaelklishin/urly">Urly</a> - a library that unifies parsing of URIs, URLs and URL-like values like relative href values
</li>
<li><a href="https://github.com/weavejester/ring-anti-forgery">ring-anti-forgery</a> - CSRF attack prevention using randomly-generated anti-forgery tokens
</li>
<li><a href="https://github.com/yogthos/clj-rss">clj-rss</a> - a library for generating RSS feeds
</li>
<li><a href="https://github.com/yogthos/clj-pdf">clj-pdf</a> - PDF report generation library
</li>
<li><a href="http://clojurevalidations.info/articles/getting_started.html">Validateur</a> - a validation library inspired by Ruby's ActiveModel
</li>
<li><a href="https://github.com/ebaxt/ring-rewrite">ring-rewrite</a> - Ring middleware for defining and applying rewrite rules
</li>
<li><a href="https://github.com/michaelklishin/pantomime">Pantomime</a> - a Library For Working With MIME Types
</li>
</ul>
<p>
为数不多的几个目录包含了很多web开发所需要的包：测试，数据验证，JSON，<br />
异常处理，SQL和其他你能在<a href="http://www.clojure-toolbox.com/">Clojure Toobox</a>,<a href="http://www.clojuresphere.com/">ClojureSphere</a>和<a href="http://clojurewerkz.org/">ClojureWerkz</a>中<br />
找到的包。</p>
</div>
</div>



            <a href="/luminus/useful-libraries.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/luminus/deployment.html">Luminus手册-Deployment</a></h2>

            <p class="post-meta">By 12月06日  2013  



 
<a class="post-categorybut " href="/type/#luminus"><i class="fa fa-folder-open"></i> luminus (2)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> luminus (2)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Running Standalone</a></li>
<li><a href="#sec-2">2 Delpoying on Immutant</a></li>
<li><a href="#sec-3">3 Deploying to Tomcat</a></li>
<li><a href="#sec-4">4 Heroku Deployment</a></li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Running Standalone</h2>
<div class="outline-text-2" id="text-1">
<p>要创建一个可独立运行的包，只需要运行如下的命令:</p>
<pre class="src src-sh">lein ring uberjar
</pre>
<p>
打包完成的jar会出现在target目录下。可以通过下面的命令运行:</p>
<pre class="src src-clojure">java -jar myapp-0.1.0-SNAPSHOT-standalone.jar
</pre>
<p>
独立可运行的程序可以使用Jetty来运行。如果要设置端口号，你需要设置$PORT<br />
环境变量:</p>
<pre class="src src-sh"><span style="color: #859900;">export</span> <span style="color: #268bd2;">PORT</span>=8080
java -jar target/myapp1-0.1.0-SNAPSHOT-standalone.jar
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Delpoying on Immutant</h2>
<div class="outline-text-2" id="text-2">
<p>如果想部署应用到Immutant，请执行如下命令:</p>
<pre class="src src-sh">lein immutant deploy
</pre>
<p>
更多信息请访问<a href="http://immutant.org/tutorials/deploying/index.html">官网</a></p>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Deploying to Tomcat</h2>
<div class="outline-text-2" id="text-3">
<p>如果想打包应用为war包:</p>
<pre class="src src-sh">lein ring uberwar 
</pre>
<p>
然后只需要将打好的包拷贝到tomcat的webapps目录下即可:</p>
<pre class="src src-sh">cp target/myapp-0.1.0-SNAPSHOT-standalone.war ~/tomcat/webapps/myapp.war
</pre>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Heroku Deployment</h2>
<div class="outline-text-2" id="text-4">
<p>首先确保你有git和Heroku，然后按照下面的步骤做就可以了。<br />
要测试你的应用是否通过foreman在本地运行，只需要执行下面的命令:</p>
<pre class="src src-sh">foreman start
</pre>
<p>
现在你能初始化你的git仓库，并提交你的应用</p>
<pre class="src src-sh">git init
git add .
git commit -m <span style="color: #2aa198;">"init"</span>
</pre>
<p>
在Heroku创建你的应用</p>
<pre class="src src-sh">heroku create
</pre>
<p>
你还可以创建数据库</p>
<pre class="src src-sh">heroku addons:add heroku-postgresql 
</pre>
<p>
连接信息可以在你的Heroku页面看到.<br />
部署应用.</p>
<pre class="src src-sh">git push heroku master
</pre>
<p>
现在你的应用就被部署到了Heroku上.<br />
具体信息请看<a href="https://devcenter.heroku.com/articles/clojure">官方文档</a></p>
</div>
</div>



            <a href="/luminus/deployment.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b-%25e7%258e%25af%25e5%25a2%2583%25e6%2590%25ad%25e5%25bb%25ba%25e4%25b8%258ehello-world-2.html">Clojure教程-环境搭建与Hello World</a></h2>

            <p class="post-meta">By 10月05日  2013  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 环境搭建</a>
<ul>
<li><a href="#sec-1-1">1.1 通过Leiningen安装</a></li>
<li><a href="#sec-1-2">1.2 手动安装</a></li>
</ul>
</li>
<li><a href="#sec-2">2 HelloWorld</a>
<ul>
<li><a href="#sec-2-1">2.1 REPL</a></li>
<li><a href="#sec-2-2">2.2 运行单个文件</a></li>
<li><a href="#sec-2-3">2.3 编辑器</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">环境搭建</h2>
<div class="outline-text-2" id="text-1">
<p>Clojure是JVM上的一种语言，其语法是Lisp格式，所以称为是JVM上的Lisp方言。<br />
所以其依赖于JDK。请确保你的机器上安装了JDK6+。Clojure的安装非常的简单。<br />
可以分为两种方式:</p>
<ul>
<li>通过Leiningen安装
</li>
<li>手动安装
</li>
</ul>
<p>通过Leiningen是比较普遍也很方便的方式。我们先通过Leiningen来安装。</p>
</div>
<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">通过Leiningen安装</h3>
<div class="outline-text-3" id="text-1-1">
<p>Leiningen和Maven比较类似，是Clojure语言的管理工具。其实它就是基于Maven<br />
构建的。我们先来安装Leiningen</p>
<ul>
<li>首先下载<a href="https://raw.github.com/technomancy/leiningen/stable/bin/lein">lein script</a>
</li>
<li>将lein script放置到你的path下(linux下直接放到用户目录下即可)，保存文<br />
  件名叫lein。
</li>
<li>将其权限设置为可执行(chmod a+x lein)
</li>
<li>打开shell，输入lein即可
</li>
</ul>
<p>leiningen会自动下载需要的依赖。运行完成后,Clojure开发环境即安装完成。</p>
</div>
</div>
<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">手动安装</h3>
<div class="outline-text-3" id="text-1-2">
<p>leiningen需要以项目为单位才能运行。比如你想运行一个hello.clj程序，如果<br />
你通过leiningen来运行，则hello.clj需要在lein项目内，且设置为core，才能<br />
运行,比较麻烦(这个问题在Maven中同样存在)。而通过手动安装可以解决这个问题。</p>
<ul>
<li>首先下载<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.5.1/clojure-1.5.1.zip">Clojure</a>, 目前稳定版本是1.5.1
</li>
<li>解压到任意位置，其中最主要的文件就是clojure-1.5.1.jar
</li>
<li>在path下编写脚本clj,输入如下内容
</li>
</ul>
<pre class="src src-sh">java -jar /home/ivan/soft/clojure-1.5.1/clojure-1.5.1.jar $<span style="color: #268bd2;">1</span>
 <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">clojure.jar&#35831;&#36755;&#20837;&#20320;&#26412;&#26426;&#30340;&#36335;&#24452;</span>
</pre>
<p>
这样就可以执行单个的Clojure文件了</p>
</div>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">HelloWorld</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">REPL</h3>
<div class="outline-text-3" id="text-2-1">
<p>老掉牙的入门程序。如果你想体验Clojure。那么只需要在Shell中运行lein<br />
repl。则会运行一个Clojure的REPL环境，你可以直接输入Clojure代码，REPL直<br />
接反馈结果。试试输入如下代码</p>
<pre class="src src-clojure"><span style="color: #7f7f7f;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"Hello World"</span><span style="color: #7f7f7f;">)</span>
</pre>
<p>
结果如图<img src="assets/wpid-repl6.png" alt="file/repl.png" /></p>
</div>
</div>
<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">运行单个文件</h3>
<div class="outline-text-3" id="text-2-2">
<p>如果你想将Clojure代码保存到文件中去运行，那么将上面的代码保存到.clj结<br />
尾的文件中，并在shell中运行如下命令即可</p>
<pre class="src src-sh">clj hello.clj
</pre>
</div>
</div>
<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">编辑器</h3>
<div class="outline-text-3" id="text-2-3">
<p>Clojure编辑器主要还是文本编辑器，比如emacs,vim等,大部分的文本编辑器都<br />
有Clojure语言的支持。IDE的话，Intellij IDEA有<br />
Clojure环境，不过速度太慢了。一般编写使用文本编辑器即可。<br />
这里使用Emacs的clojure-mode作为开发环境。界面如图<br />
<img src="assets/wpid-emacs5.png" alt="file/emacs.png" /></p>
</div>
</div>
</div>



            <a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b-%25e7%258e%25af%25e5%25a2%2583%25e6%2590%25ad%25e5%25bb%25ba%25e4%25b8%258ehello-world-2.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/java-scala/faq%25e4%25bb%2580%25e4%25b9%2588%25e6%2598%25af%25e5%2587%25bd%25e6%2595%25b0%25e5%25bc%258f%25e6%258e%25a5%25e5%258f%25a3.html">[FAQ]什么是函数式接口</a></h2>

            <p class="post-meta">By 07月03日  2013  



 
<a class="post-categorybut " href="/type/#java-scala"><i class="fa fa-folder-open"></i> java-scala (20)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> java (16)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> java8 (3)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p>
	<br />
	<span style="color:black"><span style="background-color:white"><span style="font-family:微软雅黑">一般来说，函数式接口是这样一种类型，它可以作为方法参数，而实际上真正的参数是其包含的方法。举例来说</span>,forEach<span style="font-family:微软雅黑">方法签名如下：</span></span></span></p>
<p>
	<span style="color:black; font-family:Courier New; font-size:10pt"><span style="background-color:white"><strong>public void forEach(Consumer&lt;? super T&gt; consumer); </strong></span></span></p>
<p>
	<span style="color:black"><span style="font-family:Tahoma; background-color:white">forEach</span><span style="font-family:微软雅黑; background-color:white">必须接受一个包含单个方法的</span><span style="font-family:Tahoma; background-color:white">Consumer</span><span style="font-family:微软雅黑; background-color:white">实例。这个实例可以是一个</span><span style="font-family:Tahoma; background-color:white">lambda</span><span style="font-family:微软雅黑; background-color:white">表达式。在这种情况下</span><span style="font-family:Tahoma; background-color:white">lambda</span><span style="font-family:微软雅黑"><span style="background-color:white">表达式相当于只包含一个方法的接口，因为只有一个方法，所以调用方法清楚的知道要调用哪个方法。</span></span></span></p>
<p>
	<br />
	<span style="color:black"><span style="font-family:微软雅黑; background-color:white">更精确点来说，函数式接口实际上就是只包含一个抽象方法的接口</span><span style="font-family:Tahoma; background-color:white">(</span><span style="font-family:微软雅黑; background-color:white">请记住，是抽象方法。因为在</span><span style="font-family:Tahoma; background-color:white">Java8</span><span style="font-family:微软雅黑; background-color:white">中，接口不再只包含抽象方法，还可以包含默认方法</span><span style="font-family:Tahoma; background-color:white">)</span><span style="font-family:微软雅黑; background-color:white">。这就是为什么函数式接口一般被称为单一抽象方法接口</span><span style="font-family:Tahoma; background-color:white">(SAM)</span></span></p>
<p>
	<span style="color:black; font-family:微软雅黑; font-size:14pt"><span style="background-color:white"><strong>下面是例子</strong></span></span></p>
<p>
	<br />
	<span style="color:black"><span style="font-family:微软雅黑"><span style="background-color:white">根据上面的定义，下面的接口就是函数式接口：</span></span></span></p>
<p>
	<span style="color:black; font-family:Courier New; font-size:10pt"><span style="background-color:white"><strong>public interface Runnable { void run(); }<br />
	public interface Callable&lt;V&gt; { V call() throws Exception; }<br />
	public interface ActionListener { void actionPerformed(ActionEvent e); }<br />
	public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); } </strong></span></span></p>
<p>
	<span style="color:black; font-family:微软雅黑; font-size:14pt"><span style="background-color:white"><strong>语法点</strong></span></span></p>
<ul>
<li>
		<span style="color:black"><span style="font-family:微软雅黑; background-color:white">虽然</span><span style="font-family:Courier New; background-color:white">Comparator</span><span style="font-family:微软雅黑; background-color:white">定义了两个抽象方法，但它依然是函数式接口。因为其中的一个方法</span><span style="font-family:Courier New; background-color:white">equals</span><span style="font-family:微软雅黑; background-color:white">继承自</span><span style="font-family:Courier New; background-color:white">Object</span><span style="font-family:微软雅黑; background-color:white">。继承自</span><span style="font-family:Courier New; background-color:white">Object</span><span style="font-family:微软雅黑"><span style="background-color:white">的方法不算是接口自己定义的方法。</span></span></span>
	</li>
<li>
		<span style="color:black"><span style="font-family:微软雅黑; background-color:white">当两个接口包含的类似如下的方法，情况就变得比较复杂了</span></p>
<p>		<span style="font-family:Courier New"><span style="font-size:10pt; background-color:white"><strong>interface Foo1 { void bar(List&lt;String&gt; arg); }<br />
		interface Foo2 { void bar(List arg); }</strong></span><br />
		<span style="background-color:white">Foo1</span></span><span style="font-family:微软雅黑; background-color:white">和</span><span style="font-family:Courier New; background-color:white">Foo2</span><span style="font-family:微软雅黑; background-color:white">包含的方法几乎相同，除了集合的类型。但是在</span><span style="font-family:Courier New; background-color:white">Java</span><span style="font-family:微软雅黑; background-color:white">中，泛型在编译后是被擦除的，所以在编译后，这两个方法无法区分开。这种情况称为等价重载</span><span style="font-family:Courier New; background-color:white">(override-equivalent).</span><span style="font-family:微软雅黑; background-color:white">如果一个接口的多个父接口出现等价重载的情况，那么此接口需要定义一个方法覆盖所有继承的方法。在此例中，像如下的接口就会出现等价重载</span><span style="font-family:Courier New; background-color:white">:</p>
<p>		<span style="font-size:10pt"><strong>interface Foo extends Foo1, Foo2 {}</strong></span></span><br />
		<span style="font-family:微软雅黑; font-size:10pt; background-color:white">此时方法需要定义如下：</span></p>
<p>		<span style="font-family:Courier New; font-size:10pt; background-color:white"><strong>void bar(List arg);</strong></span></span>
	</li>
</ul>
<p>
	<img alt="" src="assets/070313_1405_FAQ1.png" /></p>



            <a href="/java-scala/faq%25e4%25bb%2580%25e4%25b9%2588%25e6%2598%25af%25e5%2587%25bd%25e6%2595%25b0%25e5%25bc%258f%25e6%258e%25a5%25e5%258f%25a3.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/java-scala/faq%25e4%25b8%25ba%25e4%25bb%2580%25e4%25b9%2588%25e5%25bc%2595%25e5%2585%25a5lambda%25e8%25a1%25a8%25e8%25be%25be%25e5%25bc%258f.html">[FAQ]为什么引入lambda表达式</a></h2>

            <p class="post-meta">By 07月02日  2013  



 
<a class="post-categorybut " href="/type/#java-scala"><i class="fa fa-folder-open"></i> java-scala (20)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> java (16)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> java8 (3)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p><span style="color:black"><span style="font-family:微软雅黑">    Lambda表达式</span>(<span style="font-family:微软雅黑">闭包</span>)<span style="font-family:微软雅黑">在很多现代化的编程语言中很常见。在</span>Java<span style="font-family:微软雅黑">平台上引入</span>lambda<span style="font-family:微软雅黑">表达式的一个最主要原因是方便多线程的处理集合。目前，对于</span>list<span style="font-family:微软雅黑">和</span>set<span style="font-family:微软雅黑">等集合类典型的操作方式是使用迭代器。如果需要并行的处理集合，需要编写客户端代码来处理，而不是集合本身处理。<br />
</span></span></p>
<p><span style="color:black"><br />
			<span style="font-family:微软雅黑">在</span>Java8<span style="font-family:微软雅黑">中，引入闭包的目的就是为了给集合提供函数式的方法，方便处理。这样所带来的好处是</span>,<span style="font-family:微软雅黑">集合能够自己组织他们的元素，而不需要客户端代码来处理。但是，为了使得客户端代码能够使用这一改进，必须给集合添加函数式方法。当前通用的做法是使用匿名类。但是声明匿名类带来了过多的标准化代码。<br />
</span></span></p>
<p><span style="color:black"><br />
			<span style="font-family:微软雅黑">举例来说，</span>forEach<span style="font-family:微软雅黑">方法接受一个</span>Consumer<span style="font-family:微软雅黑">接口的实例并为每个元素调用它的</span>accept<span style="font-family:微软雅黑">方法：<br />
</span></span></p>
<p style="margin-left: 27pt"><span style="color:black; font-family:Courier New; font-size:10pt"><span style="background-color:white"><strong>interface Consumer&lt;T&gt; { void accept(T t); } </strong></span><br />
		</span></p>
<p><span style="color:black"><br />
			<span style="font-family:微软雅黑">假设我们要使用</span>forEach<span style="font-family:微软雅黑">调换</span>java.awt.Point<span style="font-family:微软雅黑">的集合的每个元素的</span>x<span style="font-family:微软雅黑">与</span>y<span style="font-family:微软雅黑">的坐标。使用</span>Consumer<span style="font-family:微软雅黑">的匿名内部类</span>,<span style="font-family:微软雅黑">我们需要编写类似如下的代码<br />
</span></span></p>
<p style="margin-left: 27pt"><span style="color:black; font-family:Courier New; font-size:10pt"><span style="background-color:white"><strong>pointList.forEach(new Consumer() { <br />    public void accept(Point p) { <br />        p.move(p.y, p.x);<br />    } <br />});</strong></span><br />
		</span></p>
<p><span style="color:black"><br />
			<span style="font-family:微软雅黑">而如果使用</span>lambda<span style="font-family:微软雅黑">表达式，我们只需要这样</span>:<span style="font-family:微软雅黑"><br />
			</span></span></p>
<p style="margin-left: 27pt"><span style="color:black; font-family:Courier New; font-size:10pt"><span style="background-color:white"><strong>pointList.forEach(p -&gt; p.move(p.y, p.x)); </strong></span><br />
		</span></p>
<p><img src="assets/070213_1251_FAQlambd1.png" alt="" /></p>



            <a href="/java-scala/faq%25e4%25b8%25ba%25e4%25bb%2580%25e4%25b9%2588%25e5%25bc%2595%25e5%2585%25a5lambda%25e8%25a1%25a8%25e8%25be%25be%25e5%25bc%258f.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/java-scala/faq%25e4%25bb%2580%25e4%25b9%2588%25e6%2598%25aflambda%25e8%25a1%25a8%25e8%25be%25be%25e5%25bc%258f.html">[FAQ]什么是lambda表达式</a></h2>

            <p class="post-meta">By 07月01日  2013  



 
<a class="post-categorybut " href="/type/#java-scala"><i class="fa fa-folder-open"></i> java-scala (20)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> java (16)</a>
 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> java8 (3)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p>
	<br />
	<span style="color:black"><span style="font-family:微软雅黑">在一般数学计算中，</span>lambda<span style="font-family:微软雅黑">表达式就是函数：根据部分或所有输入的组合，返回相应的值。</span>lambda<span style="font-family:微软雅黑">表达式作为函数式思想被引入到了</span>Java<span style="font-family:微软雅黑">中。熟悉</span>Java<span style="font-family:微软雅黑">语法的朋友可以把</span>lambda<span style="font-family:微软雅黑">表达式看做是可以接受参数，返回类型，不可修改的，语法简洁的匿名方法。</span></span></p>
<p>
	&nbsp;<br />
	&nbsp;</p>
<p>
	<span style="color:black; font-family:微软雅黑"><strong>语法：</strong></span></p>
<p>
	<span style="color:black; font-size:10pt"><span style="font-family:Courier New; background-color:white">(<em>parameters</em>) -&gt; <em>expression</em></span><br />
	<span style="font-family:微软雅黑"><span style="background-color:white"><strong>或者</strong></span></span></span></p>
<p>
	<span style="color:black; font-family:Courier New; font-size:10pt"><span style="background-color:white">(<em>parameters</em>) -&gt; { <em>statements;</em> }</span></span></p>
<p>
	&nbsp;<br />
	&nbsp;</p>
<p>
	<span style="color:black; font-family:微软雅黑; font-size:10pt"><span style="background-color:white"><strong>例子：</strong></span></span></p>
<p>
	<span style="color:black; font-size:10pt"><strong><span style="font-family:Courier New; background-color:white">1. (int x, int y) -&gt; x + y // </span><span style="font-family:微软雅黑; background-color:white">接受两个整数，并返回两数的和</span><br />
	<span style="font-family:Courier New; background-color:white">2. (x, y) -&gt; x - y // </span><span style="font-family:微软雅黑; background-color:white">接受两个数，并返回差值</span><br />
	<span style="font-family:Courier New; background-color:white">3. () -&gt; 42 // </span><span style="font-family:微软雅黑; background-color:white">不接受参数，直接返回</span><span style="font-family:Courier New; background-color:white">42<br />
	4. (String s) -&gt; System.out.println(s) // </span></strong><span style="font-family:微软雅黑"><span style="background-color:white"><strong>接受字符串，打印标准输出，没有返回值</strong></span></span></span></p>
<p>
	<span style="color:black; font-size:10pt"><strong><span style="font-family:Courier New; background-color:white">5. x -&gt; 2 * x // </span><span style="font-family:微软雅黑; background-color:white">接受数字，并返回该值的</span><span style="font-family:Courier New; background-color:white">2</span><span style="font-family:微软雅黑; background-color:white">倍</span><br />
	<span style="font-family:Courier New; background-color:white">6. c -&gt; { int s = c.size(); c.clear(); return s; } // </span></strong><span style="font-family:微软雅黑"><span style="background-color:white"><strong>接受一个集合。清空该集合，返回该集合未清空前的长度</strong></span></span></span></p>
<p>
	&nbsp;<br />
	&nbsp;</p>
<p>
	<span style="color:black; font-family:微软雅黑; font-size:10pt"><span style="background-color:white"><strong>语法注意点：</strong></span></span></p>
<ol>
<li>
		<span style="color:black; font-size:10pt"><strong><span style="font-family:微软雅黑; background-color:white">可以明确的指出参数类型（比如</span><span style="background-color:white">,1,4<span style="font-family:微软雅黑">）也可以不明确指出</span>(2,5,6).<span style="font-family:微软雅黑">在单个</span>lambda<span style="font-family:微软雅黑">表达式中，无论你明不明确指出参数类型都是没有关系的。</span></span></strong></span>
	</li>
<li>
		<span style="color:black; font-size:10pt"><strong><span style="background-color:white">lambda<span style="font-family:微软雅黑">表达式的表达式体可以是个语句块</span>(<span style="font-family:微软雅黑">被大括号包围，例如</span>:6)<span style="font-family:微软雅黑">或者是个表达式</span>(<span style="font-family:微软雅黑">例如</span>:1-5)<span style="font-family:微软雅黑">。语句块式的表达式体能返回值或者不返回。使用或省略</span>return<span style="font-family:微软雅黑">关键字的规则和普通的方法体相同。</span></span></strong></span>
	</li>
<li>
		<span style="color:black; font-size:10pt"><strong><span style="font-family:微软雅黑; background-color:white">如果表达式体是个表达式，那么它也可以返回值</span><span style="background-color:white">(<span style="font-family:微软雅黑">例如</span>:1,2,3,5)<span style="font-family:微软雅黑">，也可以不返回</span>(<span style="font-family:微软雅黑">例如</span>:4)</span></strong></span>
	</li>
<li>
		<span style="color:black; font-size:10pt"><strong><span style="font-family:微软雅黑; background-color:white">如果表达式只有一个参数那么括号可以省略</span><span style="background-color:white">(<span style="font-family:微软雅黑">例如</span>:5,6)</span></strong></span>
	</li>
<li>
		<span style="color:black; font-size:10pt"><strong><span style="font-family:微软雅黑; background-color:white">例子</span><span style="background-color:white">6<span style="font-family:微软雅黑">后的注释说此</span>lambda<span style="font-family:微软雅黑">表达式需要一个集合作为参数。而实际上，根据上下文环境的不同，此表达式不限于集合参数，只要参数包含</span>size<span style="font-family:微软雅黑">方法和</span>clear<span style="font-family:微软雅黑">方法，并且接受合适的参数且返回合适的类型即可。</span></span></strong></span>
	</li>
</ol>
<p>
	<span style="color:black; font-family:微软雅黑; font-size:10pt">&nbsp;</span><img src="assets/5f547f627dde99bf9f86e1d6716d7401.png" /><br />
	&nbsp;</p>



            <a href="/java-scala/faq%25e4%25bb%2580%25e4%25b9%2588%25e6%2598%25aflambda%25e8%25a1%25a8%25e8%25be%25be%25e5%25bc%258f.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>


<div class="pure-g pagination">
    
    
    <a class=" pure-u-1-2 pagination-item" href="/page/2"><p>← Newer</p></a>
    
    


    
    <a class=" pure-u-1-2 pagination-item" href="/page/4"><p>Older →</p></a>
    
</div>








            </div>
            </div>
        <div class="footer">
                <a href="/love/welcome-my-blog.html">About</a>
                 <a href="/1">Collecting</a>
                <a href="tencent://message/?uin=561802774">QQ</a>
                <a href="https://github.com/ivanpig">GitHub</a>
            <script src="/js/min/nprogress.min.js"></script>
            <script src="/js/index.js"></script>
        </div>
        <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

    </div>

</div>

</body>

</html>
