<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="keywords" content=""/>
    <meta name="author" content="liyouhai.com"> 
    <link rel="canonical" href="http://liyouhai.com/page/2/index.html">
    <link href="http://liyouhai.com/rss.xml" title="RSS 2.0" type="application/rss+xml" rel="alternate"/>
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon">
    <title>IvanPig's Blog</title>
    <link rel="stylesheet" href="/css/min/pure-min.css">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/min/grids-responsive-min.css">
    <!--<![endif]-->

    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/JekyllPure-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="/css/JekyllPure.css">
    <!--<![endif]-->

    <link href="/css/min/font-awesome.min.css" rel="stylesheet">
    <!--[if lte IE 8]>
    <link rel="stylesheet" href="/css/min/font-awesome-ie7.min.css">
    <![endif]-->
    <script src="/js/min/jquery-1.7.2.min.js"></script>
    <!--
     /\_ \    __                         /\ \                __
     \//\ \  /\_\  __  __    ___   __  __\ \ \___      __   /\_\
       \ \ \ \/\ \/\ \/\ \  / __`\/\ \/\ \\ \  _ `\  /'__`\ \/\ \
        \_\ \_\ \ \ \ \_\ \/\ \L\ \ \ \_\ \\ \ \ \ \/\ \L\.\_\ \ \
        /\____\\ \_\/`____ \ \____/\ \____/ \ \_\ \_\ \__/.\_\\ \_\
        \/____/ \/_/`/___/> \/___/  \/___/   \/_/\/_/\/__/\/_/ \/_/
                       /\___/
                       \/__/
     图像可以到http://asciigen.com/  生成..记得翻墙才能正常生成.如不方便可以博客留言我帮你生成
     -->
</head>

<body>







<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
        <div class="header">
            <div class="headerpic">
                <a href="/">
                    <img src="/img/op.jpg" alt="Profile Picture" style="width: 140px;" title="返回首页">
                </a>
            </div>
            <!-- <h1 class="brand-title">IvanPig's Blog</h1>-->
            <h2 class="brand-tagline">IvanPig's Blog</h2>

            <nav class="nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a class="pure-button" href="/Timing">时间轴</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/tag">标签库</a>
                    </li>
                    <!--<li class="nav-item">
                        <a class="pure-button" href="/1">收藏站</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="/1">音乐屋</a>-->

                </ul>
            </nav>
            <div class="search">
                <form action="/search">
                    <input type="text" class="search-query" placeholder="Search Blog" name="query" title="全站搜索-只支持英文">
                </form>
            </div>
            <div id="toc"></div>
            <nav id="nav">
                <ul class="nav-list">
                    <li class="nav-link">
                    <a class="weibo "  href="http://weibo.com/1686537657/profile?topnav=1&wvr=6" ><i class="fa fa-weibo fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="github" href="https://github.com/ivanpig"><i class="fa fa-github fa-2x"></i></a>
                    </li>
                    <li class="nav-link">
                    <a class="rss" href="/rss.xml" ><i class="fa fa-rss fa-2x"></i></a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <!--[if lt IE 8]>
        <i class="label label-danger">亲爱的用户，您的浏览器版本过低，建议您升级浏览器获得更好的用户体验</i>
        <![endif]-->
        <div>
            <div class="posts">

                


    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b%25e5%2587%25bd%25e6%2595%25b0.html">Clojure教程:函数</a></h2>

            <p class="post-meta">By 03月15日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  

  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 针对Clojure版本</a></li>
<li><a href="#sec-2">2. 简介</a></li>
<li><a href="#sec-3">3. 如何定义函数</a></li>
<li><a href="#sec-4">4. 匿名函数</a></li>
<li><a href="#sec-5">5. 如何执行函数</a></li>
<li><a href="#sec-6">6. 多元数函数</a></li>
<li><a href="#sec-7">7. 解构函数参数</a>
<ul>
<li><a href="#sec-7-1">7.1. 基于位置的解构</a></li>
<li><a href="#sec-7-2">7.2. 解构Map</a></li>
</ul>
</li>
<li><a href="#sec-8">8. 变参函数</a>
<ul>
<li><a href="#sec-8-1">8.1. 具名参数(Named Parameters)</a></li>
</ul>
</li>
<li><a href="#sec-9">9. 高阶函数</a></li>
<li><a href="#sec-10">10. 私有函数</a></li>
<li><a href="#sec-11">11. 关键字作为函数</a></li>
<li><a href="#sec-12">12. Map作为函数</a></li>
<li><a href="#sec-13">13. Set作为函数</a></li>
<li><a href="#sec-14">14. 函数作为比较器</a></li>
<li><a href="#sec-15">15. 结束语</a></li>
<li><a href="#sec-16">16. 贡献</a></li>
</ul>
</div>
</div>
<p>
本文翻译自<a href="http://clojure-doc.org/articles/language/functions.html">Functions in Clojure</a><br />
本文包括如下内容:</p>
<ul class="org-ul">
<li>如何定义函数
</li>
<li>如何执行函数
</li>
<li>多元数函数(Multi-arity Functions)
</li>
<li>不定参函数(Variadic Functions)
</li>
<li>高阶函数
</li>
<li>其它函数相关内容
</li>
</ul>
<p>
版权:<br />
This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 针对Clojure版本</h2>
<div class="outline-text-2" id="text-1">
<p>
Clojure 1.5</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 简介</h2>
<div class="outline-text-2" id="text-2">
<p>
Clojure是函数式编程语言.自然的,函数是Clojure非常重要的一部分.</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 如何定义函数</h2>
<div class="outline-text-2" id="text-3">
<p>
函数定义一般使用defn宏:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">round</span>
  [d precision]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [factor <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/pow</span> 10 precision<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">/</span> <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/floor</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> d factor<span style="color: #8c8c8c;">))</span> factor<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
类型提示有时能避免编译器使用反射,从而能生成更高效的字节码.但是,基本上<br />
你没必要使用类型提示.后期优化时再考虑.<br />
函数可以添加注释文档,给API添加文档说明是个好习惯:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">round</span>
  <span style="color: #93a1a1; font-style: italic;">"Round down a double to the given precision (number of significant digits)"</span>
  [d precision]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [factor <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/pow</span> 10 precision<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">/</span> <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/floor</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> d factor<span style="color: #8c8c8c;">))</span> factor<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
在Clojure中函数参数可以有类型提示,不过是可选的.</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">round</span>
  [<span style="color: #cb4b16;">^double</span> d <span style="color: #cb4b16;">^long</span> precision]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [factor <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/pow</span> 10 precision<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">/</span> <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/floor</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> d factor<span style="color: #8c8c8c;">))</span> factor<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
函数还可以定义前置和后置条件来限制函数的参数和返回值.</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">round</span>
  <span style="color: #93a1a1; font-style: italic;">"Round down a double to the given precision (number of significant digits)"</span>
  [<span style="color: #cb4b16;">^double</span> d <span style="color: #cb4b16;">^long</span> precision]
  {<span style="color: #2aa198;">:pre</span> [<span style="color: #8c8c8c;">(</span>not-nil? d<span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span>not-nil? precision<span style="color: #8c8c8c;">)</span>]}
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [factor <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/pow</span> 10 precision<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">/</span> <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/floor</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> d factor<span style="color: #8c8c8c;">))</span> factor<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
在上面的例子中,我没使用了前置条件来检查两个参数是否为nil.not-nil?宏(或<br />
函数),没有在该例子中展示,我们假设它已经在其它地方实现了.</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 匿名函数</h2>
<div class="outline-text-2" id="text-4">
<p>
匿名函数使用fn特殊形式来定义;</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> 2 x<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
匿名函数可以赋给局部变量,作为参数传递给函数或作为函数的返回值.</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [f <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [x]
          <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> 2 x<span style="color: #8c8c8c;">))</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> f <span style="color: #8c8c8c;">(</span><span style="color: #859900;">range</span> 0 10<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
Clojure提供了语法糖来简化匿名函数的编写:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [f #<span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> 2 %<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> f <span style="color: #8c8c8c;">(</span><span style="color: #859900;">range</span> 0 10<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
%表示第一个参数.如果要引用多个参数,可以使用%1,%2.以此类推:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#19968;&#20010;&#21253;&#21547;&#20102;&#19977;&#20010;&#21442;&#25968;&#30340;&#21311;&#21517;&#20989;&#25968;,&#36820;&#22238;&#19977;&#20010;&#21442;&#25968;&#30340;&#21644;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [f #<span style="color: #8c8c8c;">(</span><span style="color: #859900;">+</span> %1 %2 %3<span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span>f 1 2 3<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
语法糖简化了代码,但是降低了代码的可读性.所以使用前请斟酌.</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 如何执行函数</h2>
<div class="outline-text-2" id="text-5">
<p>
要执行函数,只需要将函数名放在list的第一个位置就行了:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">format</span> <span style="color: #2aa198;">"Hello, %s"</span> <span style="color: #2aa198;">"world"</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
对于赋给局部变量,变量或这从参数传递的函数,此法同样适用:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [f format]
  <span style="color: #8c8c8c;">(</span>f <span style="color: #2aa198;">"Hello, %s"</span> <span style="color: #2aa198;">"world"</span><span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
另外你也可以使用clojure.core/apply来执行函数</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> format <span style="color: #2aa198;">"Hello, %s"</span> [<span style="color: #2aa198;">"world"</span>]<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> format <span style="color: #2aa198;">"Hello, %s %s"</span> [<span style="color: #2aa198;">"Clojure"</span> <span style="color: #2aa198;">"world"</span>]<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
clojure.core/apply一般在调用不定参函数或者需要将参数作为集合传递时才会<br />
使用</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 多元数函数</h2>
<div class="outline-text-2" id="text-6">
<p>
在Clojure中有多元数函数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">tax-amount</span>
  <span style="color: #8c8c8c;">(</span>[amount]
     <span style="color: #8c8c8c;">(</span>tax-amount amount 35<span style="color: #8c8c8c;">))</span>
  <span style="color: #8c8c8c;">(</span>[amount rate]
     <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Math/round</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">double</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> amount <span style="color: #8c8c8c;">(</span><span style="color: #859900;">/</span> rate 100<span style="color: #8c8c8c;">))))))</span>
</pre>
</div>
<p>
在上面的例子中,只有一个参数的函数调用了有两个参数的函数.这在多参函数中<br />
很常见(相当于默认值的功能).Clojure没有提供默认值的功能,是因为JVM不支持.<br />
在Clojure中,元数只和参数个数有关,而和参数类型无关.这是因为Clojure是动<br />
态语言,类型信息可能在编译期是无效的.</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">range</span>
  <span style="color: #8c8c8c;">(</span>[]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">range</span> 0 <span style="color: #cb4b16;">Double/POSITIVE_INFINITY</span> 1<span style="color: #8c8c8c;">))</span>
  <span style="color: #8c8c8c;">(</span>[end]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">range</span> 0 end 1<span style="color: #8c8c8c;">))</span>
  <span style="color: #8c8c8c;">(</span>[start end]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">range</span> start end 1<span style="color: #8c8c8c;">))</span>
  <span style="color: #8c8c8c;">(</span>[start end step]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comment</span> <span style="color: #cb4b16;">Omitted</span> for clarity<span style="color: #8c8c8c;">)))</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 解构函数参数</h2>
<div class="outline-text-2" id="text-7">
<p>
有时函数的参数是数据结构:向量,序列,map.当你想访问这些数据结构的其中一<br />
部分数据时,你可能需要编写类似下面的代码</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [m]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [currency <span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> m <span style="color: #2aa198;">:currency</span><span style="color: #8c8c8c;">)</span>]
    currency<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
对向量来说,需要编写类似这样的代码:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [pair]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [amount   <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span>  pair<span style="color: #8c8c8c;">)</span>
        currency <span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> pair<span style="color: #8c8c8c;">)</span>]
    currency<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
但是呢,这样的样板代码可重用性并不高.所以Clojure提供了解构.</p>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 基于位置的解构</h3>
<div class="outline-text-3" id="text-7-1">
<p>
解构向量的方式如下:使用一个向量替换原来作为函数参数的数据结构,这个向量包含了占位符,<br />
而占位符会将对应位置的数据结构的值绑定过来.举例来说,如果一个参数是一对<br />
值,你想要获得第二个参数值,那么代码可以这样写:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [[amount currency]]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
在上面的例子中,参数的第一个值被绑定到了amount上,第二个参数是被绑定到了<br />
currency上.看起来很棒,但是,这里我们并没有使用amount.在这种情况下,我们<br />
可以使用下划线来忽略它:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [[_ currency]]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
解构是能够嵌套的:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">first-first</span>
  [[[i _] _]]
  i<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
虽然本文不会涉及到let这个form和本地变量.但是需要提一下,解构对let也生效,而<br />
且作用一模一样</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [pair         [10 <span style="color: #2aa198;">:gbp</span>]
      [_ currency] pair]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 解构Map</h3>
<div class="outline-text-3" id="text-7-2">
<p>
对Map和Record的解构方式与解构向量略有不同:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{currency <span style="color: #2aa198;">:currency</span>}]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
在上面的例子中,我们想把:currency这个key对应的value绑定到currency上.Key<br />
并不一定需要是关键字:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{currency <span style="color: #2aa198;">"currency"</span>}]
  currency<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{currency 'currency}]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
我们可以一次性解构多个key:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{<span style="color: #2aa198;">:keys</span> [currency amount]}]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
上面的例子中,keys需要为关键字,其名字与currency和amount相同<br />
(即:currency,:amount).如果keys是字符串,则将上面的:keys改为:strs即可:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{<span style="color: #2aa198;">:strs</span> [currency amount]}]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
当然也可以是symbol:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{<span style="color: #2aa198;">:syms</span> [currency amount]}]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
当然了,使用关键字作为key在Clojure中是推荐做法.<br />
解构Map时,如果找不到我们需要的key的值,我们可以设置默认值:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">currency-of</span>
  [{<span style="color: #2aa198;">:keys</span> [currency amount] <span style="color: #2aa198;">:or</span> {currency <span style="color: #2aa198;">:gbp</span>}}]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
此功能对于编写包含额外属性的函数大有裨益.<br />
和基于位置的解构相同,Map解构对let同样适用:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [money               {<span style="color: #2aa198;">:currency</span> <span style="color: #2aa198;">:gbp</span> <span style="color: #2aa198;">:amount</span> 10}
     {currency <span style="color: #2aa198;">:currency</span>} money]
  currency<span style="color: #8c8c8c;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 变参函数</h2>
<div class="outline-text-2" id="text-8">
<p>
参数数量可变的函数叫做变参函数.clojure.core/str和clojure.core/format就<br />
是两个变参函数:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"a"</span> <span style="color: #2aa198;">"b"</span><span style="color: #8c8c8c;">)</span>      <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; "ab"</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"a"</span> <span style="color: #2aa198;">"b"</span> <span style="color: #2aa198;">"c"</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; "abc"</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">format</span> <span style="color: #2aa198;">"Hello, %s"</span> <span style="color: #2aa198;">"world"</span><span style="color: #8c8c8c;">)</span>               <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; "Hello, world"</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">format</span> <span style="color: #2aa198;">"Hello, %s %s"</span> <span style="color: #2aa198;">"Clojure"</span> <span style="color: #2aa198;">"world"</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; "Hello, Clojure world"</span>
</pre>
</div>
<p>
要定义变参函数,只需要在变参前面加个&amp;就可以了:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">log</span>
  [message &amp; args]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comment</span> ...<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
在上面的例子中,只有一个参数是必须的.变参函数的调用方式和普通函数相同:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">log</span>
  [message &amp; args]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"args: "</span> args<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span>log <span style="color: #2aa198;">"message from "</span> <span style="color: #2aa198;">"192.0.0.76"</span><span style="color: #8c8c8c;">)</span>
</pre>
</div>
<p>
在REPL中执行:</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (log <span style="color: #2aa198;">"message from "</span> <span style="color: #2aa198;">"192.0.0.76"</span>)
args:  (192.0.0.76)

<span style="color: #268bd2;">user</span>=&gt; (log <span style="color: #2aa198;">"message from "</span> <span style="color: #2aa198;">"192.0.0.76"</span> <span style="color: #2aa198;">"service:xyz"</span>)
args:  (192.0.0.76 service:xyz)
</pre>
</div>
<p>
你可以看到,可选的参数被包装到了一个list里面.</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 具名参数(Named Parameters)</h3>
<div class="outline-text-3" id="text-8-1">
<p>
具名参数是通过对变参函数的解构来实现的.<br />
从解构变参函数的立场上来看,具名参数具有较好的可读性.下面是一个例子:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">job-info</span>
  [&amp; {<span style="color: #2aa198;">:keys</span> [name job income] <span style="color: #2aa198;">:or</span> {job <span style="color: #2aa198;">"unemployed"</span> income <span style="color: #2aa198;">"$0.00"</span>}}]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">if</span> name
    [name job income]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"No name specified"</span><span style="color: #8c8c8c;">)))</span>
</pre>
</div>
<p>
使用函数方式如下:</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (job-info :name <span style="color: #2aa198;">"Robert"</span> :job <span style="color: #2aa198;">"Engineer"</span>)
[<span style="color: #2aa198;">"Robert"</span> <span style="color: #2aa198;">"Engineer"</span> <span style="color: #2aa198;">"$0.00"</span>]

<span style="color: #268bd2;">user</span>=&gt; (job-info :job <span style="color: #2aa198;">"Engineer"</span>)
No name specified
</pre>
</div>
<p>
如果不使用变参列表,那么你需要使用形如{:name "Robert" :job "Engineer"}这<br />
样的map作为参数.<br />
关键字的默认值依据:as后跟的map来确定.如果关键字没有传递值,且无默认值,<br />
则为nil.</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 高阶函数</h2>
<div class="outline-text-2" id="text-9">
<p>
高阶函数是将其它函数作为参数的函数.高阶函数在函数式编程中是很重要的技<br />
术,在Clojure中经常使用到.一个高阶函数的例子是将一个函数和一个集合作为<br />
参数,返回符合这个函数条件的集合.在Clojure中,这叫做clojure.core/filter:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">filter</span> even? <span style="color: #8c8c8c;">(</span><span style="color: #859900;">range</span> 0 10<span style="color: #8c8c8c;">))</span>  <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt;(0 2 4 6 8)</span>
</pre>
</div>
<p>
上面的例子中,clojure.core/filter函数接收clojure.core/even?作为参数.<br />
clojure.core中有很多高阶函数.经常使用的函数请参见<a href="http://clojure-doc.org/articles/language/core_overview.html">clojure.core</a></p>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 私有函数</h2>
<div class="outline-text-2" id="text-10">
<p>
在Clojure中,函数可以在其命名空间中设置为私有的.<br />
具体细节请参考<a href="http://clojure-doc.org/articles/language/namespaces.html">这里</a></p>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 关键字作为函数</h2>
<div class="outline-text-2" id="text-11">
<p>
在Clojure中,关键字可以作为函数使用.他们接收map或record并从中查找信息:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #2aa198;">:age</span> {<span style="color: #2aa198;">:age</span> 27 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Michael"</span>}<span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; 27</span>
</pre>
</div>
<p>
他们经常和高阶函数结合使用:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> <span style="color: #2aa198;">:age</span> [{<span style="color: #2aa198;">:age</span> 45 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Joe"</span>} {<span style="color: #2aa198;">:age</span> 42 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Jill"</span>} {<span style="color: #2aa198;">:age</span> 17 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Matt"</span>}]<span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; (45 42 17)</span>
</pre>
</div>
<p>
也能和-&gt;宏一起使用:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">-&gt;</span> [{<span style="color: #2aa198;">:age</span> 45 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Joe"</span>} {<span style="color: #2aa198;">:age</span> 42 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Jill"</span>}] first <span style="color: #2aa198;">:name</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; "Joe"</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Map作为函数</h2>
<div class="outline-text-2" id="text-12">
<p>
Clojure的Map也能作为函数使用,来查找key对应的value:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>{<span style="color: #2aa198;">:age</span> 42 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Joe"</span>} <span style="color: #2aa198;">:name</span><span style="color: #8c8c8c;">)</span>     <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; "Joe"</span>
<span style="color: #8c8c8c;">(</span>{<span style="color: #2aa198;">:age</span> 42 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Joe"</span>} <span style="color: #2aa198;">:age</span><span style="color: #8c8c8c;">)</span>      <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; 42</span>
<span style="color: #8c8c8c;">(</span>{<span style="color: #2aa198;">:age</span> 42 <span style="color: #2aa198;">:name</span> <span style="color: #2aa198;">"Joe"</span>} <span style="color: #2aa198;">:unknown</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; nil</span>
</pre>
</div>
<p>
需要注意的是,虽然大部分情况下map和record可以等同对待,但是这里不<br />
行!record不能作为函数使用!</p>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Set作为函数</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>#{1 2 3} 1<span style="color: #8c8c8c;">)</span>   <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; 1</span>
<span style="color: #8c8c8c;">(</span>#{1 2 3} 10<span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; nil</span>

<span style="color: #8c8c8c;">(</span>#{<span style="color: #2aa198;">:us</span> <span style="color: #2aa198;">:au</span> <span style="color: #2aa198;">:ru</span> <span style="color: #2aa198;">:uk</span>} <span style="color: #2aa198;">:uk</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; :uk</span>
<span style="color: #8c8c8c;">(</span>#{<span style="color: #2aa198;">:us</span> <span style="color: #2aa198;">:au</span> <span style="color: #2aa198;">:ru</span> <span style="color: #2aa198;">:uk</span>} <span style="color: #2aa198;">:cn</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">&#8658; nil</span>
</pre>
</div>
<p>
此功能被用来验证某值是否set中:</p>
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">when</span> <span style="color: #8c8c8c;">(</span>countries <span style="color: #2aa198;">:in</span><span style="color: #8c8c8c;">)</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comment</span> ...<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">if</span> <span style="color: #8c8c8c;">(</span>countries <span style="color: #2aa198;">:in</span><span style="color: #8c8c8c;">)</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comment</span> <span style="color: #cb4b16;">Implement</span> positive case<span style="color: #8c8c8c;">)</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comment</span> <span style="color: #cb4b16;">Implement</span> negative case<span style="color: #8c8c8c;">))</span>
</pre>
</div>
<p>
因为在Clojure中除了false和nil,其它值都是true.</p>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> 函数作为比较器</h2>
<div class="outline-text-2" id="text-14">
<p>
Clojure函数实现了java.util.Comparator接口,所以能作为比较器使用.</p>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> 结束语</h2>
<div class="outline-text-2" id="text-15">
<p>
函数是Clojure的核心.他们通过defn宏来定义,可以有多个元数,不定参数并支持<br />
参数解构.函数参数和返回值可以有类型提示,当然这不是必须的.<br />
函数是一等值,它能被传递给其它函数.这是函数式编程的基石.<br />
有一些数据类型有函数特性.适时的使用这些特性可以是代码更简洁易读.</p>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> 贡献</h2>
<div class="outline-text-2" id="text-16">
<p>
Michael Klishin michael@defprotocol.org, 2012 (original author)<br />
Translated by Ivan 2014</p>
</div>
</div>



            <a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b%25e5%2587%25bd%25e6%2595%25b0.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e8%25bf%259b%25e9%2598%25b6%25e4%25bd%25bf%25e7%2594%25a8clojure%25e6%259e%2584%25e5%25bb%25badsl.html">Clojure进阶:使用Clojure构建DSL</a></h2>

            <p class="post-meta">By 03月01日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p>翻译自<a href="http://clojure-doc.org/articles/tutorials/growing_a_dsl_with_clojure.html">Growing a DSL with Clojure</a>.主要讲解如何使用Clojure来创建一个简单的DSL.包括如下知识点:</p>
<ul>
<li>多重方法(Multimethods)
</li>
<li>继承(Hierarchies)
</li>
<li>元编程及"代码即数据"哲学(Metaprogramming and the "Code as data" philosophy)
</li>
</ul>
<p>
Lisp及其方言(比如Clojure)可以很方便的创建DSL并能和源语言无缝的集成.<br />
Lisp界鼓吹的优点中，提到最多的可能就是:数据即代码，代码即数据了。在此<br />
文中我们将依此特性来定义一个DSL。</p>
<p>
我们将渐进式的开发这个DSL，不断的加入Clojure的特性和抽象。</p>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 任务</a></li>
<li><a href="#sec-2">2 第一步:构建我们的领域语言</a></li>
<li><a href="#sec-3">3 Echo和Print</a></li>
<li><a href="#sec-4">4 Lisp代码即数据</a></li>
<li><a href="#sec-5">5 细窥Clojure</a></li>
<li><a href="#sec-6">6 使用多重方法对分支进行抽象</a></li>
<li><a href="#sec-7">7 扩展我们的DSL实现Windows批处理</a></li>
<li><a href="#sec-8">8 Ad-hoc继承</a></li>
<li><a href="#sec-9">9 多重方法中使用继承</a></li>
<li><a href="#sec-10">10 饭后甜点</a></li>
<li><a href="#sec-11">11 总结</a></li>
<li><a href="#sec-12">12 Copyright</a></li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">任务</h2>
<div class="outline-text-2" id="text-1">
<p>我们的目标是定义一个可以生成各种脚本语言的DSL.而且DSL代码看起来和普通<br />
的Clojure代码没有区别。</p>
<p>
例如,我们使用Clojure形式(form)来生成Bash脚本或者Windows批处理脚本:<br />
输入(Clojure形式):</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">if</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> 1 2<span style="color: #8c8c8c;">)</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"b"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
输出(Bash脚本):</p>
<pre class="src src-sh"><span style="color: #859900;">if</span> [ 1 -eq 2 ]; <span style="color: #859900;">then</span>
  <span style="color: #859900;">echo</span> <span style="color: #2aa198;">"a"</span>
<span style="color: #859900;">else</span>
  <span style="color: #859900;">echo</span> <span style="color: #2aa198;">"b"</span>
<span style="color: #859900;">fi</span>
</pre>
<p>
输出(Windows批处理):</p>
<pre class="src src-sh">IF <span style="color: #268bd2;">1</span>==2 (
  ECHO a
) ELSE (
  ECHO b
)
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">第一步:构建我们的领域语言</h2>
<div class="outline-text-2" id="text-2">
<p>我们先从Bash脚本开始。<br />
在开始之前，我们先看看Clojure核心类型是否有什么类型我们可以直接拿到领域<br />
语言中使用。在Clojure类型中是否有和Bash脚本类似的类型呢？<br />
那就是字符串和基本类型，我们先从这里开始。<br />
我们来定义一个emit-bash-form函数，它接受一个Clojure形式并返回一个符合<br />
Bash脚本定义的字符串。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">emit-bash-form</span>
  <span style="color: #93a1a1; font-style: italic;">"Returns a String containing the equivalent Bash script</span>
<span style="color: #93a1a1; font-style: italic;">  to its argument."</span>
  [a]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> 
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">java.lang.String</span><span style="color: #8c8c8c;">)</span> a
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">java.lang.Long</span><span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> a<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">java.lang.Double</span><span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> a<span style="color: #8c8c8c;">)</span>
    <span style="color: #2aa198;">:else</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">throw</span> <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Exception.</span> <span style="color: #2aa198;">"Fell through"</span><span style="color: #8c8c8c;">))))</span>
</pre>
<p>
cond表达式根据传入参数的类型来进行相应的操作。</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (emit-bash-form 1)
<span style="color: #2aa198;">"1"</span>
<span style="color: #268bd2;">user</span>=&gt; (emit-bash-form <span style="color: #2aa198;">"a"</span>)
<span style="color: #2aa198;">"a"</span>
</pre>
<p>
那么我们为什么要选择Long而不是Integer呢？因为在Clojure中，默认数据类型<br />
是Long.<br />
虽然Clojure支持Java所有的基本类型,但是默认情况下Clojure使用的是long和<br />
double.Clojure会自动将int转成long，float转成double.可以简单的测试一下:</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (class 7)
java.lang.Long
</pre>
<p>
现在，如果我们想添加条件判断，我们只需要在cond表达式中添加相应的分支即<br />
可。</p>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Echo和Print</h2>
<div class="outline-text-2" id="text-3">
<p>让我们继续添加功能。<br />
Bash使用echo在屏幕上打印信息。如果你玩过Linux shell那么你应该对此不陌<br />
生。</p>
<pre class="src src-sh">ambrose@ambrose-desktop&gt; echo asdf
asdf
</pre>
<p>
clojure.core命名空间也包含了一个和Bash的echo类似功能的函数，叫println.</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (println <span style="color: #2aa198;">"asdf"</span>)
asdf
;=&gt; nil
</pre>
<p>
如果我们能直接将(println "a")传递给emit-bash-form是不是很酷?</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (emit-bash-form (println <span style="color: #2aa198;">"asdf"</span>))
asdf
;=&gt; nil
</pre>
<p>
那么首先，需要看看这是否可行.<br />
我们使用Java来进行一下类比，假设我们要调用的是这样一段Java代码，它的第一个参数<br />
类似于System.out.println("asdf").</p>
<pre class="src src-java">foo(System.out.println(<span style="color: #2aa198;">"asdf"</span>));
</pre>
<p>
(我们先忽略System.out.println(&hellip;)返回的是void)<br />
在Java中，参数会被先求值，然后再传递，也就是说，这里会先打印出asdf，然<br />
后将println的返回值给foo方法。<br />
我们如何能阻止参数被先求值呢?<br />
很遗憾，在Java中这是不可能完成的任务。即使这在Java中可以实现，那后续我们能对<br />
这段源代码做什么处理呢?<br />
System.out.println("asdf")不是集合,所以我们不能遍历它；它也不是字符串，<br />
我们也不能用正则表达式来切割它。不管System.out.println("asdf")是什么类<br />
型，除了编译器，没人认识它。<br />
Lisp则不会有这样的尴尬!</p>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Lisp代码即数据</h2>
<div class="outline-text-2" id="text-4">
<p>上节说到的Java的主要问题是没有能处理源代码的工具。Clojure是怎么解决这个问题的呢?<br />
首先，为了能获得源码，Clojure提供了quote来阻止求值过程。<br />
只需要在不需要求值的形式前面添加quote即可阻止该形式被求值。</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; <span style="color: #2aa198;">'(println "a")</span>
<span style="color: #2aa198;">;=&gt; (println "a")</span>
</pre>
<p>
那么我们的返回值是什么类型呢?</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (class <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">;=&gt; clojure.lang.PersistentList</span>
</pre>
<p>
我们可以将返回值当成原始的Clojure列表(实际上它就是)</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (first <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">;=&gt; println</span>

<span style="color: #2aa198;">user=&gt; (second '</span>(println <span style="color: #2aa198;">"a"</span>))
;=&gt; <span style="color: #2aa198;">"a"</span>
</pre>
<p>
这就是Lisp代码即数据所带来的一个好处.</p>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">细窥Clojure</h2>
<div class="outline-text-2" id="text-5">
<p>使用了quote，我们就离DSL近了一步。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>emit-bash-form
  '<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
让我们将这个分支添加到emit-bash-form函数中。我们需要添加一个新的判断条<br />
件。<br />
但是这个分支该用什么类型来判断呢?</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (class <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">clojure.lang.PersistentList</span>
</pre>
<p>
所以让我们来添加一个clojure.lang.PersistentList判断分支.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">emit-bash-form</span> [a]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">cond</span> 
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">clojure.lang.PersistentList</span><span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">case</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">name</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> a<span style="color: #8c8c8c;">))</span>
      <span style="color: #2aa198;">"println"</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"echo "</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> a<span style="color: #8c8c8c;">)))</span>

    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">java.lang.String</span><span style="color: #8c8c8c;">)</span> a
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">java.lang.Long</span><span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> a<span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">=</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> a<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">java.lang.Double</span><span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> a<span style="color: #8c8c8c;">)</span>
    <span style="color: #2aa198;">:else</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">throw</span> <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Exception.</span> <span style="color: #2aa198;">"Fell through"</span><span style="color: #8c8c8c;">))))</span>
</pre>
<p>
看看调用:</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (emit-bash-form <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">"echo a"</span>
<span style="color: #2aa198;">user=&gt; (emit-bash-form '</span>(println <span style="color: #2aa198;">"hello"</span>))
<span style="color: #2aa198;">"echo hello"</span>
</pre>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">使用多重方法对分支进行抽象</h2>
<div class="outline-text-2" id="text-6">
<p>我们有一个好的开始，现在在我们进行下一步前，先进行一下重构。<br />
现在，我们要添加新的分支，那么就要在emit-bash-form函数中添加新的判断逻<br />
辑。随着添加的分支越来越多，这个函数将越来越难维护了。我们需要将这个函<br />
数切分成易于维护的片段.<br />
emit-bash-form的调度是依据其参数的类型来进行的。而这可以通过Clojure的<br />
多重方法来进行抽象。<br />
我们来定义一个叫emit-bash的多重方法。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmulti</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [form]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> form<span style="color: #8c8c8c;">)))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #cb4b16;">clojure.lang.PersistentList</span>
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">case</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">name</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> form<span style="color: #8c8c8c;">))</span>
    <span style="color: #2aa198;">"println"</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"echo "</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> form<span style="color: #8c8c8c;">))))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #cb4b16;">java.lang.String</span>
  [form]
  form<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #cb4b16;">java.lang.Long</span>
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> form<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #cb4b16;">java.lang.Double</span>
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> form<span style="color: #8c8c8c;">))</span>
</pre>
<p>
多重方法的分派和cond很类似，但是不需要去写实际的分派代码。让我们来对比<br />
一下多重方法和之前的代码。defmulti用来创建一个新的多重方法，并和分派函<br />
数来关联。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmulti</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [form]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> form<span style="color: #8c8c8c;">)))</span>
</pre>
<p>
defmethod用来添加具体的方法到多重方法中。在这里java.lang.String是指派<br />
所依赖的值,而方法直接返回form自身.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-bash</span>
  <span style="color: #cb4b16;">java.lang.String</span>
  [form]
  form<span style="color: #8c8c8c;">)</span>
</pre>
<p>
添加新方法和扩展cond表达式的效果相同，差别就是:<br />
多重方法来控制指派，不需要你去写控制代码。<br />
那么我们该如何使用emit-bash呢？调用多重方法和调用普通的Clojure函数一模<br />
一样:</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (emit-bash <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">"echo a"</span>
</pre>
<p>
分支判断由多重方法自己去判断了。</p>
</div>
</div>
<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">扩展我们的DSL实现Windows批处理</h2>
<div class="outline-text-2" id="text-7">
<p>现在我们来实现Windows批处理.我们来定义一个新的多重方法,emit-batch:</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmulti</span> <span style="color: #268bd2;">emit-batch</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [form] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> form<span style="color: #8c8c8c;">)))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-batch</span> <span style="color: #cb4b16;">clojure.lang.PersistentList</span>
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">case</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">name</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> form<span style="color: #8c8c8c;">))</span>
    <span style="color: #2aa198;">"println"</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"ECHO "</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> form<span style="color: #8c8c8c;">))</span>
    nil<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-batch</span> <span style="color: #cb4b16;">java.lang.String</span>
  [form]
  form<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-batch</span> <span style="color: #cb4b16;">java.lang.Long</span>
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> form<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit-batch</span> <span style="color: #cb4b16;">java.lang.Double</span>
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> form<span style="color: #8c8c8c;">))</span>
</pre>
<p>
现在我们能使用emit-batch和emit-bash了。</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (emit-batch <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">"ECHO a"</span>
<span style="color: #2aa198;">user=&gt; (emit-bash '</span>(println <span style="color: #2aa198;">"a"</span>))
<span style="color: #2aa198;">"echo a"</span>
</pre>
</div>
</div>
<div id="outline-container-8" class="outline-2">
<h2 id="sec-8">Ad-hoc继承</h2>
<div class="outline-text-2" id="text-8">
<p>比较一下两个实现，有很多相似的地方。实际上，只有<br />
clojure.lang.PersistentList分支有区别。<br />
我们想到了继承，Clojure可以很方便的实现继承。<br />
当我说继承的时候，我可不是指依赖于类或者命名空间的那种继承，实际上继承<br />
是一个与类或命名空间无关的独立功能。<br />
但是像Java这样的语言，继承是绑定到了类层级上的.<br />
我们能从一个名字派生到另一个名字，或者从类派生到名字。而这个名字可以是symbol<br />
或者keyword.这样的话继承就更加的灵活和强大!<br />
我们将使用(derive child parent)来定义父子关系。isa?来判断第一个参数是<br />
不是派生自第二个参数。</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (derive ::child ::parent)
nil

<span style="color: #268bd2;">user</span>=&gt; (isa? ::child ::parent)
true
</pre>
<p>
我们来定义Bash和Batch的继承关系</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">derive</span> <span style="color: #2aa198;">::bash</span> <span style="color: #2aa198;">::common</span><span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">derive</span> <span style="color: #2aa198;">::batch</span> <span style="color: #2aa198;">::common</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
测试一下</p>
<pre class="src src-sh"><span style="color: #268bd2;">user</span>=&gt; (parents ::bash)
;=&gt; <span style="color: #93a1a1; font-style: italic;">#</span><span style="color: #93a1a1; font-style: italic;">{:user/common}</span>

<span style="color: #268bd2;">user</span>=&gt; (parents ::batch)
;=&gt; <span style="color: #93a1a1; font-style: italic;">#</span><span style="color: #93a1a1; font-style: italic;">{:user/common}</span>
</pre>
</div>
</div>
<div id="outline-container-9" class="outline-2">
<h2 id="sec-9">多重方法中使用继承</h2>
<div class="outline-text-2" id="text-9">
<p>现在我们可以利用继承关系来定义一个新的多重方法emit了。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmulti</span> <span style="color: #268bd2;">emit</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [form]
    [*current-implementation* <span style="color: #8c8c8c;">(</span><span style="color: #859900;">class</span> form<span style="color: #8c8c8c;">)</span>]<span style="color: #8c8c8c;">))</span>
</pre>
<p>
这个函数返回了一个包含两个元素的vector。一个是当前的实现(::bash或<br />
者::batch)和指派类型。*current-implementation*是个动态var,你可以把他看<br />
做一个线程安全的全局变量。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> ^{<span style="color: #2aa198;">:dynamic</span> true}
  <span style="color: #2aa198;">"The current script language implementation to generate"</span>
  *current-implementation*<span style="color: #8c8c8c;">)</span>
</pre>
<p>
在我们的继承关系中，::common是父，这就意味着它需要提供公共方法。<br />
需要记住的是，现在的指派值是个vector。所以在每个defmethod中，都需要包<br />
含一个vector，其中第一个元素是指派值.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit</span> [<span style="color: #2aa198;">::common</span> <span style="color: #cb4b16;">java.lang.String</span>]
  [form]
  form<span style="color: #8c8c8c;">)</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit</span> [<span style="color: #2aa198;">::common</span> <span style="color: #cb4b16;">java.lang.Long</span>]
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> form<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit</span> [<span style="color: #2aa198;">::common</span> <span style="color: #cb4b16;">java.lang.Double</span>]
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> form<span style="color: #8c8c8c;">))</span>
</pre>
<p>
代码很类似。只有clojure.lang.PersistentList分支需要特别处理，其vector<br />
的第一个元素需要为::bash或者::batch，而不能是::common了。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit</span> [<span style="color: #2aa198;">::bash</span> <span style="color: #cb4b16;">clojure.lang.PersistentList</span>]
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">case</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">name</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> form<span style="color: #8c8c8c;">))</span>
    <span style="color: #2aa198;">"println"</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"echo "</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> form<span style="color: #8c8c8c;">))</span>
    nil<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmethod</span> <span style="color: #268bd2;">emit</span> [<span style="color: #2aa198;">::batch</span> <span style="color: #cb4b16;">clojure.lang.PersistentList</span>]
  [form]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">case</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">name</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> form<span style="color: #8c8c8c;">))</span>
    <span style="color: #2aa198;">"println"</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"ECHO "</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">second</span> form<span style="color: #8c8c8c;">))</span>
    nil<span style="color: #8c8c8c;">))</span>
</pre>
<p>
我们来测试一下</p>
<pre class="src src-clojure">user=&gt; <span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*current-implementation* <span style="color: #2aa198;">::common</span>]
         <span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">))</span>
<span style="color: #2aa198;">"a"</span>

user=&gt; <span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*current-implementation* <span style="color: #2aa198;">::batch</span>]
         <span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> '<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)))</span>
<span style="color: #2aa198;">"ECHO a"</span>

user=&gt; <span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*current-implementation* <span style="color: #2aa198;">::bash</span>]
         <span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> '<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)))</span>
<span style="color: #2aa198;">"echo a"</span>

user=&gt; <span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*current-implementation* <span style="color: #2aa198;">::common</span>]
         <span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> '<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)))</span>
#&lt;<span style="color: #cb4b16;">CompilerException</span> java.lang.IllegalArgumentException:
<span style="color: #cb4b16;">No</span> method in multimethod 'emit' for dispatch value:
[<span style="color: #2aa198;">:user/common</span> <span style="color: #cb4b16;">clojure.lang.PersistentList</span>] <span style="color: #8c8c8c;">(</span>REPL:31<span style="color: #8c8c8c;">)</span>&gt;
</pre>
<p>
因为我们没有定义[::common clojure.lang.PersistentList]的实现，多重方法<br />
报错了。<br />
多重方法非常强大且非常灵活，但是能力越强责任越大。我们可以将我们的多重<br />
方法放在同一个命名空间下，但是不代表我们就需要这么做。当我们的DSL越来<br />
越大的时候，我们需要将其分开到独立的命名空间下去。</p>
<p>
这是个小例子，但是很好的展示了命名空间和继承的功能。</p>
</div>
</div>
<div id="outline-container-10" class="outline-2">
<h2 id="sec-10">饭后甜点</h2>
<div class="outline-text-2" id="text-10">
<p>我们使用多重方法，动态var和ad-hoc继承创建了一个漂亮的，细粒度的DSL，但<br />
是在使用的时候还是有些许的不便。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*current-implementation* <span style="color: #2aa198;">::bash</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> '<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)))</span>
</pre>
<p>
我们来消除样板代码.但是它在哪呢？<br />
binding表达式就是个样板代码，我们可以将binding的工作封装到<br />
with-implementation中</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>with-implementation <span style="color: #2aa198;">::bash</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> '<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)))</span>
</pre>
<p>
这是个改进。但是还有个改进没有这么的明显:用来延迟求值的quote。我们使用<br />
script来消除这个quote.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>with-implementation <span style="color: #2aa198;">::bash</span>
  <span style="color: #8c8c8c;">(</span>script
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"a"</span><span style="color: #8c8c8c;">)))</span>
</pre>
<p>
这样看起来好多了，但我们如何来实现script呢？Clojure函数会在求函数值前<br />
对所有的参数进行求值，而quote就是用来解决这个问题。而现在我们要消除这<br />
个quote。只能使用Lisp中的宏来处理。<br />
宏不会去立即对参数求值，这正是我们需要的。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmacro</span> <span style="color: #268bd2;">script</span> [form]
  `<span style="color: #8c8c8c;">(</span><span style="color: #b58900;">emit</span> '~form<span style="color: #8c8c8c;">))</span>
</pre>
<p>
看看调用结果</p>
<pre class="src src-sh">(script (println <span style="color: #2aa198;">"a"</span>))
=&gt;
(emit <span style="color: #2aa198;">'(println "a"))</span>
</pre>
<p>
比起欣赏宏美化语法的功能，记住宏的特性对你更有帮助。<br />
对于with-implementation来说，也需要宏来解决，与script不同，它不是为了<br />
延迟求值这个功能，而是对于其中的script来说，需要先将script的内容添加到binding<br />
形式中，才能进行求值.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defmacro</span> <span style="color: #268bd2;">with-implementation</span>
  [impl &amp; body]
  `<span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*current-implementation* impl]
    ~@body<span style="color: #8c8c8c;">))</span>
</pre>
<p>
好了,这就是DSL的所有内容了,实际上就添加了语法糖.</p>
<pre class="src src-sh">(with-implementation ::bash
  (script
    (println <span style="color: #2aa198;">"a"</span>)))
=&gt;
(with-implementation ::bash
  (emit
    <span style="color: #2aa198;">'(println "a"))</span>
<span style="color: #2aa198;">=&gt;</span>
<span style="color: #2aa198;">(binding [*current-implementation* ::bash]</span>
<span style="color: #2aa198;">  (emit</span>
<span style="color: #2aa198;">    '</span>(println <span style="color: #2aa198;">"a"</span>)))
</pre>
<p>
可以看出一个定义良好的宏如何来给代码添加语法糖.我们的DSL和普通的<br />
Clojure代码看起来没啥区别.</p>
</div>
</div>
<div id="outline-container-11" class="outline-2">
<h2 id="sec-11">总结</h2>
<div class="outline-text-2" id="text-11">
<p>在这个DSL中,我们看到了Clojure的很多高级特性.<br />
我们来回顾一下我们构建DSL的过程.<br />
一开始,我们使用了简单的cond表达式,然后变成了两个多重方法.接着我们使用<br />
了继承和动态var来消除重复代码.最后我们使用宏来简化调用.<br />
这个DSL是<a href="https://github.com/pallet/stevedore">Stevedore</a>的一个简化版本,Stevedore是Hugo Duncan开发的开源项目.如<br />
果你对这个DSL的实现感兴趣,那么最好的方法就是去看Stevedore的源码了.</p>
</div>
</div>
<div id="outline-container-12" class="outline-2">
<h2 id="sec-12">Copyright</h2>
<div class="outline-text-2" id="text-12">
<p>Copyright Ambrose Bonnaire-Sergeant, 2013<br />
Translated By Ivan 2014.02</p>
</div>
</div>



            <a href="/clojure/clojure%25e8%25bf%259b%25e9%2598%25b6%25e4%25bd%25bf%25e7%2594%25a8clojure%25e6%259e%2584%25e5%25bb%25badsl.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e8%25bf%259b%25e9%2598%25b6%25e6%2595%25b0%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597.html">Clojure进阶:数学计算</a></h2>

            <p class="post-meta">By 02月19日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <div id="content" style="color: #657a83; font-family: MONACO, 'trebuchet ms', arial, helvetica, sans-serif; font-size: 13px;">
<p style="margin: 5px 10px; text-indent: 40px;">本文翻译自<a style="text-decoration: none; color: #5489de;" href="http://clojure-doc.org/articles/cookbooks/math.html">Mathematics with Clojure</a><br />
本文包含了使用Clojure的内建函数,扩展包和部分JDK功能进行数学计算.<br />
版权:<br />
This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<div id="table-of-contents">
<h2 style="margin: 5px;">目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a style="text-decoration: none; color: #5489de;" href="#sec-1">1 准备</a></li>
<li><a style="text-decoration: none; color: #5489de;" href="#sec-2">2 方法</a>
<ul>
<li><a style="text-decoration: none; color: #5489de;" href="#sec-2-1">2.1 简单计算</a></li>
<li><a style="text-decoration: none; color: #5489de;" href="#sec-2-2">2.2 三角函数</a></li>
<li><a style="text-decoration: none; color: #5489de;" href="#sec-2-3">2.3 组合数学</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1" style="margin: 5px;"><span class="section-number-2">1</span> 准备</h2>
<div id="text-1" class="outline-text-2">
<p style="margin: 5px 10px; text-indent: 40px;">这里的一些例子使用了<a style="text-decoration: none; color: #5489de;" href="https://github.com/clojure/math.numeric-tower">math.numeric-tower</a>和<a style="text-decoration: none; color: #5489de;" href="https://github.com/clojure/math.combinatorics">math.combinatorics</a>库.所以需要<br />
你在代码的命名空间中包含如下代码:</p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<pre class="src src-clojure" style="border: 1pt solid #aebdcc; background-color: #272822; padding: 5pt; font-family: monaco, Consolas, courier, monospace; font-size: small; overflow: auto; margin: 5px 10px;"><span style="color: #7f7f7f;">(</span><span style="color: #ae81ff;">:require</span> [clojure.math.numeric-tower <span style="color: #ae81ff;">:as</span> math]
          [clojure.math.combinatorics <span style="color: #ae81ff;">:as</span> combo]<span style="color: #7f7f7f;">)</span>
</pre>
<p>或者在REPL里载入:</p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<pre class="src src-clojure" style="border: 1pt solid #aebdcc; background-color: #272822; padding: 5pt; font-family: monaco, Consolas, courier, monospace; font-size: small; overflow: auto; margin: 5px 10px;"><span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">require</span> '[clojure.math.numeric-tower <span style="color: #ae81ff;">:as</span> math]<span style="color: #7f7f7f;">)</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">require</span> '[clojure.math.combinatorics <span style="color: #ae81ff;">:as</span> combo]<span style="color: #7f7f7f;">)</span>
</pre>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2" style="margin: 5px;"><span class="section-number-2">2</span> 方法</h2>
<div id="text-2" class="outline-text-2"> </div>
<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1" style="margin: 5px 10px;"><span class="section-number-3">2.1</span> 简单计算</h3>
<div id="text-2-1" class="outline-text-3">
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<pre class="src src-clojure" style="border: 1pt solid #aebdcc; background-color: #272822; padding: 5pt; font-family: monaco, Consolas, courier, monospace; font-size: small; overflow: auto; margin: 5px 10px;"><span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">+</span> 3 4<span style="color: #7f7f7f;">)</span>    <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 7</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">-</span> 3 4<span style="color: #7f7f7f;">)</span>    <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; -1</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">*</span> 3 4<span style="color: #7f7f7f;">)</span>    <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 12</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">/</span> 3 4<span style="color: #7f7f7f;">)</span>    <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 3/4  (an exact ratio)</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">/</span> 3.0 4<span style="color: #7f7f7f;">)</span>  <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 0.75</span>

<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">inc</span> 5<span style="color: #7f7f7f;">)</span>    <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 6</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">dec</span> 5<span style="color: #7f7f7f;">)</span>    <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 4</span>
</pre>
<p>想要计算整数的除法,取余和取模,请看<a style="text-decoration: none; color: #5489de;" href="http://clojuredocs.org/clojure_core/clojure.core/quot">quot</a>,<a style="text-decoration: none; color: #5489de;" href="http://clojuredocs.org/clojure_core/clojure.core/rem">rem</a>,<a style="text-decoration: none; color: #5489de;" href="http://clojuredocs.org/clojure_core/clojure.core/mod">mod</a><br />
想计算指数的平方根,四舍五入,上下限,绝对值和最大公约数/最小公倍数,请看<a style="text-decoration: none; color: #5489de;" href="http://clojure.github.com/math.numeric-tower/">math.numeric-tower</a></p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
</div>
</div>
<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2" style="margin: 5px 10px;"><span class="section-number-3">2.2</span> 三角函数</h3>
<div id="text-2-2" class="outline-text-3">
<p style="margin: 5px 10px; text-indent: 40px;">使用Java平台提供的函数:</p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<pre class="src src-clojure" style="border: 1pt solid #aebdcc; background-color: #272822; padding: 5pt; font-family: monaco, Consolas, courier, monospace; font-size: small; overflow: auto; margin: 5px 10px;"><span style="color: #a6e22a;">Math/PI</span>       <span style="color: #75715e;">;</span><span style="color: #75715e;">=&gt; 3.14159...</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">Math/sin</span> x<span style="color: #7f7f7f;">)</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">Math/cos</span> x<span style="color: #7f7f7f;">)</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a6e22a;">Math/tan</span> x<span style="color: #7f7f7f;">)</span>
</pre>
<p>还有很多的函数,你可以查看<a style="text-decoration: none; color: #5489de;" href="http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html">java.lang.Math</a></p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
<p style="margin: 5px 10px; text-indent: 40px;"> </p>
</div>
</div>
<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3" style="margin: 5px 10px;"><span class="section-number-3">2.3</span> 组合数学</h3>
<div id="text-2-3" class="outline-text-3">
<p style="margin: 5px 10px; text-indent: 40px;">对于组合数学相关函数(比如:combinations和permutations),请看<a style="text-decoration: none; color: #5489de;" href="http://clojure.github.com/math.combinatorics/">math.combinatorics</a></p>
</div>
</div>
</div>
</div>
<div id="postamble" style="margin-top: 15px; color: #657a83; font-family: MONACO, 'trebuchet ms', arial, helvetica, sans-serif; font-size: 13px;">
<p class="author" style="margin: 5px 10px; text-indent: 40px;">Author: Ivan (<a style="text-decoration: none; color: #5489de;" href="mailto:ivan.pig@foxmail.com">ivan.pig@foxmail.com</a>)</p>
<p class="date" style="margin: 5px 10px; text-indent: 40px;">Date: 2014-02-09 日</p>
</div>



            <a href="/clojure/clojure%25e8%25bf%259b%25e9%2598%25b6%25e6%2595%25b0%25e5%25ad%25a6%25e8%25ae%25a1%25e7%25ae%2597.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e4%25b8%2593%25e9%25a2%2598%25e6%2596%2587%25e4%25bb%25b6%25e5%25a4%2584%25e7%2590%2586.html">Clojure专题:文件处理</a></h2>

            <p class="post-meta">By 02月08日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <p>本文翻译自<a href="http://clojure-doc.org/articles/cookbooks/files_and_directories.html">Working with Files and Directories in Clojure</a><br />
本文介绍使用Clojure的clojure.java.io命名空间下的函数以及JDK相关方法来<br />
操作文件和目录.<br />
版权:This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets). The source is available on Github.</p>
<p></p>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 准备</a></li>
<li><a href="#sec-2">2 方法</a>
<ul>
<li><a href="#sec-2-1">2.1 将文件读到字符串中</a></li>
<li><a href="#sec-2-2">2.2 一行一行的读取文件</a></li>
<li><a href="#sec-2-3">2.3 将字符串写到文件中</a></li>
<li><a href="#sec-2-4">2.4 每次向文件中写一行</a></li>
<li><a href="#sec-2-5">2.5 检查文件是否存在</a></li>
<li><a href="#sec-2-6">2.6 获取给定目录下的文件列表和目录列表</a></li>
</ul>
</li>
<li><a href="#sec-3">3 更多内容</a></li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">准备</h2>
<div class="outline-text-2" id="text-1">
<p>请注意,在下面的例子中,"io"是clojure.java.io命名空间的简写引用.请确保你<br />
的ns宏包含如下代码:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #2aa198;">:require</span> [clojure.java.io <span style="color: #2aa198;">:as</span> io]<span style="color: #8c8c8c;">)</span>
</pre>
<p>或者在REPL中加载了:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> '[clojure.java.io <span style="color: #2aa198;">:as</span> io]<span style="color: #8c8c8c;">)</span>
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">方法</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">将文件读到字符串中</h3>
<div class="outline-text-3" id="text-2-1">
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">a-long-string</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> <span style="color: #2aa198;">"foo.txt"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>注意,你可一给slurp函数传递url.请看<a href="http://clojuredocs.org/clojure_core/clojure.core/slurp">slurp文档</a></p>
<p></p>
</div>
</div>
<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">一行一行的读取文件</h3>
<div class="outline-text-3" id="text-2-2">
<p>假设你想针对文件的每行内容调用my-func函数,并返回结果序列:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">with-open</span> [rdr <span style="color: #8c8c8c;">(</span>io/reader <span style="color: #2aa198;">"foo.txt"</span><span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">doall</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> my-func <span style="color: #8c8c8c;">(</span><span style="color: #859900;">line-seq</span> rdr<span style="color: #8c8c8c;">))))</span>
</pre>
<p>doall函数是必须的,因为map函数返回的是个lazy序列.line-seq返回的每行内容<br />
没有是去除了末尾的回车标记的,且空行将返回空字符串.</p>
<p></p>
</div>
</div>
<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">将字符串写到文件中</h3>
<div class="outline-text-3" id="text-2-3">
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">spit</span> <span style="color: #2aa198;">"foo.txt"</span>
      <span style="color: #2aa198;">"A long</span>
<span style="color: #2aa198;">multi-line string.</span>
<span style="color: #2aa198;">Bye."</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>如果foo.txt文件不存在则会创建,如果存在,将会覆盖其内容.如果想追加内容,<br />
而不是覆盖:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">spit</span> <span style="color: #2aa198;">"foo.txt"</span> <span style="color: #2aa198;">"file content"</span> <span style="color: #2aa198;">:append</span> true<span style="color: #8c8c8c;">)</span>
</pre>
</div>
</div>
<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4">每次向文件中写一行</h3>
<div class="outline-text-3" id="text-2-4">
<p>假设你想将vector里的内容写到文件中,每个元素一行:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">with-open</span> [wrtr <span style="color: #8c8c8c;">(</span>io/writer <span style="color: #2aa198;">"foo.txt"</span><span style="color: #8c8c8c;">)</span>]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">doseq</span> [i my-vec]
    <span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.write</span> wrtr <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> i <span style="color: #2aa198;">"\n"</span><span style="color: #8c8c8c;">))))</span>
</pre>
</div>
</div>
<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5">检查文件是否存在</h3>
<div class="outline-text-3" id="text-2-5">
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.exists</span> <span style="color: #8c8c8c;">(</span>io/file <span style="color: #2aa198;">"filename.txt"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>判断是否是目录:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.isDirectory</span> <span style="color: #8c8c8c;">(</span>io/file <span style="color: #2aa198;">"path/to/something"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>io/file是java.io.File对象(文件或目录).你能直接调用该对象上的方法,包括:</p>
<p></p>
<pre class="example">exists        文件是否存在?
isDirectory   文件还是目录?
getName       获取文件名字
getParent     过去文件所在目录名称
getPath       获取文件全路径
mkdir         创建目录
</pre>
<p>更多内容前查看<a href="http://docs.oracle.com/javase/7/docs/api/java/io/File.html">java.io.File</a></p>
<p></p>
</div>
</div>
<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6">获取给定目录下的文件列表和目录列表</h3>
<div class="outline-text-3" id="text-2-6">
<p>对于File对象:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.listFiles</span> <span style="color: #8c8c8c;">(</span>io/file <span style="color: #2aa198;">"path/to/some-dir"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>上面的方法返回File对象序列,如果想返回字符串序列:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.list</span> <span style="color: #8c8c8c;">(</span>io/file <span style="color: #2aa198;">"path/to/some-dir"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>所有的结果都是列表形式的,可使用Clojure中的seq相关函数对其操作.</p>
<p></p>
</div>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">更多内容</h2>
<div class="outline-text-2" id="text-3">
<p><a href="https://github.com/Raynes/fs">https://github.com/Raynes/fs</a><br />
<a href="http://clojure.org/cheatsheet">cheatsheet</a>的I/O节</p>
</div>
</div>



            <a href="/clojure/clojure%25e4%25b8%2593%25e9%25a2%2598%25e6%2596%2587%25e4%25bb%25b6%25e5%25a4%2584%25e7%2590%2586.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e4%25b8%2593%25e9%25a2%2598%25e5%25ad%2597%25e7%25ac%25a6%25e4%25b8%25b2%25e5%25a4%2584%25e7%2590%2586.html">Clojure专题:字符串处理</a></h2>

            <p class="post-meta">By 02月05日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <ul>
<li>本文翻译自<a href="http://clojure-doc.org/articles/cookbooks/strings.html">Strings</a>
</li>
<li>本文内容包括使用Clojure内建的函数和标准库来操作字符串,以及JDK中的相关操作.
</li>
<li>版权:This work is licensed under a Creative Commons Attribution 3.0 Unported License (including images &amp; stylesheets).
</li>
<li>源代码在<a href="https://github.com/clojuredocs/guides">Github</a>上.
</li>
</ul>
<p></p>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 概述</a></li>
<li><a href="#sec-2">2 预备知识</a></li>
<li><a href="#sec-3">3 方法</a>
<ul>
<li><a href="#sec-3-1">3.1 基础方法</a></li>
<li><a href="#sec-3-2">3.2 解析复杂字符串</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 正则表达式</a></li>
<li><a href="#sec-3-2-2">3.2.2 上下文无关语法</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 构建复杂的字符串</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1 重定向</a></li>
<li><a href="#sec-3-3-2">3.3.2 格式化字符串</a></li>
<li><a href="#sec-3-3-3">3.3.3 CL-Format</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4 贡献者</a></li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">概述</h2>
<div class="outline-text-2" id="text-1">
<ul>
<li>Clojure中的字符串就是Java字符串.你可以使用Java中的相应方法来对其进行处理.
</li>
<li>Java字符串是不可变的,所以能很方便的在Clojure中使用
</li>
<li>你不能给Java字符串添加元数据
</li>
<li>Clojure提供一些方便的符号
</li>
</ul>
<p></p>
<pre class="example">"foo"    java.lang.String
#"\d"    java.util.regex.Pattern (正则表达式,匹配一个数字)
\f       java.lang.Character (表示'f')
</pre>
<ul>
<li><b>注意</b>: 人类的大脑和计算机之间还是有很大的差异的.所以Java的字符串(UTF-16编码)并不能像人们所认为的那样很好的和字符一一对应.比如说,一个Unicode的位和我们所认为的字符的一位是无法对应的(像韩国 韩语尊宝,这些词由多个字符组成.)同样的,一个Unicode位可能是由2个UTF-16字符组成.
</li>
</ul>
<p></p>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">预备知识</h2>
<div class="outline-text-2" id="text-2">
<p>一些例子用到了clojure.string,clojure.edn和clojure.pprint.我们假设你的ns宏里面已经包含了如下内容:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #2aa198;">:require</span> [clojure.string <span style="color: #2aa198;">:as</span> str]
          [clojure.edn <span style="color: #2aa198;">:as</span> edn]
          [clojure.pprint <span style="color: #2aa198;">:as</span> pp]<span style="color: #8c8c8c;">)</span>
</pre>
<p>或者在REPL里面,你需要载入:</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> '[clojure.string <span style="color: #2aa198;">:as</span> str]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> '[clojure.edn <span style="color: #2aa198;">:as</span> edn]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> '[clojure.pprint <span style="color: #2aa198;">:as</span> pp]<span style="color: #8c8c8c;">)</span>
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">方法</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">基础方法</h3>
<div class="outline-text-3" id="text-3-1">
<p></p>
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#38271;&#24230;&#35745;&#31639;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">count</span> <span style="color: #2aa198;">"0123"</span><span style="color: #8c8c8c;">)</span>      <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 4</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">empty?</span> <span style="color: #2aa198;">"0123"</span><span style="color: #8c8c8c;">)</span>     <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; false</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">empty?</span> <span style="color: #2aa198;">""</span><span style="color: #8c8c8c;">)</span>         <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; true</span>
<span style="color: #8c8c8c;">(</span>str/blank? <span style="color: #2aa198;">"    "</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; true</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#23383;&#31526;&#20018;&#36830;&#25509;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> <span style="color: #2aa198;">"foo"</span> <span style="color: #2aa198;">"bar"</span><span style="color: #8c8c8c;">)</span>            <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "foobar" </span>
<span style="color: #8c8c8c;">(</span>str/<span style="color: #b58900;">join</span> [<span style="color: #2aa198;">"0"</span> <span style="color: #2aa198;">"1"</span> <span style="color: #2aa198;">"2"</span>]<span style="color: #8c8c8c;">)</span>     <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "012"</span>
<span style="color: #8c8c8c;">(</span>str/<span style="color: #b58900;">join</span> <span style="color: #2aa198;">"."</span> [<span style="color: #2aa198;">"0"</span> <span style="color: #2aa198;">"1"</span> <span style="color: #2aa198;">"2"</span>]<span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "0.1.2"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#20351;&#29992;Java&#26041;&#27861;&#26469;&#21305;&#37197;.</span>
<span style="color: #93a1a1; font-style: italic;">;;</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#23545;&#20110;&#19979;&#38754;&#30340;&#24773;&#20917;,&#20320;&#24212;&#35813;&#26356;&#21916;&#27426;&#20351;&#29992;&#27491;&#21017;&#34920;&#36798;&#24335;.&#27604;&#22914;,&#20320;&#22312;&#36827;&#34892;&#27979;&#35797;,&#24403;&#22833;&#36133;&#26102;&#38656;&#35201;&#36820;&#22238;-1.</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#25110;&#32773;&#19968;&#20010;&#23383;&#31526;\o&#38656;&#35201;&#36716;&#25442;&#25104;&#23383;&#31526;&#20018;&#25110;&#25968;&#23383;.</span>
<span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.indexOf</span> <span style="color: #2aa198;">"foo"</span> <span style="color: #2aa198;">"oo"</span><span style="color: #8c8c8c;">)</span>         <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 1</span>
<span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.indexOf</span> <span style="color: #2aa198;">"foo"</span> <span style="color: #2aa198;">"x"</span><span style="color: #8c8c8c;">)</span>          <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; -1</span>
<span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.lastIndexOf</span> <span style="color: #2aa198;">"foo"</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">int</span> \o<span style="color: #8c8c8c;">))</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 2</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#23383;&#31526;&#20018;&#25130;&#21462;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">subs</span> <span style="color: #2aa198;">"0123"</span> 1<span style="color: #8c8c8c;">)</span>       <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "123"</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">subs</span> <span style="color: #2aa198;">"0123"</span> 1 3<span style="color: #8c8c8c;">)</span>     <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "12"</span>
<span style="color: #8c8c8c;">(</span>str/trim <span style="color: #2aa198;">"  foo  "</span><span style="color: #8c8c8c;">)</span>  <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "foo"</span>
<span style="color: #8c8c8c;">(</span>str/triml <span style="color: #2aa198;">"  foo  "</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "foo  "</span>
<span style="color: #8c8c8c;">(</span>str/trimr <span style="color: #2aa198;">"  foo  "</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "  foo"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#20999;&#20998;&#23383;&#31526;&#20018;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">seq</span> <span style="color: #2aa198;">"foo"</span><span style="color: #8c8c8c;">)</span>                       <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; (\f \o \o)</span>
<span style="color: #8c8c8c;">(</span>str/split <span style="color: #2aa198;">"foo/bar/quux"</span> #<span style="color: #2aa198;">"/"</span><span style="color: #8c8c8c;">)</span>   <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; ["foo" "bar" "quux"]</span>
<span style="color: #8c8c8c;">(</span>str/split <span style="color: #2aa198;">"foo/bar/quux"</span> #<span style="color: #2aa198;">"/"</span> 2<span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; ["foo" "bar/quux"]</span>
<span style="color: #8c8c8c;">(</span>str/split-lines <span style="color: #2aa198;">"foo</span>
<span style="color: #2aa198;">bar"</span><span style="color: #8c8c8c;">)</span>                             <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; ["foo" "bar"]</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#22823;&#23567;&#20889;&#36716;&#25442;</span>
<span style="color: #8c8c8c;">(</span>str/lower-case <span style="color: #2aa198;">"fOo"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "foo"</span>
<span style="color: #8c8c8c;">(</span>str/upper-case <span style="color: #2aa198;">"fOo"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "FOO"</span>
<span style="color: #8c8c8c;">(</span>str/capitalize <span style="color: #2aa198;">"fOo"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "Foo"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#36716;&#25442; </span>
<span style="color: #8c8c8c;">(</span>str/escape <span style="color: #2aa198;">"foo|bar|quux"</span> {\| <span style="color: #2aa198;">"||"</span>}<span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "foo||bar||quux"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#33719;&#24471;&#32473;&#23450;&#32534;&#30721;&#30340;&#23383;&#33410;&#25968;&#32452;</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">(&#36755;&#20986;&#21487;&#33021;&#21644;&#19979;&#38754;&#30340;"3c3660"&#19981;&#21516;)</span>
<span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">.getBytes</span> <span style="color: #2aa198;">"foo"</span> <span style="color: #2aa198;">"UTF-8"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; #&lt;byte[] [B@3c3660&gt;</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#35299;&#26512;&#20026;keyword</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">keyword</span> <span style="color: #2aa198;">"foo"</span><span style="color: #8c8c8c;">)</span>    <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; :foo</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#35299;&#26512;&#20026;&#25968;&#23383;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">bigint</span> <span style="color: #2aa198;">"20000000000000000000000000000"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 20000000000000000000000000000N</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">bigdec</span> <span style="color: #2aa198;">"20000000000000000000.00000000"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 20000000000000000000.00000000M</span>
<span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Integer/parseInt</span> <span style="color: #2aa198;">"2"</span><span style="color: #8c8c8c;">)</span>                   <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 2</span>
<span style="color: #8c8c8c;">(</span><span style="color: #cb4b16;">Float/parseFloat</span> <span style="color: #2aa198;">"2"</span><span style="color: #8c8c8c;">)</span>                   <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 2.0</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#35299;&#26512;&#20026;edn,&#23427;&#26159;Clojure&#24418;&#24335;&#30340;&#19968;&#20010;&#23376;&#38598;</span>
<span style="color: #8c8c8c;">(</span>edn/read-string <span style="color: #2aa198;">"0xffff"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; 65535</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#35835;&#21462;Clojure&#24418;&#24335;&#30340;&#26041;&#27861;.</span>
<span style="color: #93a1a1; font-style: italic;">;;</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#23433;&#20840;&#35686;&#21578;:&#24403;&#20320;&#26080;&#27861;&#30830;&#20445;&#20320;&#33021;100%&#20449;&#20219;&#35201;&#22788;&#29702;&#30340;&#23383;&#31526;&#20018;&#26102;,&#35831;&#23558;*read-eval*&#32622;&#20026;false.</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#20174;Clojure1.5&#24320;&#22987;*read-eval*&#40664;&#35748;&#20026;false,&#20294;&#20026;&#20102;&#23433;&#20840;&#36215;&#35265;,</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#22312;&#22788;&#29702;&#23383;&#31526;&#20018;&#26102;&#36824;&#26159;&#20808;&#25163;&#21160;&#32622;&#19968;&#19979;false</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#22240;&#20026;&#21487;&#33021;&#26377;&#25805;&#20316;&#23558;&#20854;&#32622;&#20026;&#20102;true.</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">binding</span> [*read-eval* false]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">read-string</span> <span style="color: #2aa198;">"#\"[abc]\""</span><span style="color: #8c8c8c;">))</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; #"[abc]"</span>
</pre>
</div>
</div>
<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2">解析复杂字符串</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">正则表达式</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>正则表达式增强了字符串匹配.你可以重复匹配,匹配其中之一,等等等等.</p>
<ul>
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html">Regex reference</a>
</li>
</ul>
<p><b>Groups</b>:当我们想匹配多余一个子串时,正则表达式的组就起到了作用. 在正则表达式#"(group-1) (group-2)"中, 第0个组为整个匹配表达式.第1个组从最左边的(开始,第2个组从左起第二个(开始,依次类推.你还可以嵌套组.也可以后续通过$0,$1等来引用组.</p>
<p></p>
<ul>
<li id="sec-3-2-1-1">匹配
<p></p>
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#31616;&#21333;&#21305;&#37197;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">re-find</span> #<span style="color: #2aa198;">"\d+"</span> <span style="color: #2aa198;">"foo 123 bar"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "123"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#21305;&#37197;&#19981;&#21040;&#26102;&#20250;&#24590;&#26679;?</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">re-find</span> #<span style="color: #2aa198;">"\d+"</span> <span style="color: #2aa198;">"foobar"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; nil</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#23545;&#27599;&#20010;&#32452;&#36820;&#22238;&#31532;&#19968;&#20010;&#28385;&#36275;&#21305;&#37197;&#26465;&#20214;&#30340;&#20869;&#23481;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">re-matches</span> #<span style="color: #2aa198;">"(@\w+)\s([.0-9]+)%"</span>
            <span style="color: #2aa198;">"@shanley 19.8%"</span><span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt;["@shanley 19.8%" "@shanley" "19.8"]</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#36820;&#22238;&#25152;&#26377;&#21305;&#37197;&#30340;&#32452;&#30340;&#32467;&#26524;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">re-seq</span> #<span style="color: #2aa198;">"(@\w+)\s([.0-9]+)%"</span>
        <span style="color: #2aa198;">"@davidgraeber 12.3%,@shanley 19.8%"</span><span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; (["@davidgraeber 12.3%" "@davidgraeber" "12.3"]</span>
<span style="color: #93a1a1; font-style: italic;">;    </span><span style="color: #93a1a1; font-style: italic;">["@shanley 19.8%" "@shanley" "19.8"])</span>
</pre>
</li>
</ul>
<ul>
<li id="sec-3-2-1-2">替换<br />
我们使用str/replace来进行替换. 第一个参数是源字符串,下一个是匹配字符串,最后一个是替换的内容.</p>
<p></p>
<pre class="example">match / replacement can be:
string / string
char / char
pattern / (string or function of match).
</pre>
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#22312;&#26367;&#25442;&#23383;&#31526;&#20018;&#20013;,$0,$1&#31561;&#29992;&#26469;&#24341;&#29992;&#21305;&#37197;&#23383;&#31526;&#20018;&#20013;&#30340;&#32452;.</span>
<span style="color: #8c8c8c;">(</span>str/<span style="color: #b58900;">replace</span> <span style="color: #2aa198;">"@davidgraeber 12.3%,@shanley 19.8%"</span>
             #<span style="color: #2aa198;">"(@\S+)\s([.0-9]+)%"</span>
             <span style="color: #2aa198;">"$2 ($1)"</span><span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "12.3 (@davidgraeber),19.8 (@shanley)"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#20351;&#29992;&#20989;&#25968;&#26469;&#26367;&#25442;&#23383;&#31526;&#20018;,&#26356;&#28789;&#27963;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span>
  <span style="color: #8c8c8c;">(</span>str/<span style="color: #b58900;">replace</span> <span style="color: #2aa198;">"@davidgraeber 12.3%,@shanley 19.8%"</span>
               #<span style="color: #2aa198;">"(@\w+)\s([.0-9]+)%,?"</span>
               <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [[_ person percent]]
                   <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [points <span style="color: #8c8c8c;">(</span><span style="color: #859900;">-&gt;</span> percent <span style="color: #cb4b16;">Float/parseFloat</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">*</span> 100<span style="color: #8c8c8c;">)</span> <span style="color: #cb4b16;">Math/round</span><span style="color: #8c8c8c;">)</span>]
                     <span style="color: #8c8c8c;">(</span><span style="color: #859900;">str</span> person <span style="color: #2aa198;">"'s followers grew "</span> points <span style="color: #2aa198;">" points.\n"</span><span style="color: #8c8c8c;">)))))</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">print=&gt; @davidgraeber's followers grew 1230 points.</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">print=&gt; @shanley's followers grew 1980 points.</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">print=&gt;</span>
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">上下文无关语法</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>和正则表达式相比上下文无关语法提供了更具表现力的匹配方式.你能使用例如嵌套来表达想法.<br />
我们将在JSON语法上使用<a href="https://github.com/Engelberg/instaparse">Instapares</a>.(这个例子没有经过严格的测试也没什么特色.如果想应用到实际开发中,请使用<a href="https://github.com/clojure/data.json">data.json</a>)</p>
<p></p>
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#20320;&#39033;&#30446;&#20013;&#30340;project.clj&#38656;&#35201;&#21253;&#21547;&#22914;&#19979;&#20381;&#36182;(&#20320;&#21487;&#33021;&#38656;&#35201;&#37325;&#21551;JVM)</span>
<span style="color: #93a1a1; font-style: italic;">;;   </span><span style="color: #93a1a1; font-style: italic;">:dependencies [[instaparse "1.2.4"]]</span>
<span style="color: #93a1a1; font-style: italic;">;;</span>
<span style="color: #93a1a1; font-style: italic;">;;  </span><span style="color: #93a1a1; font-style: italic;">&#25105;&#20204;&#20551;&#35774;&#20320;&#30340;ns&#23439;&#21253;&#21547;&#20102;&#22914;&#19979;&#20869;&#23481;:</span>
<span style="color: #93a1a1; font-style: italic;">;;   </span><span style="color: #93a1a1; font-style: italic;">(:require [instaparse.core :as insta])</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#25110;&#20320;&#22312;REPL&#37324;&#21152;&#36733;&#20102;:</span>
<span style="color: #93a1a1; font-style: italic;">;;   </span><span style="color: #93a1a1; font-style: italic;">(require '[instaparse.core :as insta])</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">barely-tested-json-parser</span>
  <span style="color: #8c8c8c;">(</span>insta/parser
   <span style="color: #2aa198;">"object     = &lt;'{'&gt; &lt;w*&gt; (members &lt;w*&gt;)* &lt;'}'&gt;</span>
<span style="color: #2aa198;">    &lt;members&gt;  = pair (&lt;w*&gt; &lt;','&gt; &lt;w*&gt; members)*</span>
<span style="color: #2aa198;">    &lt;pair&gt;     = string &lt;w*&gt; &lt;':'&gt; &lt;w*&gt; value</span>
<span style="color: #2aa198;">    &lt;value&gt;    = string | number | object | array | 'true' | 'false' | 'null'</span>
<span style="color: #2aa198;">    array      = &lt;'['&gt; elements* &lt;']'&gt;</span>
<span style="color: #2aa198;">    &lt;elements&gt; = value &lt;w*&gt; (&lt;','&gt; &lt;w*&gt; elements)*</span>
<span style="color: #2aa198;">    number     = int frac? exp?</span>
<span style="color: #2aa198;">    &lt;int&gt;      = '-'? digits</span>
<span style="color: #2aa198;">    &lt;frac&gt;     = '.' digits</span>
<span style="color: #2aa198;">    &lt;exp&gt;      = e digits</span>
<span style="color: #2aa198;">    &lt;e&gt;        = ('e' | 'E') (&lt;'+'&gt; | '-')?</span>
<span style="color: #2aa198;">    &lt;digits&gt;   = #'[0-9]+'</span>
<span style="color: #2aa198;">    (* First sketched state machine; then it was easier to figure out</span>
<span style="color: #2aa198;">       regex syntax and all the maddening escape-backslashes. *)</span>
<span style="color: #2aa198;">    string     = &lt;'\\"'&gt; #'([^\"\\]|\\.)*' &lt;'\\"'&gt;</span>
<span style="color: #2aa198;">    &lt;w&gt;        = #'\s+'"</span><span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span>barely-tested-json-parser <span style="color: #2aa198;">"{\"foo\": {\"bar\": 99.9e-9, \"quux\": [1, 2, -3]}}"</span><span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; [:object</span>
<span style="color: #93a1a1; font-style: italic;">;     </span><span style="color: #93a1a1; font-style: italic;">[:string "foo"]</span>
<span style="color: #93a1a1; font-style: italic;">;     </span><span style="color: #93a1a1; font-style: italic;">[:object</span>
<span style="color: #93a1a1; font-style: italic;">;       </span><span style="color: #93a1a1; font-style: italic;">[:string "bar"]</span>
<span style="color: #93a1a1; font-style: italic;">;       </span><span style="color: #93a1a1; font-style: italic;">[:number "99" "." "9" "e" "-" "9"]</span>
<span style="color: #93a1a1; font-style: italic;">;       </span><span style="color: #93a1a1; font-style: italic;">[:string "quux"]</span>
<span style="color: #93a1a1; font-style: italic;">;       </span><span style="color: #93a1a1; font-style: italic;">[:array [:number "1"] [:number "2"] [:number "-" "3"]]]]</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#26368;&#21518;&#30340;&#36755;&#20986;&#26377;&#28857;&#21872;&#21990;,&#25105;&#20204;&#25913;&#36827;&#19968;&#19979;.</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">-&gt;&gt;</span> <span style="color: #8c8c8c;">(</span>barely-tested-json-parser <span style="color: #2aa198;">"{\"foo\": {\"bar\": 99.9e-9, \"quux\": [1, 2, -3]}}"</span><span style="color: #8c8c8c;">)</span>
     <span style="color: #8c8c8c;">(</span>insta/transform {<span style="color: #2aa198;">:object</span> hash-map
                       <span style="color: #2aa198;">:string</span> str
                       <span style="color: #2aa198;">:array</span> vector
                       <span style="color: #2aa198;">:number</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comp</span> edn/read-string str<span style="color: #8c8c8c;">)</span>}<span style="color: #8c8c8c;">))</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; {"foo" {"quux" [1 2 -3], "bar" 9.99E-8}}</span>


<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#25152;&#26377;&#30340;&#20869;&#23481;&#37117;&#22312;&#19978;&#38754;&#20102; </span>
<span style="color: #93a1a1; font-style: italic;">;;</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">=&#21491;&#36793;&#30340;&#35821;&#27861;&#20027;&#35201;&#29992;&#26469;&#38544;&#34255;&#22810;&#20313;&#20449;&#24687;.&#27604;&#22914;&#35828;,&#25105;&#20204;&#19981;&#20851;&#24515;&#31354;&#26684;,&#25152;&#20197;&#25105;&#20204;&#36890;&#36807;&#35774;&#32622;&lt;w*&gt;&#26469;&#38544;&#34255;</span>
<span style="color: #93a1a1; font-style: italic;">;;</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">=&#24038;&#36793;&#30340;&#35821;&#27861;&#21482;&#26159;&#29992;&#26469;&#36991;&#20813;&#23884;&#22871;&#36755;&#20986;&#30340;.&#20363;&#22914;,"members"&#20165;&#20165;&#26159;&#19968;&#20010;&#20154;&#20026;&#35774;&#32622;&#30340;&#23454;&#20307;, </span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#25152;&#20197;&#25105;&#20204;&#38459;&#27490;&#20102;&#36825;&#20010;&#26080;&#24847;&#20041;&#30340;&#23884;&#22871;&#20851;&#31995;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3">构建复杂的字符串</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">重定向</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>with-out-str提供了一个简单的方法来构建字符串.它重定向标准输出(<b>out</b>)到StringWriter,然后返回结果字符串.这样你就可以使用print这样的函数来获得字符串(即使在嵌套函数中)</p>
<p></p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [shrimp-varieties [<span style="color: #2aa198;">"shrimp-kabobs"</span> <span style="color: #2aa198;">"shrimp creole"</span> <span style="color: #2aa198;">"shrimp gumbo"</span>]]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">with-out-str</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">print</span> <span style="color: #2aa198;">"We have "</span><span style="color: #8c8c8c;">)</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">doseq</span> [name <span style="color: #8c8c8c;">(</span>str/<span style="color: #b58900;">join</span> <span style="color: #2aa198;">", "</span> shrimp-varieties<span style="color: #8c8c8c;">)</span>]
      <span style="color: #8c8c8c;">(</span><span style="color: #859900;">print</span> name<span style="color: #8c8c8c;">))</span>
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">print</span> <span style="color: #2aa198;">"..."</span><span style="color: #8c8c8c;">)))</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "We have shrimp-kabobs, shrimp creole, shrimp gumbo..."</span>
</pre>
</div>
</div>
<div id="outline-container-3-3-2" class="outline-4">
<h4 id="sec-3-3-2">格式化字符串</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>Java里的模板能帮助你方便的构造字符串.<a href="http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html">Reference</a></p>
<p></p>
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">%s&#32463;&#24120;&#20250;&#20316;&#20026;print&#30340;&#21442;&#25968;. &#32780;%&#38656;&#35201;&#20351;&#29992;%%</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">format</span> <span style="color: #2aa198;">"%s enjoyed %s%%."</span> <span style="color: #2aa198;">"Mozambique"</span> 19.8<span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "Mozambique enjoyed 19.8%."</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">1$&#21069;&#32512;&#33021;&#24341;&#29992;&#21040;&#20854;&#21518;&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">format</span> <span style="color: #2aa198;">"%1$tY-%1$tm-%1$latex td"</span> #inst<span style="color: #2aa198;">"2000-01-02T00:00:00"</span><span style="color: #8c8c8c;">)</span> <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "2000-01-02"</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">&#21516;&#19978;1$, 2$&#21069;&#32512;&#21487;&#20197;&#24341;&#29992;&#20854;&#21518;&#38754;&#30340;&#21442;&#25968;</span>
<span style="color: #8c8c8c;">(</span><span style="color: #859900;">format</span> <span style="color: #2aa198;">"New year: %2$tY. Old year: %1$tY"</span>
        #inst<span style="color: #2aa198;">"2000-01-02T00:00:00"</span>
        #inst<span style="color: #2aa198;">"3111-12-31T00:00:00"</span><span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "New year: 3111. Old year: 2000"</span>
</pre>
</div>
</div>
<div id="outline-container-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">CL-Format</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>cl-format是Common Lisp中的一个臭名昭著的功能.例如,你可以从序列来构建字符串(其怪异程度就像使用英文来表示数字,使用两种类型的罗马数字).但对于打印日期和上面的对无序参数的引用方面却又比普通的格式化功能弱.</p>
<p>
你只需要记住cl-format就是个无人问津的不值一学的语言.但是如果你喜欢并想学习它,那么看<a href="http://www.gigamonkeys.com/book/a-few-format-recipes.html">Practical Common Lisp教程</a>.或者<a href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">Common Lisp手册</a></p>
<p></p>
<pre class="src src-clojure"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">The first param prints to *out* if true. To string if false.</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">To a stream if it's a stream.</span>
<span style="color: #8c8c8c;">(</span>pp/cl-format true <span style="color: #2aa198;">"~{~{~a had ~s percentage point~:p.~}~^~%~}"</span>
              {<span style="color: #2aa198;">"@davidgraeber"</span> 12.3
               <span style="color: #2aa198;">"@shanley"</span> 19.8
               <span style="color: #2aa198;">"@tjgabbour"</span> 1}<span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">print=&gt; @davidgraeber had 12.3 percentage points.</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">print=&gt; @tjgabbour had 1 percentage point.</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">print=&gt; @shanley had 19.8 percentage points.</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">format-string</span> <span style="color: #2aa198;">"~{~#[~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~}"</span><span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span>pp/cl-format nil format-string []<span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; ""</span>
<span style="color: #8c8c8c;">(</span>pp/cl-format nil format-string [<span style="color: #2aa198;">"@shanley"</span>]<span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "@shanley"</span>
<span style="color: #8c8c8c;">(</span>pp/cl-format nil format-string [<span style="color: #2aa198;">"@shanley"</span>, <span style="color: #2aa198;">"@davidgraeber"</span>]<span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "@shanley and @davidgraeber"</span>
<span style="color: #8c8c8c;">(</span>pp/cl-format nil format-string [<span style="color: #2aa198;">"@shanley"</span>, <span style="color: #2aa198;">"@davidgraeber"</span>, <span style="color: #2aa198;">"@sarahkendzior"</span>]<span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">=&gt; "@shanley, @davidgraeber, and @sarahkendzior"</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">贡献者</h2>
<div class="outline-text-2" id="text-4">
<p>Tj Gabbour tjg@simplevalue.de, 2013 (original author)</p>
<p></p>
</div>
</div>



            <a href="/clojure/clojure%25e4%25b8%2593%25e9%25a2%2598%25e5%25ad%2597%25e7%25ac%25a6%25e4%25b8%25b2%25e5%25a4%2584%25e7%2590%2586.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/%25e7%25bc%2596%25e7%25a8%258b%25e8%25af%25ad%25e8%25a8%2580%25e5%258f%2591%25e5%25b1%2595%25e7%259a%2584%25e7%25bc%2596%25e5%25b9%25b4%25e5%258f%25b2.html">编程语言发展的编年史</a></h2>

            <p class="post-meta">By 01月30日  2014  



 
<a class="post-categorybut " href="/type/#技术相关"><i class="fa fa-folder-open"></i> 技术相关 (6)</a>


  

  

            </p>
        </header>

        <div class="post-description">
            <h4 style="box-sizing: border-box; color: rgb(17, 17, 17); font-family: Georgia, ‘vardana’, Times, serif; line-height: 21.983333587646484px; margin: 0px 0px 1.571em; padding: 10px 10px 10px 45px; font-size: 18px; background-color: rgb(227, 240, 242); border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgb(102, 204, 204); background-position: 7px 50%; background-repeat: no-repeat no-repeat;">
	Development of Programming Language By Year :-<br />
</h4>
<ul style="box-sizing: border-box; margin: 0px 0px 2.6rem 4rem; padding-right: 0px; padding-left: 0px; font-family: Verdana, Geneva, sans-serif; font-size: 16px; line-height: 26px;">
<li style="box-sizing: border-box; list-style-type: disc;">
		1951 &ndash; Regional Assembly Language
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1952 &ndash; Autocode
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1954 &ndash; IPL (forerunner to LISP)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1955 &ndash; FLOW-MATIC (forerunner to COBOL)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1957 &ndash; FORTRAN (First compiler)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1957 &ndash; COMTRAN (forerunner to COBOL)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1958 &ndash; LISP
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1958 &ndash; ALGOL 58
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1959 &ndash; FACT (forerunner to COBOL)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1959 &ndash; COBOL
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1959 &ndash; RPG
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1962 &ndash; APL
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1962 &ndash; Simula
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1962 &ndash; SNOBOL
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1963 &ndash; CPL (forerunner to C)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1964 &ndash; BASIC
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1964 &ndash; PL/I
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1966 &ndash; JOSS
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1967 &ndash; BCPL (forerunner to C)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1968 &ndash; Logo
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1969 &ndash; B (forerunner to C)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1970 &ndash; Pascal
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1970 &ndash; Forth
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1972 &ndash; C
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1972 &ndash; Smalltalk
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1972 &ndash; Prolog
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1973 &ndash; ML
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1975 &ndash; Scheme
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1978 &ndash; SQL
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1980 &ndash; C++ (as C with classes, name changed in July 1983)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1983 &ndash; Ada
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1984 &ndash; Common Lisp
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1984 &ndash; MATLAB
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1985 &ndash; Eiffel
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1986 &ndash; Objective-C
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1986 &ndash; Erlang
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1987 &ndash; Perl
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1988 &ndash; Tcl
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1988 &ndash; Mathematica
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1989 &ndash; FL
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1990 &ndash; Haskell
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1991 &ndash; Python
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1991 &ndash; Visual Basic
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1993 &ndash; Ruby
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1993 &ndash; Lua
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1994 &ndash; CLOS (part of ANSI Common Lisp)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1995 &ndash; Java
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1995 &ndash; Delphi (Object Pascal)
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1995 &ndash; JavaScript
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1995 &ndash; PHP
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1996 &ndash; WebDNA
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1997 &ndash; Rebol
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		1999 &ndash; D
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2000 &ndash; ActionScript
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2001 &ndash; C#
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2001 &ndash; Visual Basic .NET
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2002 &ndash; F#
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2003 &ndash; Groovy
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2003 &ndash; Scala
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2007 &ndash; Clojure
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2009 &ndash; Go
	</li>
<li style="box-sizing: border-box; list-style-type: disc;">
		2011 &ndash; Dart
	</li>
</ul>
<p>
	&nbsp;原文地址:<a href="http://www.justwebworld.com/history-programming-languages-infographic.html">http://www.justwebworld.com/history-programming-languages-infographic.html</a></p>



            <a href="/%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3/%25e7%25bc%2596%25e7%25a8%258b%25e8%25af%25ad%25e8%25a8%2580%25e5%258f%2591%25e5%25b1%2595%25e7%259a%2584%25e7%25bc%2596%25e5%25b9%25b4%25e5%258f%25b2.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>




    <section class="post">
        <header class="post-header">
            <img class="post-avatar" height="48" width="48"
                 src="">

            <h2 class="post-title"><a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b-%25e5%259f%25ba%25e6%259c%25ac%25e8%25af%25ad%25e6%25b3%2595.html">Clojure教程-基本语法</a></h2>

            <p class="post-meta">By 01月06日  2014  



 
<a class="post-categorybut " href="/type/#clojure"><i class="fa fa-folder-open"></i> clojure (11)</a>


  



		  
			 
<a class="post-category " href="/tag/#"><i class="fa fa-tags"></i> clojure (10)</a>

		  
		  
		  

            </p>
        </header>

        <div class="post-description">
            <div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 简介</a></li>
<li><a href="#sec-2">2 核心语法</a></li>
<li><a href="#sec-3">3 代码功能</a>
<ul>
<li><a href="#sec-3-1">3.1 读取简繁字典</a></li>
<li><a href="#sec-3-2">3.2 进行简繁翻译</a></li>
<li><a href="#sec-3-3">3.3 读取不需要翻译的文字</a></li>
<li><a href="#sec-3-4">3.4 过滤不翻译的文字</a></li>
<li><a href="#sec-3-5">3.5 提供给Java调用</a></li>
<li><a href="#sec-3-6">3.6 打包</a></li>
</ul>
</li>
<li><a href="#sec-4">4 源码</a></li>
</ul>
</div>
</div>
<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">简介</h2>
<div class="outline-text-2" id="text-1">
<p>学习一门语言最好的方法就是去使用它。我们就从一个小例子来学习<br />
Clojure语法.</p>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="target">核心语法</span></h2>
<div class="outline-text-2" id="text-2">
<p>首先先来看一下Clojure的核心语法。<br />
Clojure的使用的是Lisp语法,又叫S表达式。核心语法非常的简单。但是对于熟悉c系语法<br />
(c,c++,java)的朋友来说，第一次接触会非常的不习惯。</p>
<ul>
<li>所有代码以"("开始,")"结束。即所有的代码都被()包裹
</li>
<li>"("后的第一个数据被当作函数或者宏来调用
</li>
<li>接着的数据被当作参数传递
</li>
<li>如果想原样返回数据，在"("前面添加"'"。此写法是(quote (&hellip;))的简写
</li>
</ul>
<p>以前面的hello world程序为例。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">println</span> <span style="color: #2aa198;">"Hello World"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
它以"("开始，后面跟的是函数println，接着空格跟的是参数"Hello World"，最后")"结尾。<br />
了解了如上规则，你就基本学会了Clojure的大部分语法。下面比较一下<br />
Clojure,Java,Python,Ruby的一些语法.</p>
<table border="1" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left" />
<col class="left" />
<col class="left" />
<col class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Clojure 表达式</th>
<th scope="col" class="left">对应的 Java 语法</th>
<th scope="col" class="left">对应的 Python 语法</th>
<th scope="col" class="left">对应的 Ruby 语法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">(not k)</td>
<td class="left">!k</td>
<td class="left">not k</td>
<td class="left">not k or !k</td>
</tr>
<tr>
<td class="left">(inc a)</td>
<td class="left">a++、++a、a += 1、a + 1<sup>a</sup></td>
<td class="left">a += 1、a + 1</td>
<td class="left">a += 1</td>
</tr>
<tr>
<td class="left">(/ (+ x y) 2)</td>
<td class="left">(x + y) / 2</td>
<td class="left">(x + y) / 2</td>
<td class="left">(x + y) / 2</td>
</tr>
<tr>
<td class="left">(instance? java. util.List al)</td>
<td class="left">al instanceof java.util.List</td>
<td class="left">isinstance(al,list)</td>
<td class="left">al.is<sub>a</sub>? Array</td>
</tr>
<tr>
<td class="left">(if (not a) (inc b) (dec b))</td>
<td class="left">!a ? b + 1 : b - 1</td>
<td class="left">b + 1 if not a else b-1</td>
<td class="left">!a ? b + 1 : b - 1</td>
</tr>
<tr>
<td class="left">(Math/pow 2 10)<sup>c</sup></td>
<td class="left">Math.pow(2, 10)</td>
<td class="left">pow(2, 10)</td>
<td class="left">2 ** 10</td>
</tr>
<tr>
<td class="left">(.someMethod someObj "foo" (.otherMethod otherObj 0))</td>
<td class="left">someObj.someMethod("foo" , otherObj.otherMethod(0))</td>
<td class="left">someObj.someMethod("foo" , otherObj.otherMethod(0))</td>
<td class="left">someObj.someMethod("foo" , otherObj.otherMethod(0))</td>
</tr>
</tbody>
</table>
<p>可以看出Clojure的语法有高度的一致性，即使你不熟悉S表达式，但是依据上面<br />
的原则，可以看懂它想表达的是一个什么意思。而对于其他三门语言，如果你没<br />
有一个个的学习相应的语法，你还是比较难理解它的意思的。
</p></div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">代码功能</h2>
<div class="outline-text-2" id="text-3">
<p>了解了核心语法，我们就可以来编写代码了。我们要编写的代码功能很简单，进<br />
行简繁翻译，其中过滤不需要翻译以及需要特殊翻译的文字。我们将分几步来完成:</p>
<ul>
<li>读取简繁字典
</li>
<li>进行简繁翻译
</li>
<li>读取不需要翻译的文字
</li>
<li>过滤不翻译的文字
</li>
<li>提供给Java调用
</li>
<li>打包
</li>
</ul>
</div>
<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1">读取简繁字典</h3>
<div class="outline-text-3" id="text-3-1">
<ul>
<li>语法点
<ul>
<li>查看Clojure API
</li>
<li>第一个函数的编写
</li>
<li>Namespace的引入
</li>
<li>正则表达式
</li>
<li>Clojure字面量
</li>
</ul>
</li>
</ul>
<p>
我们先看第一个功能。我们要读取简繁字典。简繁字典其实就是简繁对照的文件，<br />
我这里叫jfmap.clj<br />
格式如下:</p>
<pre class="example">万 萬 与 與 丑 醜 专 專 业 業 丛 叢 东 東 丝 絲 丢 丟 两 兩 严 嚴 丧 喪 个 個 丬 爿 
</pre>
<p>
这里只是简单的列了一点。具体内容请见附件。有了这个文件，我们如何把内容<br />
读出来呢？熟悉Java的都知道，我们要创建文件流来读取，然后要打开流，循环<br />
读取，最后关闭流，还要抓异常。很繁琐。在Clojure中如何处理呢？Clojure提<br />
供了slurp函数，可以根据提供的路径将文件内容读入。API如下:</p>
<pre class="src src-clojure">clojure.core/slurp
<span style="color: #8c8c8c;">(</span>[f &amp; opts]<span style="color: #8c8c8c;">)</span>
  <span style="color: #cb4b16;">Opens</span> a reader on f and reads all its contents, returning a string.
  <span style="color: #cb4b16;">See</span> clojure.java.io/reader for a complete list of supported arguments.
</pre>
<p>
OK。我们知道了要用什么函数。那么根据API和上面说的总规则，我们来写代码.</p>
<ul>
<li>首先是"("
</li>
<li>然后是函数名slurp
</li>
<li>空格，参数。这里是要读取的文件路径
</li>
<li>最后")"
</li>
</ul>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
你可以在REPL里面去实验这行代码的执行结果。执行此行代码，clojure会将jfmap.clj的内容以字符串的形式全部读<br />
入。接着呢？要做简繁翻译，字符串肯定不方便我们的操作。很明显map才是最<br />
适合的数据结构。那么我们如何将字符串变成map呢？<br />
我们只能求助于API了，你可以在<a href="http://clojure.github.io/clojure/api-index.html">Clojure的Index页面</a>搜索map,可以找到<br />
hash-map函数。它的API说明如下:</p>
<pre class="example">hash-map
function
Usage: (hash-map)
       (hash-map &amp; keyvals)
keyval =&gt; key val
Returns a new hash map with supplied mappings.  If any keys are
equal, they are handled as if by repeated uses of assoc.
</pre>
<p>
根据提供的映射关系返回一个新的hashmap。而这里我们是一个字符串，如何提<br />
供映射关系呢？按照空格将文字切开就行了嘛！！继续找API。Java里有split方<br />
法，Clojure里有没有相应的函数呢？试试再说。。有了！在<br />
clojure.string的Namespace<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>中，我们找到了叫split的函数！</p>
<pre class="example">split
function
Usage: (split s re)
       (split s re limit)
Splits string on a regular expression.  Optional argument limit is
the maximum number of splits. Not lazy. Returns vector of the splits.
</pre>
<p>
通过正则表达式来切割字符串。看着挺像，先用再说！我们有repl嘛！直接在<br />
repl里面输入</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
执行!Oops,报错了！</p>
<pre class="example">CompilerException java.lang.RuntimeException: Unable to resolve symbol: split in this context
</pre>
<p>
找不到split?!如果在Java中报类似的错误，你会想到什么？没有引入包阿！这<br />
里也是。在Java中会默认引入java.lang包，同理在Clojure中会引入<br />
clojure.core和java.lang包。其他包则要自己引入，这里split在clojure.string包中。所<br />
以你需要引入clojure.string包。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> 'clojure.string<span style="color: #8c8c8c;">)</span>
</pre>
<p>
这也就是调用了require函数来进行引入！为什么clojure.string前面有个单引<br />
号呢？想想核心语法！这里暂不展开说！给大家留个思考题！！后续会专门对命名空间引入做详细介绍！<br />
光引入还没用！调用代码也需要修改！</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>clojure.string/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
你可能要吐槽了！既然引入了，为什么还要加Namespace前缀？！我们可以和Java作个<br />
比较！如果这里是Java的话，那么我们在调用split的时候，实际上是需要一个<br />
类作为前缀的，比如StringUtils.split()!但是在clojure中并没有类的概念！<br />
Namespace下面只有函数，所以它使用命名空间来确保函数的唯一性引用！<br />
当然了每次都要写这么长的命名空间的名字也是挺烦人的。Clojure提供了简写.</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">require</span> ['clojure.stirng <span style="color: #2aa198;">:as</span> 'cstr]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
:as是Keyword,是Clojure字面量的一种。它和String很类似，不过有些区别，它比String有更多的功能。<br />
下表是Clojure所包含的字面量。</p>
<table border="1" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left" />
<col class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Example(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Boolean</td>
<td class="left">true,false</td>
</tr>
<tr>
<td class="left">Character</td>
<td class="left">\a</td>
</tr>
<tr>
<td class="left">Keyword</td>
<td class="left">:tag,:doc</td>
</tr>
<tr>
<td class="left">List</td>
<td class="left">(1 2 3),(println "foo")</td>
</tr>
<tr>
<td class="left">Map</td>
<td class="left">{:name "Bill",:age 42}</td>
</tr>
<tr>
<td class="left">Nil</td>
<td class="left">nil</td>
</tr>
<tr>
<td class="left">Number</td>
<td class="left">1,4.2</td>
</tr>
<tr>
<td class="left">Set</td>
<td class="left">#{:snap :crackle :pop}</td>
</tr>
<tr>
<td class="left">String</td>
<td class="left">"hello"</td>
</tr>
<tr>
<td class="left">Symbol</td>
<td class="left">user/foo,java.lang.String</td>
</tr>
<tr>
<td class="left">Vector</td>
<td class="left">[1 2 3]</td>
</tr>
</tbody>
</table>
<p>
ok.终于得到了我们要的结果。这里的#" "是正则表达式(这是你遇到的第一个特殊语<br />
法，学习方法&mdash;死记！！)，它构建了Java中的Pattern，所以正则表达式内容<br />
和Java完全相同，这里就不废话了。你只需要记住其语法就行了。<br />
切开了字符串，我们来生成map吧！如何生成呢？你应该有答案了吧？</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">hash-map</span> <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
又报错了！</p>
<pre class="example">IllegalArgumentException No value supplied for key: ["万" "萬"]  clojure.lang.PersistentHashMap.create (PersistentHashMap.java:77)
</pre>
<p>
不合法的参数！！split得到的是个Vector([]包裹的数据结构是Vector),而<br />
hash-map要的参数类似于Java中的可变参数！如何匹配这两者呢？Clojure中提<br />
供了apply函数!API如下</p>
<pre class="src src-clojure">clojure.core/apply
<span style="color: #8c8c8c;">(</span>[f args] [f x args] [f x y args] [f x y z args] [f a b c d &amp; args]<span style="color: #8c8c8c;">)</span>
  <span style="color: #cb4b16;">Applies</span> fn f to the argument list formed by prepending intervening arguments to args.
</pre>
<p>
此函数有点特别！它的第一个参数是函数，后面是该函数所需要的参数！知道<br />
怎么调用吗？</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> hash-map <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #2aa198;">"&#19975; &#33836;"</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
终于成功了！！我们看到了结果</p>
<pre class="src src-clojure">{<span style="color: #2aa198;">"&#19975;"</span> <span style="color: #2aa198;">"&#33836;"</span>}   <span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">&#20197;{}&#21253;&#35065;&#30340;&#25968;&#25454;&#32467;&#26500;&#26159;map</span>
</pre>
<p>
最后呢！我们需要对jfmap.clj的内容进行处理！So easy!</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> hash-map <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">)</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
</div>
</div>
<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2">进行简繁翻译</h3>
<div class="outline-text-3" id="text-3-2">
<ul>
<li>语法点
<ul>
<li>var的定义
</li>
<li>函数的定义
</li>
<li>闭包的使用
</li>
</ul>
</li>
</ul>
<p>
上一节我们完成了对jfmap.clj的读取，并生成了hashmap。但是呢，如果我们<br />
每次要使用jfmap.clj的时候都要写</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> hash-map <span style="color: #8c8c8c;">(</span>cstr/split <span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">)</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
太麻烦了。在Java中的可以将其封装为一个方法来进行调用。Clojure也可以将<br />
其封装为函数:</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">read-map</span>
  <span style="color: #93a1a1; font-style: italic;">"Read trans map from file"</span>
  [path]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">apply</span> hash-map <span style="color: #8c8c8c;">(</span>clstr/split <span style="color: #8c8c8c;">(</span><span style="color: #859900;">slurp</span> path<span style="color: #8c8c8c;">)</span> #<span style="color: #2aa198;">" "</span><span style="color: #8c8c8c;">)))</span>
</pre>
<p>
defn是个宏，宏的定义后面讨论。defn是用来定义有名函数的。read-map就是函<br />
数名，和Java中的驼峰式取名不同，List系的取名方式一般是使用-。给出的原<br />
因是大写字母要按两个按键，-只需要按一个按键！！紧接着函数名的是注释，<br />
类似Java中的注释，不同的是其双引号内的内容可以多行。后面的vector是参数<br />
列表，最后就是函数体了。<br />
现在当你再读取jfmap的时候。只需要这样调用:</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span>read-map <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
比刚才简单了很多。但是每次都要去读取，还是不够方便。在Java中会将其赋值<br />
给一个变量，然后去调用。Clojure当然也可以。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">jfmap</span> <span style="color: #8c8c8c;">(</span>read-map <span style="color: #2aa198;">"jfmap-path"</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
然后你直接操作jfmap就可以了。<br />
现在我们就来按照jfmap来进行简繁翻译吧！<br />
你可能会想，很简单吧？只需要遍历需要翻译的字符串，然后到jfmap中去找对应的翻译，然<br />
后将翻译组装成字符串就行了。so easy!但当你这么想的时候，你已经陷入到了<br />
实现的细节中了！Clojure让你能够更加的关注业务而不是实现细节！<br />
这里给出的建议是：<br />
<b>请先查找Clojure是否可通过函数组合来解决问题？如果不能再考虑自己编写函 数！</b><br />
为什么这么说呢？因为在Clojure中大部分的问题都可以通过其提供的函数组合<br />
来解决。你需要做的就是根据需要来组合函数！这使你能更多的思考业务而非实<br />
现细节！比如这里的问题！<br />
我们需要一个函数：</p>
<ol>
<li>接受一个字符串
</li>
<li>返回翻译完成的字符串
</li>
</ol>
<p>很简单，我们先编写函数的定义。这里我们叫translate。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
<span style="color: #8c8c8c;">)</span>
</pre>
<p>
然后呢？需要翻译字符串。这里叫翻译字符串，实际上就是根据map的key找到<br />
value而已。在Clojure中找到这样的函数就可以了。你可以找到get函数。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> map k default<span style="color: #8c8c8c;">)</span>
</pre>
<p>
很好理解吧？根据k从map中查找value，如果找不到则返回default。其实这就是<br />
核心代码了！我们知道map就是我们这里的jfmap，k实际上是获取的字符串的每<br />
个字符，而default呢？这里如果我们根据k找不到的话，就直接返回k，也就是<br />
不翻译了。所以代码修改为:</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap k k<span style="color: #8c8c8c;">)</span>
</pre>
<p>
现在只需要解决k就行了！继续寻找函数！现在需要的是在Clojure中用得还比较<br />
多的一个函数&mdash;map!</p>
<pre class="src src-clojure">clojure.core/map
<span style="color: #8c8c8c;">(</span>[f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 &amp; colls]<span style="color: #8c8c8c;">)</span>
  <span style="color: #cb4b16;">Returns</span> a lazy sequence consisting of the result of applying f to the
  set of first items of each coll, followed by applying f to the set
  of second items in each coll, until any one of the colls is
  exhausted.  <span style="color: #cb4b16;">Any</span> remaining items in other colls are ignored. <span style="color: #cb4b16;">Function</span>
  f should accept number-of-colls arguments.
</pre>
<p>
看到作用了吗？将函数应用到序列的每个元素上去！并返回一个由结果组成的<br />
lazy序列！你可能会问了：这是针对序列的，对字符串有效吗？试试不就知道了？</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> class <span style="color: #2aa198;">"aaa"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
在repl里面输入如上的代码！你看到了什么？java.lang.Character?!没错，字<br />
符串会被当作字符序列来操作！但是我们需要的是字符串啊？没关系，我们有<br />
str函数!</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">comp</span> class str<span style="color: #8c8c8c;">)</span> <span style="color: #2aa198;">"aaa"</span><span style="color: #8c8c8c;">)</span>
</pre>
<p>
comp是个什么东东？它的作用是将多个函数组合起来，从右向左的执行！！这里<br />
就是先执行str在执行class,可以看到结果打印的是java.lang.String,正是我们<br />
需要的。<br />
OK，现在我们来组合这两个函数就行了.但是问题又来了！map的第二个参数是个函数，<br />
我们怎么办呢？既然它需要函数，那我们就定义一个给它咯！</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">tmp</span> [k]
   <span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap k k<span style="color: #8c8c8c;">))</span>

<span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> tmp s<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">)</span>
</pre>
<p>
你可能要抱怨了！取了个什么烂名字！！居然叫tmp?!呵呵，别急！我把函数定<br />
义为tmp，是因为我要将优化掉！可以看出，这个功能非常的简单，而且只会给<br />
translate使用，那么我们需要特意定义一个单独的函数吗？<br />
不需要吧？我们直接将两个函数合并好了！</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">tmp</span> [k] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap k k<span style="color: #8c8c8c;">))</span> s<span style="color: #8c8c8c;">))</span>
</pre>
<p>
很简单，但是呢！既然都放到函数内部了！还需要函数名吗？就像Java中的匿名<br />
内部类一样，直接定义直接使用，不需要名字！在Clojure中有fn这个special<br />
form来定义匿名函数！<br />
上面说defn是个宏！它的功能就类似于(还有其他功能，比如注释)：</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">def</span> <span style="color: #268bd2;">tmp</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [k] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap k k<span style="color: #8c8c8c;">)))</span>
</pre>
<p>
我们使用fn来简化一下代码!</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">fn</span> [k] <span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap k k<span style="color: #8c8c8c;">))</span> s<span style="color: #8c8c8c;">))</span>
</pre>
<p>
舒服很多！还能更简单吗？当然！Clojure提供了#这个语法糖来定义匿名函数!</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> #<span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap k k<span style="color: #8c8c8c;">)</span> s<span style="color: #8c8c8c;">))</span>
</pre>
<p>
好！问题来了！这里没有了参数列表！那get函数怎么知道k是个什么东西呢？所<br />
以，这里使用%来替换，第一个参数用%或者%1替换，第二个则是%2,依次类推！</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> #<span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap % %<span style="color: #8c8c8c;">)</span> s<span style="color: #8c8c8c;">))</span>
</pre>
<p>
搞定了吗？没有！translate需要返回一个字符串，而map返回的是个lazy序列！<br />
需要将序列转化为字符串！到clojure.string找找！有个join函数</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">translate</span>
  <span style="color: #93a1a1; font-style: italic;">"Trans string by map"</span>
  [s]
  <span style="color: #8c8c8c;">(</span>clstr/<span style="color: #b58900;">join</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">map</span> #<span style="color: #8c8c8c;">(</span><span style="color: #859900;">get</span> jfmap % %<span style="color: #8c8c8c;">)</span> s<span style="color: #8c8c8c;">)))</span>
</pre>
<p>
不废话了！记得要引入Namespace哦！！<br />
实际上一行代码我们就搞定了基本的翻译了！很简单吧？</p>
</div>
</div>
<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3">读取不需要翻译的文字</h3>
<div class="outline-text-3" id="text-3-3">
<ul>
<li>复习
</li>
</ul>
<p>翻译的字，是使用的map来存储的？那不需要翻译的文字该如何存储呢？这要看<br />
你如何处理了！我这里采用的是一个很简单的方式！</p>
<ol>
<li>首先对文字全文翻译
</li>
<li>然后对翻译后的文字再反翻译
</li>
</ol>
<p>比如说，"阿里山"直接翻译的话，那么就会变成"阿裡山"，但是"里"字是不需要<br />
翻译的。那么我就新建一个map，保存"阿裡山"-&gt;"阿里山"，将文字再翻回来！<br />
那么这里我就再需要一个类似jfmap.clj的文件就可以了。我这里叫ntmap.clj。<br />
格式和jfmap.clj类似！只不过里面存储的是需要反翻译的文字!<br />
如何读取和组装map?不需要我废话吧？</p>
</div>
</div>
<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4">过滤不翻译的文字</h3>
<div class="outline-text-3" id="text-3-4">
<ul>
<li>Special Form
<ul>
<li>let
</li>
<li>loop
</li>
<li>if
</li>
<li>recur
</li>
</ul>
</li>
</ul>
<p>过滤不翻译的文字，实际上就是反翻译!如何进行呢？原来在翻译的过程中我们<br />
是一个字符一个字符的匹配的！但是这里是一个一个的字符串！这就比较难办了！<br />
不管怎么说我们先定义函数!</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">do-trans</span>
  [s tmap ntmap]
   <span style="color: #8c8c8c;">)</span>
</pre>
<p>
首先第一件事就是去全文翻译！然后获得结果！提供给后续函数使用！Java中有<br />
局部变量！只需要将变量写在方法里就可以了！但是在Clojure中不同，它需要<br />
通过let这个Special Form来处理。</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">do-trans</span>
  [s tmap ntmap]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [re <span style="color: #8c8c8c;">(</span>translate s tmap<span style="color: #8c8c8c;">)</span>]

<span style="color: #8c8c8c;">))</span>
</pre>
<p>
let后面是个Vector，用来进行var绑定，这里translate翻译的结果会被绑定到<br />
re这个var上！而re的作用范围就只在let这个括号内部！接着呢！就是对re进行<br />
反翻译！没啥现成的函数了！只能自己处理！代码如下！</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">do-trans</span>
  [s tmap ntmap]
  <span style="color: #8c8c8c;">(</span><span style="color: #859900;">let</span> [re <span style="color: #8c8c8c;">(</span>translate s tmap<span style="color: #8c8c8c;">)</span>]
    <span style="color: #8c8c8c;">(</span><span style="color: #859900;">loop</span> [result re
           k <span style="color: #8c8c8c;">(</span><span style="color: #859900;">keys</span> ntmap<span style="color: #8c8c8c;">)</span>]
      <span style="color: #8c8c8c;">(</span><span style="color: #859900;">if</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">seq</span> k<span style="color: #8c8c8c;">)</span>
        <span style="color: #8c8c8c;">(</span><span style="color: #859900;">recur</span> <span style="color: #8c8c8c;">(</span>clstr/<span style="color: #b58900;">replace</span> result <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> k<span style="color: #8c8c8c;">)</span> <span style="color: #8c8c8c;">(</span>ntmap <span style="color: #8c8c8c;">(</span><span style="color: #859900;">first</span> k<span style="color: #8c8c8c;">)))</span> <span style="color: #8c8c8c;">(</span><span style="color: #859900;">rest</span> k<span style="color: #8c8c8c;">))</span>
          result<span style="color: #8c8c8c;">))))</span>
</pre>
<p>
loop又是个Special Form，看起来像循环！实际上它是个递归！loop后面也是<br />
个参数Vector，功能和let的相同！这里将re绑定到了result，以及ntmap的key<br />
绑定到了k上！<br />
然后是if判断，还是个Special Form，(seq k)判断k是否是个序列！如果是则执<br />
行recur，如果不是则返回result.其实seq并不是判断函数！它是用来构建序列<br />
的！这里之所以能用来判断，基于两个原因：</p>
<ol>
<li>在Clojure中除了nil和false是假，其他全是真
</li>
<li>(seq nil)和(seq ())返回nil
</li>
</ol>
<p>然后seq就可以用来作为判断条件了！<br />
recur是递归调用！这里调用的是loop，传递的参数是替换后的s和剩余的k.<br />
实际功能就是，遍历ntmap中的key，如果找到了，则使用value替换掉！<br />
至此，就完成了翻译的所有功能！考虑下如果使用Java需要多少行代码？？<br />
测试翻译一个页面的时间为70毫秒左右，速度还是不错的！</p>
</div>
</div>
<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5">提供给Java调用</h3>
<div class="outline-text-3" id="text-3-5">
<p>Clojure提供了将函数给Java调用的功能！<br />
首先，在core.clj文件中编写函数，比如下面的翻译:</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">defn</span> <span style="color: #268bd2;">-transAll</span>
  <span style="color: #93a1a1; font-style: italic;">"&#32763;&#35793;&#25152;&#26377;"</span>
  [source <span style="color: #cb4b16;">mapPath</span>]
  <span style="color: #8c8c8c;">(</span>trans/translate source <span style="color: #8c8c8c;">(</span>trans/read-map <span style="color: #cb4b16;">mapPath</span><span style="color: #8c8c8c;">)</span> <span style="color: #2aa198;">""</span><span style="color: #8c8c8c;">))</span>
</pre>
<p>
函数名前面一定要有个"-"。<br />
然后在命名空间里添加如下代码</p>
<pre class="src src-clojure"><span style="color: #8c8c8c;">(</span><span style="color: #859900;">ns</span> jft.core
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">&#36825;&#37324;&#24320;&#22987; </span>
 <span style="color: #8c8c8c;">(</span><span style="color: #2aa198;">:gen-class</span>
   <span style="color: #2aa198;">:name</span> <span style="color: #cb4b16;">jft.core.Trans</span>
   <span style="color: #2aa198;">:methods</span> [#^{<span style="color: #2aa198;">:static</span> true} [<span style="color: #cb4b16;">transAll</span> [<span style="color: #cb4b16;">String</span> <span style="color: #cb4b16;">String</span>] <span style="color: #cb4b16;">String</span>]]<span style="color: #8c8c8c;">)</span>
<span style="color: #93a1a1; font-style: italic;">;</span><span style="color: #93a1a1; font-style: italic;">&#36825;&#37324;&#32467;&#26463;</span>
  <span style="color: #8c8c8c;">(</span><span style="color: #2aa198;">:require</span> [clojure.string <span style="color: #2aa198;">:as</span> cstr]
            [jft.trans <span style="color: #2aa198;">:as</span> trans]<span style="color: #8c8c8c;">)</span>
<span style="color: #8c8c8c;">)</span>
</pre>
<p>
应该不难理解吧？name是在Java中import的时候的名字！methods是可以调用的<br />
方法,这里注解为静态方法！注意这里的transAll前面是没有"-"的，后面是参数<br />
和返回类型！</p>
</div>
</div>
<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6">打包</h3>
<div class="outline-text-3" id="text-3-6">
<p>需要给Java调用，那就要先封装为jar包。非常简单</p>
<pre class="src src-sh">lein jar
</pre>
<p>
然后就可以提供给Java调用了！</p>
</div>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">源码</h2>
<div class="outline-text-2" id="text-4">
<p><a href="http://www.ivanpig.com/blog/wp-content/uploads/2014/01/wpid-jft2.zip">jft</a></p>
<div id="footnotes">
<h2 class="footnotes">脚注: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> Namespace和Java中的包类似，但是在Clojure中叫Namespace。这里没有<br />
将其翻译为命名空间，主要是怕有误解。</p>
</div>
</div>
</div>
</div>



            <a href="/clojure/clojure%25e6%2595%2599%25e7%25a8%258b-%25e5%259f%25ba%25e6%259c%25ac%25e8%25af%25ad%25e6%25b3%2595.html" class="post-categorybut">阅读全文</a>
        </div>
    </section>


<div class="pure-g pagination">
    
    
    <a class="pure-u-1-2 pagination-item" href="/"><p>← Newer</p></a>
    
    


    
    <a class=" pure-u-1-2 pagination-item" href="/page/3"><p>Older →</p></a>
    
</div>








            </div>
            </div>
        <div class="footer">
                <a href="/love/welcome-my-blog.html">About</a>
                 <a href="/1">Collecting</a>
                <a href="tencent://message/?uin=561802774">QQ</a>
                <a href="https://github.com/ivanpig">GitHub</a>
            <script src="/js/min/nprogress.min.js"></script>
            <script src="/js/index.js"></script>
        </div>
        <div class="topfade"><a href="javascript:;" title="返回顶部"></a></div>

    </div>

</div>

</body>

</html>
